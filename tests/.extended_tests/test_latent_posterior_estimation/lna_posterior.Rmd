---
title: "LNA - Latent posterior recovery"
author: "Jon Fintzi"
date: "September 15, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(stemr)
setwd("C:/Users/Jonathan/Google Drive/UW/Year 3 +/Dissertation/Code/stemr/tests/.extended_tests/test_latent_posterior_estimation")

```

## Description
This test attempts to use the LNA to estimate the posterior distribution of the latent process in the fixed parameter case. Updates to the latent process are carried out via elliptical slice sampling. We carry out the procedure for the simple SIR model under two different measurement processes, negative binomial prevalence and negative binomial incidence.

```{r, include = FALSE, cache = TRUE}
# number of iterations and objects to store the paths
iterations        <- 100000
thin_latent_paths <- 100

# set up model
compartments <- c("S","I","R")
rates <- list(rate("beta * I", "S", "I", incidence = FALSE),
              rate("mu", "I", "R"))
init_state = c(50000,10,50)
state_initializer <- stem_initializer(c(S = 50000, I = 10, R = 50), fixed = T)
parameters <- c(beta = 0.00001, mu = 1/7, rho = 0.5)
tcovar <- NULL
constants <- NULL
strata <- NULL
t0 <- 0; tmax <- 52
timestep <- NULL
adjacency <- NULL
messages <- T
nsim = 1
census_times = 0:tmax

# compile dynamics
dynamics <- stem_dynamics(rates = rates, parameters = parameters, tmax = tmax, state_initializer = state_initializer, compartments=compartments, strata = strata, tcovar = tcovar, messages = TRUE, compile_ode = F, compile_rates = T)

# compile the measurement process
emissions <- list(emission("I", "negbinomial", c("I", "I * rho"), incidence = FALSE, obstimes = seq(0,tmax,by=1)))

measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, messages = T)
stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process) 

stem_data <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = 1, census_times = 0:tmax)

# grab the dataset
true_path <- stem_data$natural_paths[[1]]
dat <- stem_data$datasets[[1]]

colnames(true_path) <- c("time", "S", "I", "R")
colnames(dat) <- c("time", "I")

# recompile the measurement process
measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, data = dat)
stem_object <- stem(stem_object = stem_object, measurement_process = measurement_process)

# extract the model objects from the stem_object
flow_matrix            <- stem_object$dynamics$flow_matrix_lna
lna_pointer            <- stem_object$dynamics$lna_pointers$lna_pointer
lna_pointer_ess        <- stem_object$dynamics$lna_pointers$lna_pointer_ess
lna_set_pars_pointer   <- stem_object$dynamics$lna_pointers$lna_set_pars_ptr
parameters             <- stem_object$dynamics$parameters
constants              <- stem_object$dynamics$constants
initdist_parameters    <- stem_object$dynamics$initdist_params
lna_initdist_inds      <- stem_object$dynamics$lna_initdist_inds
n_compartments         <- ncol(flow_matrix)
n_rates                <- nrow(flow_matrix)
n_odes                 <- 2*n_rates + n_rates^2
comp_codes             <- stem_object$dynamics$lna_comp_codes
incidence_codes        <- stem_object$dynamics$incidence_codes_lna
n_incidence            <- length(incidence_codes)
fixed_inits            <- stem_object$dynamics$fixed_inits
n_strata               <- stem_object$dynamics$n_strata

# measurement process objects
data                    <- stem_object$measurement_process$data
measproc_indmat         <- stem_object$measurement_process$measproc_indmat
d_meas_pointer          <- stem_object$measurement_process$meas_pointers$d_measure_ptr
obstimes                <- data[,1]
obstime_inds            <- stem_object$measurement_process$obstime_inds
tcovar_censmat          <- stem_object$measurement_process$tcovar_censmat
emit_mat_cur            <- cbind(obstimes, matrix(0.0,
                                                   nrow = nrow(stem_object$measurement_process$measproc_indmat),
                                                   ncol = ncol(stem_object$measurement_process$measproc_indmat),
                                                   dimnames = list(NULL,
                                                                   colnames(stem_object$measurement_process$measproc_indmat))))
emit_mat_new            <- cbind(obstimes, matrix(0.0,
                                                   nrow = nrow(stem_object$measurement_process$measproc_indmat),
                                                   ncol = ncol(stem_object$measurement_process$measproc_indmat),
                                                   dimnames = list(NULL,
                                                                   colnames(stem_object$measurement_process$measproc_indmat))))

# generate other derived objects
lna_times               <- sort(unique(c(obstimes,
                                       stem_object$dynamics$.dynamics_args$tcovar[,1],
                                       stem_object$dynamics$t0,
                                       stem_object$dynamics$tmax)))
n_times                 <- length(lna_times)
n_census_times          <- length(obstimes)
param_update_inds       <- is.na(match(lna_times, obstimes))
do_census               <- !identical(lna_times, data[,1])
do_incidence            <- !is.null(incidence_codes)

# matrix for storing the LNA parameters
lna_parameters         <- matrix(0.0, nrow = length(lna_times), ncol = length(stem_object$dynamics$lna_param_codes),
                                  dimnames = list(NULL,names(stem_object$dynamics$lna_param_codes)))

# insert the lna parameters
pars2lnapars(lna_parameters, parameters)

# get column indices for constants and time-varying covariates
const_inds             <- seq_along(stem_object$dynamics$const_codes) + length(stem_object$dynamics$param_codes)
tcovar_inds            <- (max(const_inds)+1):ncol(lna_parameters)

# insert the constants
lna_parameters[,const_inds] <- matrix(stem_object$dynamics$constants,
                                  nrow = nrow(lna_parameters),
                                  ncol = length(const_inds), byrow = T)

# insert time varying covariates
if(!is.null(stem_object$dynamics$dynamics_args$tcovar)) {
        tcovar_rowinds                 <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
        lna_parameters[, tcovar_inds]  <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
}

# initialize the latent path
path <- initialize_lna(lna_parameters          = lna_parameters,
                       flow_matrix             = flow_matrix,
                       lna_pointer             = lna_pointer,
                       lna_set_pars_pointer    = lna_set_pars_pointer,
                       lna_times               = lna_times,
                       fixed_inits             = fixed_inits,
                       param_update_inds       = param_update_inds,
                       incidence_codes         = incidence_codes,
                       data                    = data,
                       measproc_indmat         = measproc_indmat,
                       obstime_inds            = obstime_inds,
                       d_meas_pointer          = d_meas_pointer,
                       parameters              = parameters,
                       constants               = constants,
                       tcovar_censmat          = tcovar_censmat,
                       initialization_attempts = 500)

path <- lna_density2(path              = path,
                     lna_times         = lna_times,
                     lna_pars          = lna_parameters,
                     param_update_inds = param_update_inds,
                     flow_matrix       = flow_matrix,
                     lna_pointer_ess   = lna_pointer_ess,
                     set_pars_pointer  = lna_set_pars_pointer)

# save the data log-likelihood and the lna log-likelihood
data_log_lik <- double(iterations + 1)
lna_log_lik <- double(iterations + 1)
data_log_lik[1] <- path$data_log_lik
lna_log_lik[1]  <- path$lna_log_lik

# set up objects to store the latent paths
latent_paths <- vector(mode = "list", length = iterations / 100)
latent_paths[[1]] <- convert_lna(path$lna_path, flow_matrix, init_state)

for(k in 2:iterations) {
        
        if(k%%1000 == 0) {
                # print(k)
                cat(paste0("Prevalence iteration ", k), sep = "\n", file = "lna_post_fixedpars.txt", append = TRUE)
        }
                
        
        path <- update_lna_path(path_cur  = path,
                        lna_parameters    = lna_parameters,
                        flow_matrix       = flow_matrix,
                        lna_ess_pointer   = lna_ess_pointer,
                        lna_times         = lna_times,
                        lna_initdist_inds = lna_initdist_inds,
                        param_update_inds = param_update_inds,
                        incidence_codes   = incidence_codes,
                        data              = data,
                        measproc_indmat   = measproc_indmat,
                        obstime_inds      = obstime_inds,
                        d_meas_pointer    = d_meas_pointer,
                        parameters        = parameters,
                        constants         = constants,
                        tcovar_censmat    = tcovar_censmat,
                        do_census         = do_census,
                        do_incidence      = do_incidence)
        
        data_log_lik[k] <- path$data_log_lik
        lna_log_lik[k]  <- path$lna_log_lik
        
        if(k %% thin_latent_paths == 0) {
                latent_paths[[k/thin_latent_paths]] <- convert_lna(path$lna_path, flow_matrix, init_state)
        }
}

library(mcmc)
library(ggplot2)

paths <- array(unlist(latent_paths), dim = c(nrow(latent_paths[[1]]), ncol(latent_paths[[1]]), length(latent_paths)))
colnames(paths) <- c("time", "S", "I", "R")

# paths of the I compartment
I_paths <- paths[,"I",]

# matrix for storing results
results <- data.frame(time = 0:52, mean = rowMeans(I_paths), mcse = 0)
results_quantiles <- data.frame(time  = 0:52, 
                                med   = apply(I_paths, 1, median), 
                                lower = apply(I_paths, 1, quantile, 0.025),
                                upper = apply(I_paths, 1, quantile, 0.975))

# variance of the sample mean of the markov chain
vars <- rep(0, nrow(results))
for(k in 1:length(vars)) {
        vars[k] <- initseq(I_paths[k,])$var.pos
}

# monte carlo standard error
results$mcse <- sqrt(vars) / sqrt(ncol(I_paths))

# produce the plot
pdf("lna_post_prev.pdf")
print(ggplot(results, aes(x = time, y = mean)) + geom_ribbon(aes(ymin = mean - 1.96 * mcse, ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from prevalence data - mean and MCSE bands"))

print(ggplot(results_quantiles, aes(x = time, y = med)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from prevalence data - quantiles"))
dev.off()
```

```{r, include = FALSE, cache = TRUE}
rm(list=ls())
library(stemr)
# number of iterations and objects to store the paths
iterations        <- 100000
thin_latent_paths <- 100

# set up model
compartments <- c("S","I","R")
rates <- list(rate("beta * I", "S", "I", incidence = TRUE),
              rate("mu", "I", "R"))
init_state = c(50000,10,50)
state_initializer <- stem_initializer(c(S = 50000, I = 10, R = 50), fixed = T)
parameters <- c(beta = 0.00001, mu = 1/7, rho = 0.5)
tcovar <- NULL
constants <- NULL
strata <- NULL
t0 <- 0; tmax <- 52
timestep <- NULL
adjacency <- NULL
messages <- T
nsim = 1
census_times = 0:tmax

# compile dynamics
dynamics <- stem_dynamics(rates = rates, parameters = parameters, tmax = tmax, state_initializer = state_initializer, compartments=compartments, strata = strata, tcovar = tcovar, messages = TRUE, compile_ode = F, compile_rates = T)

# compile the measurement process
emissions <- list(emission("cases", "negbinomial", c("S2I", "S2I * rho"), incidence = TRUE, obstimes = seq(1,tmax,by=1)))

measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, messages = T)
stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process)

stem_data <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = 1, census_times = 0:tmax)

# grab the dataset
true_path_incid <- stem_data$paths[[1]]; 
true_path_incid[2:nrow(true_path_incid),-1] <- diff(true_path_incid[,-1]); 
true_path_incid <- true_path_incid[-1,] 
true_path_prev <- stem_data$natural_paths[[1]]; colnames(true_path_prev) <- c("time", "S", "I", "R")
dat <- stem_data$datasets[[1]]

# recompile the measurement process
measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, data = dat)
stem_object <- stem(stem_object = stem_object, measurement_process = measurement_process)

# extract the model objects from the stem_object
flow_matrix            <- stem_object$dynamics$flow_matrix_lna
lna_pointer            <- stem_object$dynamics$lna_pointers$lna_pointer
lna_pointer_ess        <- stem_object$dynamics$lna_pointers$lna_pointer_ess
lna_set_pars_pointer   <- stem_object$dynamics$lna_pointers$lna_set_pars_ptr
parameters             <- stem_object$dynamics$parameters
constants              <- stem_object$dynamics$constants
initdist_parameters    <- stem_object$dynamics$initdist_params
lna_initdist_inds      <- stem_object$dynamics$lna_initdist_inds
n_compartments         <- ncol(flow_matrix)
n_rates                <- nrow(flow_matrix)
n_odes                 <- 2*n_rates + n_rates^2
comp_codes             <- stem_object$dynamics$lna_comp_codes
incidence_codes        <- stem_object$dynamics$incidence_codes_lna
n_incidence            <- length(incidence_codes)
fixed_inits            <- stem_object$dynamics$fixed_inits
n_strata               <- stem_object$dynamics$n_strata

# measurement process objects
data                    <- stem_object$measurement_process$data
measproc_indmat         <- stem_object$measurement_process$measproc_indmat
d_meas_pointer          <- stem_object$measurement_process$meas_pointers$d_measure_ptr
obstimes                <- data[,1]
obstime_inds            <- stem_object$measurement_process$obstime_inds
tcovar_censmat          <- stem_object$measurement_process$tcovar_censmat
emit_mat_cur            <- cbind(obstimes, matrix(0.0,
                                                   nrow = nrow(stem_object$measurement_process$measproc_indmat),
                                                   ncol = ncol(stem_object$measurement_process$measproc_indmat),
                                                   dimnames = list(NULL,
                                                                   colnames(stem_object$measurement_process$measproc_indmat))))
emit_mat_new            <- cbind(obstimes, matrix(0.0,
                                                   nrow = nrow(stem_object$measurement_process$measproc_indmat),
                                                   ncol = ncol(stem_object$measurement_process$measproc_indmat),
                                                   dimnames = list(NULL,
                                                                   colnames(stem_object$measurement_process$measproc_indmat))))

# generate other derived objects
lna_times               <- sort(unique(c(obstimes,
                                       stem_object$dynamics$.dynamics_args$tcovar[,1],
                                       stem_object$dynamics$t0,
                                       stem_object$dynamics$tmax)))
n_times                 <- length(lna_times)
n_census_times          <- length(obstimes)
param_update_inds       <- is.na(match(lna_times, obstimes))
do_census               <- !identical(lna_times, data[,1])
do_incidence            <- !is.null(incidence_codes)

# matrix for storing the LNA parameters
lna_parameters         <- matrix(0.0, nrow = length(lna_times), ncol = length(stem_object$dynamics$lna_param_codes),
                                  dimnames = list(NULL,names(stem_object$dynamics$lna_param_codes)))

# insert the lna parameters
pars2lnapars(lna_parameters, parameters)

# get column indices for constants and time-varying covariates
const_inds             <- seq_along(stem_object$dynamics$const_codes) + length(stem_object$dynamics$param_codes)
tcovar_inds            <- (max(const_inds)+1):ncol(lna_parameters)

# insert the constants
lna_parameters[,const_inds] <- matrix(stem_object$dynamics$constants,
                                  nrow = nrow(lna_parameters),
                                  ncol = length(const_inds), byrow = T)

# insert time varying covariates
if(!is.null(stem_object$dynamics$dynamics_args$tcovar)) {
        tcovar_rowinds                 <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
        lna_parameters[, tcovar_inds]  <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
}

# initialize the latent path
path <- initialize_lna(lna_parameters          = lna_parameters,
                       flow_matrix             = flow_matrix,
                       lna_pointer             = lna_pointer,
                       lna_set_pars_pointer    = lna_set_pars_pointer,
                       lna_times               = lna_times,
                       fixed_inits             = fixed_inits,
                       param_update_inds       = param_update_inds,
                       incidence_codes         = incidence_codes,
                       data                    = data,
                       measproc_indmat         = measproc_indmat,
                       obstime_inds            = obstime_inds,
                       d_meas_pointer          = d_meas_pointer,
                       parameters              = parameters,
                       constants               = constants,
                       tcovar_censmat          = tcovar_censmat,
                       initialization_attempts = 500)

path <- lna_density2(path              = path,
                     lna_times         = lna_times,
                     lna_pars          = lna_parameters,
                     param_update_inds = param_update_inds,
                     flow_matrix       = flow_matrix,
                     lna_pointer_ess   = lna_pointer_ess,
                     set_pars_pointer  = lna_set_pars_pointer)

# save the data log-likelihood and the lna log-likelihood
data_log_lik <- double(iterations + 1)
lna_log_lik <- double(iterations + 1)
data_log_lik[1] <- path$data_log_lik
lna_log_lik[1]  <- path$lna_log_lik

# set up objects to store the latent paths
latent_paths_prevalence <- latent_paths_incidence <- vector(mode = "list", length = iterations / 100)
latent_paths_incidence[[1]]  <- path$lna_path[-1,];
latent_paths_incidence[[1]][,-1] <- diff(path$lna_path[,-1])
latent_paths_prevalence[[1]] <- convert_lna(path$lna_path, flow_matrix, init_state)

cat("Starting incidence", sep = "\n", file = "lna_post_fixedpars.txt", append = T) 

for(k in 2:iterations) {
        
        if(k%%1000 == 0) {
                cat(paste0("Incidence iteration ", k), sep = "\n", file = "lna_post_fixedpars.txt", append = TRUE)
        }
                
        
        path <- update_lna_path(path_cur  = path,
                        lna_parameters    = lna_parameters,
                        flow_matrix       = flow_matrix,
                        lna_ess_pointer   = lna_ess_pointer,
                        lna_times         = lna_times,
                        lna_initdist_inds = lna_initdist_inds,
                        param_update_inds = param_update_inds,
                        incidence_codes   = incidence_codes,
                        data              = data,
                        measproc_indmat   = measproc_indmat,
                        obstime_inds      = obstime_inds,
                        d_meas_pointer    = d_meas_pointer,
                        parameters        = parameters,
                        constants         = constants,
                        tcovar_censmat    = tcovar_censmat,
                        do_census         = do_census,
                        do_incidence      = do_incidence)
        
        data_log_lik[k] <- path$data_log_lik
        lna_log_lik[k]  <- path$lna_log_lik
        
        if(k %% thin_latent_paths == 0) {
                latent_paths_incidence[[k/thin_latent_paths]] <- diff(path$lna_path)
                latent_paths_incidence[[k/thin_latent_paths]][,1] <- 1:52
                latent_paths_prevalence[[k/thin_latent_paths]] <- convert_lna(path$lna_path, flow_matrix, init_state)
        }
}

library(mcmc)
library(ggplot2)

paths_prev <- array(unlist(latent_paths_prevalence), dim = c(nrow(latent_paths_prevalence[[1]]), ncol(latent_paths_prevalence[[1]]), length(latent_paths_prevalence)))
colnames(paths_prev) <- c("time", "S", "I", "R")
paths_incid <- array(unlist(latent_paths_incidence), dim = c(nrow(latent_paths_incidence[[1]]), ncol(latent_paths_incidence[[1]]), length(latent_paths_incidence)))
colnames(paths_incid) <- c("time", "S2I", "I2R")

# paths of the I compartment
I_paths_prev <- paths_prev[,"I",]
I_paths_incid <- paths_incid[,"S2I",]

# matrix for storing results
results_prev <- data.frame(time = 0:52, mean = rowMeans(I_paths_prev), mcse = 0)
results_quantiles_prev <- data.frame(time  = 0:52, med   = apply(I_paths_prev, 1, median), 
                                     lower = apply(I_paths_prev, 1, quantile, 0.025),
                                     upper = apply(I_paths_prev, 1, quantile, 0.975))

results_incid <- data.frame(time = 1:52, mean = rowMeans(I_paths_incid), mcse = 0)
results_quantiles_incid <- data.frame(time  = 1:52, med   = apply(I_paths_incid, 1, median), 
                                     lower = apply(I_paths_incid, 1, quantile, 0.025),
                                     upper = apply(I_paths_incid, 1, quantile, 0.975))

# variance of the sample mean of the markov chain
vars_prev <- rep(0, nrow(results_prev))
for(k in 1:length(vars_prev)) {
        vars_prev[k] <- initseq(I_paths_prev[k,])$var.pos
}

vars_incid <- rep(0, nrow(results_incid))
for(k in 1:length(vars_incid)) {
        vars_incid[k] <- initseq(I_paths_incid[k,])$var.pos
}

# monte carlo standard error
results_prev$mcse <- sqrt(vars_prev) / sqrt(ncol(I_paths_prev))
results_incid$mcse <- sqrt(vars_incid) / sqrt(ncol(I_paths_incid))

pdf("lna_post_incid.pdf")
# produce the plot
print(ggplot(results_prev, aes(x = time, y = mean)) + geom_ribbon(aes(ymin = mean - 1.96 * mcse, ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_prev), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from incidence data - mean and MCSE bands"))

print(ggplot(results_quantiles_prev, aes(x = time, y = med)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_prev), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from incidence data - quantiles"))

print(ggplot(results_incid, aes(x = time, y = mean)) + geom_ribbon(aes(ymin = mean - 1.96 * mcse, ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_incid), aes(x = time, y = S2I), colour = "red") + labs(x = "time", y = "S2I", title = "Pointwise Incidence from incidence data - mean and MCSE bands"))

print(ggplot(results_quantiles_incid, aes(x = time, y = med)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_incid), aes(x = time, y = S2I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise incidence from incidence data - quantiles"))
dev.off()
```

