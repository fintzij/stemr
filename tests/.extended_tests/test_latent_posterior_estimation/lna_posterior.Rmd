---
title: "LNA - Latent posterior recovery"
author: "Jon Fintzi"
date: "September 15, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(stemr)
setwd("C:/Users/Jonathan/Google Drive/UW/Year 3 +/Dissertation/Code/stemr/tests/.extended_tests/test_latent_posterior_estimation")

```

## Description
This test attempts to use the LNA to estimate the posterior distribution of the latent process in the fixed parameter case. Updates to the latent process are carried out via elliptical slice sampling. We carry out the procedure for the simple SIR model under two different measurement processes, negative binomial prevalence and negative binomial incidence.

```{r, include = FALSE, cache = TRUE}
# number of iterations and objects to store the paths
cat("Starting prevalence simulation.", sep = "\n", file = "lna_post_fixedpars.txt", append = FALSE)

iterations       <- 5000000
thin_latent_proc <- 1000
thin_params      <- 1

# set up model
compartments <- c("S","I","R")
rates <- list(rate("beta * I", "S", "I", incidence = FALSE),
              rate("mu", "I", "R"))
init_state = c(50000,10,50)
state_initializer <- stem_initializer(c(S = 50000, I = 10, R = 50), fixed = T)
parameters <- c(beta = 0.00001, mu = 1/7, rho = 0.1)
tcovar <- NULL
constants <- NULL
strata <- NULL
t0 <- 0; tmax <- 52
timestep <- NULL
adjacency <- NULL
messages <- T
nsim = 1
census_times = 0:tmax

# compile dynamics
dynamics <- stem_dynamics(rates = rates, parameters = parameters, tmax = tmax, state_initializer = state_initializer, compartments=compartments, strata = strata, tcovar = tcovar, messages = TRUE, compile_ode = F, compile_rates = T)

# compile the measurement process
emissions <- list(emission("I", "negbinomial", c("I", "I * rho"), incidence = FALSE, obstimes = seq(0,tmax,by=1)))

measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, messages = T)
stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process) 

stem_data <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = 1, census_times = 0:tmax)

# grab the dataset
true_path <- stem_data$natural_paths[[1]]
dat <- stem_data$datasets[[1]]

colnames(true_path) <- c("time", "S", "I", "R")
colnames(dat) <- c("time", "I")

# recompile the measurement process
measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, data = dat)
stem_object <- stem(stem_object = stem_object, measurement_process = measurement_process)

# extract the model objects from the stem_object
flow_matrix            <- stem_object$dynamics$flow_matrix_lna
lna_pointer            <- stem_object$dynamics$lna_pointers$lna_pointer
lna_pointer_ess        <- stem_object$dynamics$lna_pointers$lna_pointer_ess
lna_set_pars_pointer   <- stem_object$dynamics$lna_pointers$lna_set_pars_ptr
lna_ess_set_pars_ptr   <- stem_object$dynamics$lna_pointers$lna_ess_set_pars_ptr
censusmat              <- stem_object$measurement_process$censusmat
parameters             <- stem_object$dynamics$parameters
constants              <- stem_object$dynamics$constants
initdist_parameters    <- stem_object$dynamics$initdist_params
lna_initdist_inds      <- stem_object$dynamics$lna_initdist_inds
n_compartments         <- ncol(flow_matrix)
n_rates                <- nrow(flow_matrix)
n_odes                 <- 2*n_rates + n_rates^2
comp_codes             <- stem_object$dynamics$lna_comp_codes
do_prevalence          <- stem_object$measurement_process$lna_prevalence
do_incidence           <- stem_object$measurement_process$lna_incidence
incidence_codes        <- stem_object$measurement_process$incidence_codes_lna
n_incidence            <- ifelse(incidence_codes[1] == -1, 0, length(incidence_codes))
census_incidence_codes <- incidence_codes + ncol(censusmat) - 2
names(census_incidence_codes) <- names(incidence_codes)
fixed_inits            <- stem_object$dynamics$fixed_inits
n_strata               <- stem_object$dynamics$n_strata

# measurement process objects
data                    <- stem_object$measurement_process$data
measproc_indmat         <- stem_object$measurement_process$measproc_indmat
d_meas_pointer          <- stem_object$measurement_process$meas_pointers$d_measure_ptr
obstimes                <- data[,1]
obstime_inds            <- stem_object$measurement_process$obstime_inds
tcovar_censmat          <- stem_object$measurement_process$tcovar_censmat

# generate other derived objects
lna_times         <- sort(unique(c(obstimes, stem_object$dynamics$.dynamics_args$tcovar[,1],
                                   stem_object$dynamics$t0, stem_object$dynamics$tmax)))
n_times           <- length(lna_times)
n_census_times    <- length(obstimes)
param_update_inds <- is.na(match(lna_times, obstimes))
census_indices    <- findInterval(obstimes, lna_times) - 1

# matrix for storing the LNA parameters
lna_parameters  <- matrix(0.0, nrow = length(lna_times),
                          ncol = length(stem_object$dynamics$lna_param_codes),
                          dimnames = list(NULL,names(stem_object$dynamics$lna_param_codes)))

# insert the lna parameters
pars2lnapars(lna_parameters, parameters)

# get column indices for constants and time-varying covariates
const_inds             <- seq_along(stem_object$dynamics$const_codes) + length(stem_object$dynamics$param_codes)
tcovar_inds            <- (max(const_inds)+1):ncol(lna_parameters)

# insert the constants
lna_parameters[,const_inds] <- matrix(stem_object$dynamics$constants,
                                      nrow = nrow(lna_parameters),
                                      ncol = length(const_inds), byrow = T)

# insert time varying covariates
if(!is.null(stem_object$dynamics$dynamics_args$tcovar)) {
        tcovar_rowinds                 <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
        lna_parameters[, tcovar_inds]  <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
}

# matrix in which to store the emission probabilities
emitmat <- cbind(data[, 1, drop = F],
                 matrix(
                         0.0,
                         nrow = nrow(measproc_indmat),
                         ncol = ncol(measproc_indmat),
                         dimnames = list(NULL, colnames(measproc_indmat))
                 ))

pathmat <- cbind(lna_times,
                 matrix(
                         0.0,
                         nrow = length(lna_times),
                         ncol = nrow(flow_matrix),
                         dimnames = list(NULL, c(rownames(flow_matrix)))
                 ))

# set up MCMC objects
latent_paths      <-
        array(0.0, dim = c(
                length(lna_times),
                1 + nrow(flow_matrix),
                1 + floor(iterations / thin_latent_proc)
        ))

lna_log_lik       <- double(1 + floor(iterations / thin_params))
data_log_lik      <- double(1 + floor(iterations / thin_params))
log_prior         <- double(1 + floor(iterations / thin_params))

# initialize the latent path
path <- initialize_lna(
        data                    = data,
        lna_parameters          = lna_parameters,
        censusmat               = censusmat,
        emitmat                 = emitmat,
        flow_matrix             = flow_matrix,
        lna_pointer             = lna_pointer,
        lna_set_pars_pointer    = lna_set_pars_pointer,
        lna_times               = lna_times,
        lna_initdist_inds       = lna_initdist_inds,
        param_update_inds       = param_update_inds,
        incidence_codes         = incidence_codes,
        census_incidence_codes  = census_incidence_codes,
        census_indices          = census_indices,
        measproc_indmat         = measproc_indmat,
        obstime_inds            = obstime_inds,
        d_meas_pointer          = d_meas_pointer,
        parameters              = parameters,
        constants               = constants,
        tcovar_censmat          = tcovar_censmat,
        do_prevalence           = do_prevalence,
        do_incidence            = do_incidence,
        initialization_attempts = 500
)

# save the current observed data log-likelihood and compute the
# likelihood of the latent LNA path
path <- lna_density2(
        path              = path,
        lna_times         = lna_times,
        lna_pars          = lna_parameters,
        param_update_inds = param_update_inds,
        flow_matrix       = flow_matrix,
        lna_pointer_ess   = lna_pointer_ess,
        lna_ess_set_pars_ptr  = lna_ess_set_pars_ptr
)

# save the initial path, data log-likelihood and the lna log-likelihood
latent_paths[,,1] <- path$lna_path
data_log_lik[1]   <- path$data_log_lik
lna_log_lik[1]    <- path$lna_log_lik

for(k in 2:iterations) {
        
        if(k%%1000 == 0) {
                # print(k)
                cat(paste0("Prevalence iteration ", k), sep = "\n", file = "lna_post_fixedpars.txt", append = TRUE)
        }
                
        path <- update_lna_path(
                                path_cur               = path,
                                data                   = data,
                                lna_parameters         = lna_parameters,
                                pathmat                = pathmat,
                                censusmat              = censusmat,
                                emitmat                = emitmat,
                                flow_matrix            = flow_matrix,
                                lna_pointer_ess        = lna_pointer_ess,
                                lna_ess_set_pars_ptr   = lna_ess_set_pars_ptr,
                                lna_times              = lna_times,
                                lna_initdist_inds      = lna_initdist_inds,
                                param_update_inds      = param_update_inds,
                                incidence_codes        = incidence_codes,
                                census_incidence_codes = census_incidence_codes,
                                census_indices         = census_indices,
                                measproc_indmat        = measproc_indmat,
                                obstime_inds           = obstime_inds,
                                d_meas_pointer         = d_meas_pointer,
                                parameters             = parameters,
                                constants              = constants,
                                tcovar_censmat         = tcovar_censmat,
                                do_prevalence          = do_prevalence,
                                do_incidence           = do_incidence
                )   
        
        data_log_lik[k] <- path$data_log_lik
        lna_log_lik[k]  <- path$lna_log_lik
        
        if(k %% thin_latent_proc == 0) {
                latent_paths[,,k/thin_latent_proc] <- path$lna_path
        }
}

library(mcmc)
library(ggplot2)

paths <- array(0.0, dim = c(nrow(censusmat), ncol(censusmat), iterations/thin_latent_proc + 1))

for(k in 1:dim(paths)[3]) {
        census_lna(
                path                = latent_paths[,,k],
                census_path         = censusmat,
                census_inds         = census_indices,
                flow_matrix_lna     = flow_matrix,
                do_prevalence       = TRUE,
                init_state          = init_state,
                incidence_codes_lna = incidence_codes
        )
        paths[,,k] <- censusmat
}
colnames(paths) <- c("time", "S", "I", "R")

# paths of the I compartment
I_paths <- paths[,"I",]

# matrix for storing results
results <- data.frame(time = 0:52, mean = rowMeans(I_paths), mcse = 0)
results_quantiles <- data.frame(time  = 0:52, 
                                med   = apply(I_paths, 1, median), 
                                lower = apply(I_paths, 1, quantile, 0.025),
                                upper = apply(I_paths, 1, quantile, 0.975))

# variance of the sample mean of the markov chain
vars <- rep(0, nrow(results))
for(k in 1:length(vars)) {
        vars[k] <- initseq(I_paths[k,])$var.pos
}

# monte carlo standard error
results$mcse <- sqrt(vars) / sqrt(ncol(I_paths))

# produce the plot
pdf("lna_post_prev_rho_1.pdf")
print(ggplot(results, aes(x = time, y = mean)) + geom_ribbon(aes(ymin = mean - 1.96 * mcse, ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from prevalence data - mean and MCSE bands"))

print(ggplot(results_quantiles, aes(x = time, y = med)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from prevalence data - quantiles"))
dev.off()
```

```{r, include = FALSE, cache = TRUE}
rm(list=ls())
library(stemr)
cat("Starting incidence simulation.", sep = "\n", file = "lna_post_fixedpars.txt", append = FALSE)

# number of iterations and objects to store the paths
iterations       <- 5000000
thin_latent_proc <- 1000
thin_params      <- 1

# set up model
compartments <- c("S","I","R")
rates <- list(rate("beta * I", "S", "I", incidence = TRUE),
              rate("mu", "I", "R"))
init_state = c(50000,10,50)
state_initializer <- stem_initializer(c(S = 50000, I = 10, R = 50), fixed = T)
parameters <- c(beta = 0.00001, mu = 1/7, rho = 0.01)
tcovar <- NULL
constants <- NULL
strata <- NULL
t0 <- 0; tmax <- 52
timestep <- NULL
adjacency <- NULL
messages <- T
nsim = 1
census_times = 0:tmax

# compile dynamics
dynamics <- stem_dynamics(rates = rates, parameters = parameters, tmax = tmax, state_initializer = state_initializer, compartments=compartments, strata = strata, tcovar = tcovar, messages = TRUE, compile_ode = F, compile_rates = T)

# compile the measurement process
emissions <- list(emission("I", "negbinomial", c("S2I", "S2I * rho"), incidence = TRUE, obstimes = seq(1,tmax,by=1)))

measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, messages = T)
stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process) 

stem_data <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = 1, census_times = 0:tmax)

# grab the dataset
true_path_prev <- stem_data$natural_paths[[1]]
true_path_incid <- stem_data$paths[[1]]
dat <- stem_data$datasets[[1]]

colnames(true_path_prev) <- c("time", "S", "I", "R")
colnames(true_path_incid) <- c("time", "S2I", "I2R")
colnames(dat) <- c("time", "I")

# recompile the measurement process
measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, data = dat)
stem_object <- stem(stem_object = stem_object, measurement_process = measurement_process)

# extract the model objects from the stem_object
flow_matrix            <- stem_object$dynamics$flow_matrix_lna
lna_pointer            <- stem_object$dynamics$lna_pointers$lna_pointer
lna_pointer_ess        <- stem_object$dynamics$lna_pointers$lna_pointer_ess
lna_set_pars_pointer   <- stem_object$dynamics$lna_pointers$lna_set_pars_ptr
lna_ess_set_pars_ptr   <- stem_object$dynamics$lna_pointers$lna_ess_set_pars_ptr
censusmat              <- stem_object$measurement_process$censusmat
parameters             <- stem_object$dynamics$parameters
constants              <- stem_object$dynamics$constants
initdist_parameters    <- stem_object$dynamics$initdist_params
lna_initdist_inds      <- stem_object$dynamics$lna_initdist_inds
n_compartments         <- ncol(flow_matrix)
n_rates                <- nrow(flow_matrix)
n_odes                 <- 2*n_rates + n_rates^2
comp_codes             <- stem_object$dynamics$lna_comp_codes
do_prevalence          <- stem_object$measurement_process$lna_prevalence
do_incidence           <- stem_object$measurement_process$lna_incidence
incidence_codes        <- stem_object$measurement_process$incidence_codes_lna
n_incidence            <- ifelse(incidence_codes[1] == -1, 0, length(incidence_codes))
census_incidence_codes <- incidence_codes + ncol(censusmat) - 2
names(census_incidence_codes) <- names(incidence_codes)
fixed_inits            <- stem_object$dynamics$fixed_inits
n_strata               <- stem_object$dynamics$n_strata

# measurement process objects
data                    <- stem_object$measurement_process$data
measproc_indmat         <- stem_object$measurement_process$measproc_indmat
d_meas_pointer          <- stem_object$measurement_process$meas_pointers$d_measure_ptr
obstimes                <- data[,1]
obstime_inds            <- stem_object$measurement_process$obstime_inds
tcovar_censmat          <- stem_object$measurement_process$tcovar_censmat

# generate other derived objects
lna_times         <- sort(unique(c(obstimes, stem_object$dynamics$.dynamics_args$tcovar[,1],
                                   stem_object$dynamics$t0, stem_object$dynamics$tmax)))
n_times           <- length(lna_times)
n_census_times    <- length(obstimes)
param_update_inds <- is.na(match(lna_times, obstimes))
census_indices    <- findInterval(obstimes, lna_times) - 1

# matrix for storing the LNA parameters
lna_parameters  <- matrix(0.0, nrow = length(lna_times),
                          ncol = length(stem_object$dynamics$lna_param_codes),
                          dimnames = list(NULL,names(stem_object$dynamics$lna_param_codes)))

# insert the lna parameters
pars2lnapars(lna_parameters, parameters)

# get column indices for constants and time-varying covariates
const_inds             <- seq_along(stem_object$dynamics$const_codes) + length(stem_object$dynamics$param_codes)
tcovar_inds            <- (max(const_inds)+1):ncol(lna_parameters)

# insert the constants
lna_parameters[,const_inds] <- matrix(stem_object$dynamics$constants,
                                      nrow = nrow(lna_parameters),
                                      ncol = length(const_inds), byrow = T)

# insert time varying covariates
if(!is.null(stem_object$dynamics$dynamics_args$tcovar)) {
        tcovar_rowinds                 <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
        lna_parameters[, tcovar_inds]  <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
}

# matrix in which to store the emission probabilities
emitmat <- cbind(data[, 1, drop = F],
                 matrix(
                         0.0,
                         nrow = nrow(measproc_indmat),
                         ncol = ncol(measproc_indmat),
                         dimnames = list(NULL, colnames(measproc_indmat))
                 ))

pathmat <- cbind(lna_times,
                 matrix(
                         0.0,
                         nrow = length(lna_times),
                         ncol = nrow(flow_matrix),
                         dimnames = list(NULL, c(rownames(flow_matrix)))
                 ))

# set up MCMC objects
latent_paths      <-
        array(0.0, dim = c(
                length(lna_times),
                1 + nrow(flow_matrix),
                1 + floor(iterations / thin_latent_proc)
        ))

lna_log_lik       <- double(1 + floor(iterations / thin_params))
data_log_lik      <- double(1 + floor(iterations / thin_params))
log_prior         <- double(1 + floor(iterations / thin_params))

# initialize the latent path
path <- initialize_lna(
        data                    = data,
        lna_parameters          = lna_parameters,
        censusmat               = censusmat,
        emitmat                 = emitmat,
        flow_matrix             = flow_matrix,
        lna_pointer             = lna_pointer,
        lna_set_pars_pointer    = lna_set_pars_pointer,
        lna_times               = lna_times,
        lna_initdist_inds       = lna_initdist_inds,
        param_update_inds       = param_update_inds,
        incidence_codes         = incidence_codes,
        census_incidence_codes  = census_incidence_codes,
        census_indices          = census_indices,
        measproc_indmat         = measproc_indmat,
        obstime_inds            = obstime_inds,
        d_meas_pointer          = d_meas_pointer,
        parameters              = parameters,
        constants               = constants,
        tcovar_censmat          = tcovar_censmat,
        do_prevalence           = do_prevalence,
        do_incidence            = do_incidence,
        initialization_attempts = 500
)

# save the current observed data log-likelihood and compute the
# likelihood of the latent LNA path
path <- lna_density2(
        path              = path,
        lna_times         = lna_times,
        lna_pars          = lna_parameters,
        param_update_inds = param_update_inds,
        flow_matrix       = flow_matrix,
        lna_pointer_ess   = lna_pointer_ess,
        lna_ess_set_pars_ptr = lna_ess_set_pars_ptr
)

# save the initial path, data log-likelihood and the lna log-likelihood
latent_paths[,,1] <- path$lna_path
data_log_lik[1]   <- path$data_log_lik
lna_log_lik[1]    <- path$lna_log_lik

for(k in 2:iterations) {
        
        if(k%%1000 == 0) {
                # print(k)
                cat(paste0("Incidence iteration ", k), sep = "\n", file = "lna_post_fixedpars.txt", append = TRUE)
        }
                
        
        path <- update_lna_path(
                                path_cur               = path,
                                data                   = data,
                                lna_parameters         = lna_parameters,
                                pathmat                = pathmat,
                                censusmat              = censusmat,
                                emitmat                = emitmat,
                                flow_matrix            = flow_matrix,
                                lna_pointer_ess        = lna_pointer_ess,
                                lna_ess_set_pars_ptr   = lna_ess_set_pars_ptr,
                                lna_times              = lna_times,
                                lna_initdist_inds      = lna_initdist_inds,
                                param_update_inds      = param_update_inds,
                                incidence_codes        = incidence_codes,
                                census_incidence_codes = census_incidence_codes,
                                census_indices         = census_indices,
                                measproc_indmat        = measproc_indmat,
                                obstime_inds           = obstime_inds,
                                d_meas_pointer         = d_meas_pointer,
                                parameters             = parameters,
                                constants              = constants,
                                tcovar_censmat         = tcovar_censmat,
                                do_prevalence          = do_prevalence,
                                do_incidence           = do_incidence
                )     
        
        data_log_lik[k] <- path$data_log_lik
        lna_log_lik[k]  <- path$lna_log_lik
        
        if(k %% thin_latent_proc == 0) {
                latent_paths[,,k/thin_latent_proc] <- path$lna_path
        }
}

library(mcmc)
library(ggplot2)

paths <- array(0.0, dim = c(nrow(censusmat) + 1, ncol(censusmat), iterations/thin_latent_proc + 1))
censusmat <- rbind(c(rep(0,5)), censusmat) 

for(k in 1:dim(paths)[3]) {
        census_lna(
                path                = latent_paths[,,k],
                census_path         = censusmat,
                census_inds         = 0:52,
                flow_matrix_lna     = flow_matrix,
                do_prevalence       = TRUE,
                init_state          = init_state,
                incidence_codes_lna = incidence_codes
        )
        paths[,,k] <- censusmat
}
colnames(paths) <- c("time", "S", "I", "R", "S2I")
colnames(latent_paths) <- c("time", "S2I", "I2R")

library(mcmc)
library(ggplot2)

# paths of the I compartment
I_paths_prev <- paths[,"I",]
I_paths_incid <- latent_paths[,"S2I",]

# matrix for storing results
results_prev <- data.frame(time = 0:52, mean = rowMeans(I_paths_prev), mcse = 0)
results_quantiles_prev <- data.frame(time  = 0:52, med   = apply(I_paths_prev, 1, median), 
                                     lower = apply(I_paths_prev, 1, quantile, 0.025),
                                     upper = apply(I_paths_prev, 1, quantile, 0.975))

results_incid <- data.frame(time = 0:52, mean = rowMeans(I_paths_incid), mcse = 0)
results_quantiles_incid <- data.frame(time  = 0:52, med   = apply(I_paths_incid, 1, median), 
                                     lower = apply(I_paths_incid, 1, quantile, 0.025),
                                     upper = apply(I_paths_incid, 1, quantile, 0.975))

# variance of the sample mean of the markov chain
vars_prev <- rep(0, nrow(results_prev))
for(k in 1:length(vars_prev)) {
        vars_prev[k] <- initseq(I_paths_prev[k,])$var.pos
}

vars_incid <- rep(0, nrow(results_incid))
for(k in 1:length(vars_incid)) {
        vars_incid[k] <- initseq(I_paths_incid[k,])$var.pos
}

# monte carlo standard error
results_prev$mcse <- sqrt(vars_prev) / sqrt(ncol(I_paths_prev))
results_incid$mcse <- sqrt(vars_incid) / sqrt(ncol(I_paths_incid))

pdf("lna_post_incid_rho_1.pdf")
# produce the plot
print(ggplot(results_prev, aes(x = time, y = mean)) + geom_ribbon(aes(ymin = mean - 1.96 * mcse, ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_prev), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from incidence data - mean and MCSE bands"))

print(ggplot(results_quantiles_prev, aes(x = time, y = med)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_prev), aes(x = time, y = I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise prevalence from incidence data - quantiles"))

print(ggplot(results_incid, aes(x = time, y = mean)) + geom_ribbon(aes(ymin = mean - 1.96 * mcse, ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_incid), aes(x = time, y = S2I), colour = "red") + labs(x = "time", y = "S2I", title = "Pointwise Incidence from incidence data - mean and MCSE bands"))

print(ggplot(results_quantiles_incid, aes(x = time, y = med)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line() + geom_line(data = as.data.frame(true_path_incid), aes(x = time, y = S2I), colour = "red") + labs(x = "time", y = "I", title = "Pointwise incidence from incidence data - quantiles"))
dev.off()
```

