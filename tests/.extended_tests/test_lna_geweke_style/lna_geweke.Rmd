---
title: "LNA - Geweke style test"
author: "Jon Fintzi"
date: "October 5, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(stemr)
setwd("C:/Users/Jonathan/Google Drive/UW/Year 3 +/Dissertation/Code/stemr/tests/.extended_tests/test_lna_geweke_style")
```

## Description
This test implements a Geweke type test to ascertain that the LNA targets the correct joint distribution of the latent process and the data. For a fixed set of model parameters, the procedure alternates between updating the latent process given the current dataset, $\mathrm{\mathbf{X}}|\mathrm{\mathbf{Y}}$, and sampling a new dataset given the current path of the latent process. Updates to the latent process are carried out via elliptical slice sampling. We carry out the procedure for the simple SIR model under two different measurement processes, negative binomial prevalence and negative binomial incidence. The pointwise distributions for the latent LNA paths and the data sampled from them are compared to the pointwise distributions of latent paths simulated using the LNA.

```{r, include = FALSE, cache = T}
# number of iterations and objects to store the paths
cat("Starting prevalence simulation.", sep = "\n", file = "lna_geweke.txt", append = FALSE)

iterations       <- 1000000
thin_latent_proc <- 100
thin_params      <- 1

# set up model
compartments <- c("S","I","R")
rates <- list(rate("beta * I", "S", "I", incidence = FALSE),
              rate("mu", "I", "R"))
init_state = c(50000,10,50)
state_initializer <- stem_initializer(c(S = 50000, I = 10, R = 50), fixed = T)
parameters <- c(beta = 0.00001, mu = 1/7, rho = 0.5)
tcovar <- NULL
constants <- NULL
strata <- NULL
t0 <- 0; tmax <- 52
timestep <- NULL
adjacency <- NULL
messages <- T
nsim = 1
census_times = 0:tmax

# compile dynamics
dynamics <- stem_dynamics(rates = rates, parameters = parameters, tmax = tmax, state_initializer = state_initializer, compartments=compartments, strata = strata, tcovar = tcovar, messages = TRUE, compile_ode = F, compile_rates = F)

# compile the measurement process
emissions <- list(emission("I", "negbinomial", c("I", "I * rho"), incidence = FALSE, obstimes = seq(0,tmax,by=1)))

measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, messages = T)
stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process) 

stem_data <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = 1, census_times = 0:tmax)

# grab the dataset
true_path <- stem_data$natural_paths[[1]]
dat <- stem_data$datasets[[1]]

colnames(true_path) <- c("time", "S", "I", "R")
colnames(dat) <- c("time", "I")

# recompile the measurement process
measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, data = dat)
stem_object <- stem(stem_object = stem_object, measurement_process = measurement_process)

# extract the model objects from the stem_object
flow_matrix            <- stem_object$dynamics$flow_matrix_lna
lna_pointer            <- stem_object$dynamics$lna_pointers$lna_pointer
lna_pointer_ess        <- stem_object$dynamics$lna_pointers$lna_pointer_ess
lna_set_pars_pointer   <- stem_object$dynamics$lna_pointers$lna_set_pars_ptr
lna_ess_set_pars_ptr <- stem_object$dynamics$lna_pointers$lna_ess_set_pars_ptr
censusmat              <- stem_object$measurement_process$censusmat
parameters             <- stem_object$dynamics$parameters
constants              <- stem_object$dynamics$constants
initdist_parameters    <- stem_object$dynamics$initdist_params
lna_initdist_inds      <- stem_object$dynamics$lna_initdist_inds
n_compartments         <- ncol(flow_matrix)
n_rates                <- nrow(flow_matrix)
n_odes                 <- 2*n_rates + n_rates^2
comp_codes             <- stem_object$dynamics$lna_comp_codes
do_prevalence          <- stem_object$measurement_process$lna_prevalence
do_incidence           <- stem_object$measurement_process$lna_incidence
incidence_codes        <- stem_object$measurement_process$incidence_codes_lna
n_incidence            <- ifelse(incidence_codes[1] == -1, 0, length(incidence_codes))
census_incidence_codes <- incidence_codes + ncol(censusmat) - 2
names(census_incidence_codes) <- names(incidence_codes)
fixed_inits            <- stem_object$dynamics$fixed_inits
n_strata               <- stem_object$dynamics$n_strata

# measurement process objects
data                    <- stem_object$measurement_process$data
measproc_indmat         <- stem_object$measurement_process$measproc_indmat
d_meas_pointer          <- stem_object$measurement_process$meas_pointers$d_measure_ptr
r_meas_pointer          <- stem_object$measurement_process$meas_pointers$r_measure_ptr
obstimes                <- data[,1]
obstime_inds            <- stem_object$measurement_process$obstime_inds
tcovar_censmat          <- stem_object$measurement_process$tcovar_censmat

# generate other derived objects
lna_times         <- sort(unique(c(obstimes, stem_object$dynamics$.dynamics_args$tcovar[,1],
                                   stem_object$dynamics$t0, stem_object$dynamics$tmax)))
n_times           <- length(lna_times)
n_census_times    <- length(obstimes)
param_update_inds <- is.na(match(lna_times, obstimes))
census_indices    <- findInterval(obstimes, lna_times) - 1

# matrix for storing the LNA parameters
lna_parameters  <- matrix(0.0, nrow = length(lna_times),
                          ncol = length(stem_object$dynamics$lna_param_codes),
                          dimnames = list(NULL,names(stem_object$dynamics$lna_param_codes)))

# insert the lna parameters
pars2lnapars(lna_parameters, parameters)

# get column indices for constants and time-varying covariates
const_inds             <- seq_along(stem_object$dynamics$const_codes) + length(stem_object$dynamics$param_codes)
tcovar_inds            <- (max(const_inds)+1):ncol(lna_parameters)

# insert the constants
lna_parameters[,const_inds] <- matrix(stem_object$dynamics$constants,
                                      nrow = nrow(lna_parameters),
                                      ncol = length(const_inds), byrow = T)

# insert time varying covariates
if(!is.null(stem_object$dynamics$dynamics_args$tcovar)) {
        tcovar_rowinds                 <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
        lna_parameters[, tcovar_inds]  <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
}

# grab the time-varying covariate values at observation times
tcovar_obstimes <- build_census_path(path           = stem_object$dynamics$tcovar,
                                     census_times   = stem_object$measurement_process$obstimes,
                                     census_columns = 1:(ncol(stem_object$dynamics$tcovar)-1))
colnames(tcovar_obstimes) <- colnames(stem_object$dynamics$tcovar)

# matrix in which to store the emission probabilities
emitmat <- cbind(data[, 1, drop = F],
                 matrix(
                         0.0,
                         nrow = nrow(measproc_indmat),
                         ncol = ncol(measproc_indmat),
                         dimnames = list(NULL, colnames(measproc_indmat))
                 ))

pathmat <- cbind(lna_times,
                 matrix(
                         0.0,
                         nrow = length(lna_times),
                         ncol = nrow(flow_matrix),
                         dimnames = list(NULL, c(rownames(flow_matrix)))
                 ))

# set up MCMC objects
latent_lna_paths      <- array(0.0, 
                               dim = c(
                               length(lna_times),
                               1 + nrow(flow_matrix),
                               1 + floor(iterations / thin_latent_proc)
                               ))
latent_paths_natural   <- array(0.0,
                                dim = c(
                                length(lna_times),
                                1 + ncol(flow_matrix),
                                1 + floor(iterations / thin_latent_proc)
                                ))
                                
lna_log_lik       <- double(1 + floor(iterations / thin_params))
data_log_lik      <- double(1 + floor(iterations / thin_params))
log_prior         <- double(1 + floor(iterations / thin_params))

# initialize the latent path
path <- initialize_lna(
        data                    = data,
        lna_parameters          = lna_parameters,
        censusmat               = censusmat,
        emitmat                 = emitmat,
        flow_matrix             = flow_matrix,
        lna_pointer             = lna_pointer,
        lna_set_pars_pointer    = lna_set_pars_pointer,
        lna_times               = lna_times,
        lna_initdist_inds       = lna_initdist_inds,
        param_update_inds       = param_update_inds,
        incidence_codes         = incidence_codes,
        census_incidence_codes  = census_incidence_codes,
        census_indices          = census_indices,
        measproc_indmat         = measproc_indmat,
        obstime_inds            = obstime_inds,
        d_meas_pointer          = d_meas_pointer,
        parameters              = parameters,
        constants               = constants,
        tcovar_censmat          = tcovar_censmat,
        do_prevalence           = do_prevalence,
        do_incidence            = do_incidence,
        initialization_attempts = 500
)

# save the current observed data log-likelihood and compute the
# likelihood of the latent LNA path
path <- lna_density2(
        path              = path,
        lna_times         = lna_times,
        lna_pars          = lna_parameters,
        param_update_inds = param_update_inds,
        flow_matrix       = flow_matrix,
        lna_pointer_ess   = lna_pointer_ess,
        lna_ess_set_pars_ptr = lna_ess_set_pars_ptr
)

# census the original LNA path
census_lna(
        path                = path$lna_path,
        census_path         = censusmat,
        census_inds         = census_indices,
        flow_matrix_lna     = flow_matrix,
        do_prevalence       = TRUE,
        init_state          = init_state,
        incidence_codes_lna = incidence_codes
        )

# save the initial path, data log-likelihood and the lna log-likelihood
latent_lna_paths[,,1]      <- path$lna_path
latent_paths_natural[,,1]  <- censusmat

for(k in 2:iterations) {

        if(k%%1000 == 0) {
                # print(k)
                cat(paste0("Prevalence iteration ", k), sep = "\n", file = "lna_geweke.txt", append = TRUE)
        }
                
        path <- update_lna_path(
                        path_cur                = path,
                        data                    = data,
                        lna_parameters          = lna_parameters,
                        pathmat                 = pathmat,
                        censusmat               = censusmat,
                        emitmat                 = emitmat,
                        flow_matrix             = flow_matrix,
                        lna_pointer_ess         = lna_pointer_ess,
                        lna_ess_set_pars_ptr    = lna_ess_set_pars_ptr,
                        lna_times               = lna_times,
                        lna_initdist_inds       = lna_initdist_inds,
                        param_update_inds       = param_update_inds,
                        incidence_codes         = incidence_codes,
                        census_incidence_codes  = census_incidence_codes,
                        census_indices          = census_indices,
                        measproc_indmat         = measproc_indmat,
                        obstime_inds            = obstime_inds,
                        d_meas_pointer          = d_meas_pointer,
                        parameters              = parameters,
                        constants               = constants,
                        tcovar_censmat          = tcovar_censmat,
                        do_prevalence           = do_prevalence,
                        do_incidence            = do_incidence
                )

        # convert the path onto the natural state space
        census_lna(
                path                = path$lna_path,
                census_path         = censusmat,
                census_inds         = census_indices,
                flow_matrix_lna     = flow_matrix,
                do_prevalence       = TRUE,
                init_state          = init_state,
                incidence_codes_lna = incidence_codes
        )        
        
        data <- simulate_r_measure(censusmat       = censusmat,
                                   measproc_indmat = measproc_indmat,
                                   parameters      = parameters,
                                   constants       = constants,
                                   tcovar          = tcovar_obstimes,
                                   r_measure_ptr   = r_meas_pointer)
        
        # recompute the emission probabilities given the new dataset
        evaluate_d_measure(emitmat          = emitmat,
                           obsmat           = data,
                           statemat         = censusmat,
                           measproc_indmat  = measproc_indmat,
                           parameters       = parameters,
                           constants        = constants,
                           tcovar_censusmat = tcovar_censmat,
                           d_meas_ptr       = d_meas_pointer)

        # compute the data log likelihood
        path$data_log_lik <- sum(emitmat[,-1][measproc_indmat])
        
        # save the new path and the new dataset
        if(k %% thin_latent_proc == 0) {
                latent_paths_natural[,,k/thin_latent_proc] <- censusmat
                latent_lna_paths[,,k/thin_latent_proc]     <- path$lna_path
        }
}

# now simulate latent lna paths 
stemr_paths <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = iterations / thin_latent_proc, census_times = 0:tmax)

# compile the results
# stemr paths from the geweke simulation
natural_paths_sim <- array(unlist(stemr_paths$natural_paths), 
                       dim = c(nrow(stemr_paths$natural_paths[[1]]), 
                               ncol(stemr_paths$natural_paths[[1]]),
                               length(stemr_paths$natural_paths)))
lna_paths_sim     <- array(unlist(stemr_paths$paths), 
                       dim = c(nrow(stemr_paths$paths[[1]]), 
                               ncol(stemr_paths$paths[[1]]),
                               length(stemr_paths$paths)))


# extract the S2I and I compartments from the relevant objects
I_nat_sim   <- natural_paths_sim[,3,]
S2I_lna_sim <- lna_paths_sim[,2,]

I_nat_mcmc   <- latent_paths_natural[,3,]
S2I_lna_mcmc <- latent_lna_paths[,2,]

library(mcmc)
library(ggplot2)

calc_mcse <- function(x) {
        sqrt(initseq(x)$var.pos) / sqrt(ncol(I_nat_mcmc))
}

# prevalence natural path 
results_natural <- data.frame(method = rep(c("mcmc", "sim"), each = length(seq(t0,tmax))),
                              time   = rep(seq(t0, tmax), 2),
                              mean   = c(rowMeans(I_nat_mcmc), rowMeans(I_nat_sim)),
                              med    = c(apply(I_nat_mcmc, 1, median), apply(I_nat_sim, 1, median)),
                              mcse   = c(apply(I_nat_mcmc, 1, calc_mcse), 
                                         apply(I_nat_sim, 1, sd) / sqrt(ncol(I_nat_mcmc))), 
                              lower  = c(apply(I_nat_mcmc, 1, quantile, probs = 0.025), 
                                         apply(I_nat_sim, 1, quantile, probs = 0.025)), 
                              upper  = c(apply(I_nat_mcmc, 1, quantile, probs = 0.975), 
                                         apply(I_nat_sim, 1, quantile, probs = 0.975)))

# path of the counting process for S2I
results_S2I_lna <- data.frame(method = rep(c("mcmc", "sim"), each = length(seq(t0,tmax))),
                              time   = rep(seq(t0, tmax), 2),
                              mean   = c(rowMeans(S2I_lna_mcmc), rowMeans(S2I_lna_sim)),
                              med    = c(apply(S2I_lna_mcmc, 1, median), apply(S2I_lna_sim, 1, median)),
                              mcse   = c(apply(S2I_lna_mcmc, 1, calc_mcse), 
                                         apply(S2I_lna_sim, 1, sd) / sqrt(ncol(I_nat_mcmc))), 
                              lower  = c(apply(S2I_lna_mcmc, 1, quantile, probs = 0.025), 
                                         apply(S2I_lna_sim, 1, quantile, probs = 0.025)), 
                              upper  = c(apply(S2I_lna_mcmc, 1, quantile, probs = 0.975), 
                                         apply(S2I_lna_sim, 1, quantile, probs = 0.975)))

# produce the plots
pdf("lna_geweke_prevalence.pdf")
# natural process
print(ggplot(results_natural, aes(x = time, y = mean, fill = method, colour = method)) + geom_ribbon(aes(ymin = pmax(mean - 1.96 * mcse, 0), ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of prevalence from prevalence data - mean and MCSE bands"))

print(ggplot(results_natural, aes(x = time, y = med, fill = method, colour = method)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of prevalence from prevalence data - median and 95% bands"))

# lna cumulative incidence
print(ggplot(results_S2I_lna, aes(x = time, y = mean, fill = method, colour = method)) + geom_ribbon(aes(ymin = pmax(mean - 1.96 * mcse, 0), ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line()  + labs(x = "time", y = "S2I", title = "Pointwise distribution of cumulative incidence LNA from prevalence data - mean and MCSE bands"))

print(ggplot(results_S2I_lna, aes(x = time, y = med, fill = method, colour = method)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of cumulative incidence LNA from prevalence data - median and 95% bands"))

dev.off()
```

```{r, include=FALSE, cache = TRUE}
rm(list=ls(all.names = T))
library(stemr)
# number of iterations and objects to store the paths
cat("Starting incidence simulation.", sep = "\n", file = "lna_geweke.txt", append = FALSE)

iterations       <- 1000000
thin_latent_proc <- 100
thin_params      <- 1

# set up model
compartments <- c("S","I","R")
rates <- list(rate("beta * I", "S", "I", incidence = TRUE),
              rate("mu", "I", "R"))
init_state = c(50000,10,50)
state_initializer <- stem_initializer(c(S = 50000, I = 10, R = 50), fixed = T)
parameters <- c(beta = 0.00001, mu = 1/7, rho = 0.5)
tcovar <- NULL
constants <- NULL
strata <- NULL
t0 <- 0; tmax <- 52
timestep <- NULL
adjacency <- NULL
messages <- T
nsim = 1
census_times = 0:tmax

# compile dynamics
dynamics <- stem_dynamics(rates = rates, parameters = parameters, tmax = tmax, state_initializer = state_initializer, compartments=compartments, strata = strata, tcovar = tcovar, messages = TRUE, compile_ode = F, compile_rates = T)

# compile the measurement process
emissions <- list(emission("I", "negbinomial", c("S2I", "S2I * rho"), incidence = TRUE, obstimes = seq(1,tmax,by=1)))

measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, messages = T)
stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process) 

stem_data <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = 1, census_times = 0:tmax)

# grab the dataset
true_path_prev <- stem_data$natural_paths[[1]]
true_path_incid <- stem_data$paths[[1]]
dat <- stem_data$datasets[[1]]

colnames(true_path_prev) <- c("time", "S", "I", "R")
colnames(true_path_incid) <- c("time", "S2I", "I2R")
colnames(dat) <- c("time", "I")

# recompile the measurement process
measurement_process <- stem_measure(emissions = emissions, dynamics = dynamics, data = dat)
stem_object <- stem(stem_object = stem_object, measurement_process = measurement_process)

# extract the model objects from the stem_object
flow_matrix            <- stem_object$dynamics$flow_matrix_lna
lna_pointer            <- stem_object$dynamics$lna_pointers$lna_pointer
lna_pointer_ess        <- stem_object$dynamics$lna_pointers$lna_pointer_ess
lna_set_pars_pointer   <- stem_object$dynamics$lna_pointers$lna_set_pars_ptr
lna_ess_set_pars_ptr   <- stem_object$dynamics$lna_pointers$lna_ess_set_pars_ptr
censusmat              <- stem_object$measurement_process$censusmat
parameters             <- stem_object$dynamics$parameters
constants              <- stem_object$dynamics$constants
initdist_parameters    <- stem_object$dynamics$initdist_params
lna_initdist_inds      <- stem_object$dynamics$lna_initdist_inds
n_compartments         <- ncol(flow_matrix)
n_rates                <- nrow(flow_matrix)
n_odes                 <- 2*n_rates + n_rates^2
comp_codes             <- stem_object$dynamics$lna_comp_codes
do_prevalence          <- stem_object$measurement_process$lna_prevalence
do_incidence           <- stem_object$measurement_process$lna_incidence
incidence_codes        <- stem_object$measurement_process$incidence_codes_lna
n_incidence            <- ifelse(incidence_codes[1] == -1, 0, length(incidence_codes))
census_incidence_codes <- incidence_codes + ncol(censusmat) - 2
names(census_incidence_codes) <- names(incidence_codes)
fixed_inits            <- stem_object$dynamics$fixed_inits
n_strata               <- stem_object$dynamics$n_strata

# measurement process objects
data                    <- stem_object$measurement_process$data
measproc_indmat         <- stem_object$measurement_process$measproc_indmat
d_meas_pointer          <- stem_object$measurement_process$meas_pointers$d_measure_ptr
r_meas_pointer          <- stem_object$measurement_process$meas_pointers$r_measure_ptr
obstimes                <- data[,1]
obstime_inds            <- stem_object$measurement_process$obstime_inds
tcovar_censmat          <- stem_object$measurement_process$tcovar_censmat

# generate other derived objects
lna_times         <- sort(unique(c(obstimes, stem_object$dynamics$.dynamics_args$tcovar[,1],
                                   stem_object$dynamics$t0, stem_object$dynamics$tmax)))
n_times           <- length(lna_times)
n_census_times    <- length(obstimes)
param_update_inds <- is.na(match(lna_times, obstimes))
census_indices    <- findInterval(obstimes, lna_times) - 1

# matrix for storing the LNA parameters
lna_parameters  <- matrix(0.0, nrow = length(lna_times),
                          ncol = length(stem_object$dynamics$lna_param_codes),
                          dimnames = list(NULL,names(stem_object$dynamics$lna_param_codes)))

# insert the lna parameters
pars2lnapars(lna_parameters, parameters)

# get column indices for constants and time-varying covariates
const_inds             <- seq_along(stem_object$dynamics$const_codes) + length(stem_object$dynamics$param_codes)
tcovar_inds            <- (max(const_inds)+1):ncol(lna_parameters)

# insert the constants
lna_parameters[,const_inds] <- matrix(stem_object$dynamics$constants,
                                      nrow = nrow(lna_parameters),
                                      ncol = length(const_inds), byrow = T)

# insert time varying covariates
if(!is.null(stem_object$dynamics$dynamics_args$tcovar)) {
        tcovar_rowinds                 <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
        lna_parameters[, tcovar_inds]  <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
}

# grab the time-varying covariate values at observation times
tcovar_obstimes <- build_census_path(path           = stem_object$dynamics$tcovar,
                                     census_times   = stem_object$measurement_process$obstimes,
                                     census_columns = 1:(ncol(stem_object$dynamics$tcovar)-1))
colnames(tcovar_obstimes) <- colnames(stem_object$dynamics$tcovar)

# matrix in which to store the emission probabilities
emitmat <- cbind(data[, 1, drop = F],
                 matrix(
                         0.0,
                         nrow = nrow(measproc_indmat),
                         ncol = ncol(measproc_indmat),
                         dimnames = list(NULL, colnames(measproc_indmat))
                 ))

pathmat <- cbind(lna_times,
                 matrix(
                         0.0,
                         nrow = length(lna_times),
                         ncol = nrow(flow_matrix),
                         dimnames = list(NULL, c(rownames(flow_matrix)))
                 ))

# set up MCMC objects
latent_lna_paths      <- array(0.0, 
                               dim = c(
                               length(lna_times),
                               1 + nrow(flow_matrix),
                               1 + floor(iterations / thin_latent_proc)
                               ))
latent_paths_natural  <- array(0.0,
                               dim = c(
                               nrow(censusmat),
                               ncol(censusmat),
                               1 + floor(iterations / thin_latent_proc)
                               ))
                                
lna_log_lik       <- double(1 + floor(iterations / thin_params))
data_log_lik      <- double(1 + floor(iterations / thin_params))
log_prior         <- double(1 + floor(iterations / thin_params))

# initialize the latent path
path <- initialize_lna(
        data                    = data,
        lna_parameters          = lna_parameters,
        censusmat               = censusmat,
        emitmat                 = emitmat,
        flow_matrix             = flow_matrix,
        lna_pointer             = lna_pointer,
        lna_set_pars_pointer    = lna_set_pars_pointer,
        lna_times               = lna_times,
        lna_initdist_inds       = lna_initdist_inds,
        param_update_inds       = param_update_inds,
        incidence_codes         = incidence_codes,
        census_incidence_codes  = census_incidence_codes,
        census_indices          = census_indices,
        measproc_indmat         = measproc_indmat,
        obstime_inds            = obstime_inds,
        d_meas_pointer          = d_meas_pointer,
        parameters              = parameters,
        constants               = constants,
        tcovar_censmat          = tcovar_censmat,
        do_prevalence           = do_prevalence,
        do_incidence            = do_incidence,
        initialization_attempts = 500
)

# save the current observed data log-likelihood and compute the
# likelihood of the latent LNA path
path <- lna_density2(
        path              = path,
        lna_times         = lna_times,
        lna_pars          = lna_parameters,
        param_update_inds = param_update_inds,
        flow_matrix       = flow_matrix,
        lna_pointer_ess   = lna_pointer_ess,
        lna_ess_set_pars_ptr = lna_ess_set_pars_ptr
)

# census the original LNA path
census_lna(
        path                = path$lna_path,
        census_path         = censusmat,
        census_inds         = census_indices,
        flow_matrix_lna     = flow_matrix,
        do_prevalence       = TRUE,
        init_state          = init_state,
        incidence_codes_lna = incidence_codes
        )

# save the initial path, data log-likelihood and the lna log-likelihood
latent_lna_paths[,,1]      <- path$lna_path
latent_paths_natural[,,1]  <- censusmat

for(k in 2:iterations) {

        if(k%%1000 == 0) {
                # print(k)
                cat(paste0("Incidence iteration ", k), sep = "\n", file = "lna_geweke.txt", append = TRUE)
        }
                
        path <- update_lna_path(
                        path_cur                = path,
                        data                    = data,
                        lna_parameters          = lna_parameters,
                        pathmat                 = pathmat,
                        censusmat               = censusmat,
                        emitmat                 = emitmat,
                        flow_matrix             = flow_matrix,
                        lna_pointer_ess         = lna_pointer_ess,
                        lna_ess_set_pars_ptr    = lna_ess_set_pars_ptr,
                        lna_times               = lna_times,
                        lna_initdist_inds       = lna_initdist_inds,
                        param_update_inds       = param_update_inds,
                        incidence_codes         = incidence_codes,
                        census_incidence_codes  = census_incidence_codes,
                        census_indices          = census_indices,
                        measproc_indmat         = measproc_indmat,
                        obstime_inds            = obstime_inds,
                        d_meas_pointer          = d_meas_pointer,
                        parameters              = parameters,
                        constants               = constants,
                        tcovar_censmat          = tcovar_censmat,
                        do_prevalence           = do_prevalence,
                        do_incidence            = do_incidence
                )

        # convert the path onto the natural state space
        census_lna(
                path                = path$lna_path,
                census_path         = censusmat,
                census_inds         = census_indices,
                flow_matrix_lna     = flow_matrix,
                do_prevalence       = TRUE,
                init_state          = init_state,
                incidence_codes_lna = incidence_codes
        )        
        
        # either compute the incidence, or compute the compartment counts if the data are prevalence counts
        if(do_incidence) {
                compute_incidence(censusmat = censusmat,
                                  col_inds  = census_incidence_codes,
                                  row_inds  = obstime_inds)
        }
        
        data <- simulate_r_measure(censusmat       = censusmat,
                                   measproc_indmat = measproc_indmat,
                                   parameters      = parameters,
                                   constants       = constants,
                                   tcovar          = tcovar_obstimes,
                                   r_measure_ptr   = r_meas_pointer)
        
        # recompute the emission probabilities given the new dataset
        evaluate_d_measure(emitmat          = emitmat,
                           obsmat           = data,
                           statemat         = censusmat,
                           measproc_indmat  = measproc_indmat,
                           parameters       = parameters,
                           constants        = constants,
                           tcovar_censusmat = tcovar_censmat,
                           d_meas_ptr       = d_meas_pointer)

        # compute the data log likelihood
        path$data_log_lik <- sum(emitmat[,-1][measproc_indmat])
        
        # save the new path and the new dataset
        if(k %% thin_latent_proc == 0) {
                latent_lna_paths[,,k/thin_latent_proc]     <- path$lna_path
                latent_paths_natural[,,k/thin_latent_proc] <- censusmat
        }
}

latent_lna_paths <- latent_lna_paths[,,-dim(latent_lna_paths)[3]]
latent_paths_natural <- latent_paths_natural[,,-dim(latent_paths_natural)[3]]

# now simulate latent lna paths 
stemr_paths <- simulate_stem(stem_object = stem_object, method = "lna", paths = TRUE, observations = T, tmax = tmax, nsim = iterations / thin_latent_proc, census_times = 0:tmax)

# paths simulated from the LNA
prev_paths_sim <- array(unlist(stemr_paths$natural_paths), 
                                  dim = c(nrow(stemr_paths$natural_paths[[1]]), 
                                          ncol(stemr_paths$natural_paths[[1]]), 
                                          length(stemr_paths$natural_paths)))
incid_paths_sim <- array(unlist(lapply(stemr_paths$paths, function(x) cbind(1:52, diff(x[,-1])))), 
                                  dim = c(length(obstimes), 
                                          ncol(stemr_paths$paths[[1]]), 
                                          length(stemr_paths$paths)))
lna_paths_sim <- array(unlist(stemr_paths$paths), 
                                  dim = c(nrow(stemr_paths$paths[[1]]), 
                                          ncol(stemr_paths$paths[[1]]), 
                                          length(stemr_paths$paths)))

# extract the S2I and I compartments from the relevant objects
prev_mcmc    <- latent_paths_natural[,3,] 
prev_mcmc    <- rbind(rep(10, ncol(latent_paths_natural)), prev_mcmc)
incid_mcmc   <- matrix(0.0, 53, dim(latent_paths_natural)[3])
for(k in seq_len(ncol(incid_mcmc))) {
        incid_mcmc[2:53,k] <- diff(latent_lna_paths[,2,k])
}
S2I_lna_mcmc <- latent_lna_paths[,2,]

prev_sim    <- prev_paths_sim[,3,]
incid_sim   <- rbind(rep(0,ncol(prev_sim)), incid_paths_sim[,2,])
S2I_lna_sim <- lna_paths_sim[,2,]

library(mcmc)
library(ggplot2)

calc_mcse <- function(x) {
        sqrt(initseq(x)$var.pos) / sqrt(ncol(prev_sim))
}

# prevalence natural path 
results_prev <- data.frame(method = rep(c("mcmc", "sim"), each = length(seq(t0,tmax))),
                              time   = rep(seq(t0, tmax), 2),
                              mean   = c(rowMeans(prev_mcmc), rowMeans(prev_sim)),
                              med    = c(apply(prev_mcmc, 1, median), apply(prev_sim, 1, median)),
                              mcse   = c(apply(prev_mcmc, 1, calc_mcse), 
                                         apply(prev_sim, 1, sd) / sqrt(ncol(prev_sim))), 
                              lower  = c(apply(prev_mcmc, 1, quantile, probs = 0.025), 
                                         apply(prev_sim, 1, quantile, probs = 0.025)), 
                              upper  = c(apply(prev_mcmc, 1, quantile, probs = 0.975), 
                                         apply(prev_sim, 1, quantile, probs = 0.975)))

# incidence
results_incid <- data.frame(method = rep(c("mcmc", "sim"), each = length(seq(0,tmax))),
                              time   = rep(seq(0, tmax), 2),
                              mean   = c(rowMeans(incid_mcmc), rowMeans(incid_sim)),
                              med    = c(apply(incid_mcmc, 1, median), apply(incid_sim, 1, median)),
                              mcse   = c(apply(incid_mcmc, 1, calc_mcse), 
                                         apply(incid_sim, 1, sd) / sqrt(ncol(prev_sim))), 
                              lower  = c(apply(incid_mcmc, 1, quantile, probs = 0.025), 
                                         apply(incid_sim, 1, quantile, probs = 0.025)), 
                              upper  = c(apply(incid_mcmc, 1, quantile, probs = 0.975), 
                                         apply(incid_sim, 1, quantile, probs = 0.975)))

# path of the counting process for S2I
results_S2I_lna <- data.frame(method = rep(c("mcmc", "sim"), each = length(seq(t0,tmax))),
                              time   = rep(seq(t0, tmax), 2),
                              mean   = c(rowMeans(S2I_lna_mcmc), rowMeans(S2I_lna_sim)),
                              med    = c(apply(S2I_lna_mcmc, 1, median), apply(S2I_lna_sim, 1, median)),
                              mcse   = c(apply(S2I_lna_mcmc, 1, calc_mcse), 
                                         apply(S2I_lna_sim, 1, sd) / sqrt(ncol(prev_sim))), 
                              lower  = c(apply(S2I_lna_mcmc, 1, quantile, probs = 0.025), 
                                         apply(S2I_lna_sim, 1, quantile, probs = 0.025)), 
                              upper  = c(apply(S2I_lna_mcmc, 1, quantile, probs = 0.975), 
                                         apply(S2I_lna_sim, 1, quantile, probs = 0.975)))

# produce the plots
pdf("lna_geweke_incidence.pdf")
# natural process
print(ggplot(results_prev, aes(x = time, y = mean, fill = method, colour = method)) + geom_ribbon(aes(ymin = pmax(mean - 1.96 * mcse, 0), ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of prevalence from prevalence data - mean and MCSE bands"))

print(ggplot(results_prev, aes(x = time, y = med, fill = method, colour = method)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of prevalence from prevalence data - median and 95% bands"))

# incidence
print(ggplot(results_incid, aes(x = time, y = mean, fill = method, colour = method)) + geom_ribbon(aes(ymin = pmax(mean - 1.96 * mcse, 0), ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of incidence from prevalence data - mean and MCSE bands"))

print(ggplot(results_incid, aes(x = time, y = med, fill = method, colour = method)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of incidence from prevalence data - median and 95% bands"))

# lna cumulative incidence
print(ggplot(results_S2I_lna, aes(x = time, y = mean, fill = method, colour = method)) + geom_ribbon(aes(ymin = pmax(mean - 1.96 * mcse, 0), ymax = mean + 1.96 * mcse), alpha = 0.2) + geom_line()  + labs(x = "time", y = "S2I", title = "Pointwise distribution of cumulative incidence LNA from prevalence data - mean and MCSE bands"))

print(ggplot(results_S2I_lna, aes(x = time, y = med, fill = method, colour = method)) + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) + geom_line()  + labs(x = "time", y = "I", title = "Pointwise distribution of cumulative incidence LNA from prevalence data - median and 95% bands"))

dev.off()
```

