---
title: "Testing 'stemr' LNA ODE paths vs 'issb' implementation"
author: "Jon Fintzi"
date: "October 8, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = T)
```

## Description
This vignette compares the LNA ODE paths for the drift, residual, and diffusion processes against those computed by the `issb` package. 

### Adapting the `issb` LNA function to output the drift and diffusion paths
We first load a modified version of the `lna` function from the `issb` package.
```{r}
library(issb)
library(stemr)
library(deSolve)
lnastep <- function (model, z, m, ddt) 
{
    u = length(z)
    state = c(z, m, rep(0, u^2))
    sol = ode(y = state, func = issb:::lnafun, times = c(0, ddt), parms = model, method = "rk4")
    sol = sol[nrow(sol), -1]
    z = sol[1:u]
    m = sol[(u + 1):(2 * u)]
    V = matrix(sol[-(1:(2 * u))], ncol = u)
    return(list(z = z, m = m, V = V))
}

lna <- function (model, maxtime, ddt, restart = FALSE, noise = T) 
{
    z         = model$get_initial() # drift ODE initialized here
    N         = max((maxtime + .Machine$double.eps^0.5)/ddt + 1, 2)
    xmat      = matrix(0, nrow = N, ncol = length(z) + 1)
    xmat[1, ] = c(0, z)
    driftmat  = xmat[,-1] # matrix in which to store the drift
    residmat  = xmat[,-1] # matrix in which to store the residual
    diffarr   = array(0.0, dim = c(length(z), length(z), N)) # array in which to store the diffusion
    m = z * 0
    V = matrix(0, length(z), length(z))
    for (i in 2:N) {
        lsol = lnastep(model, z, m, ddt)
        z = lsol[["z"]]

        # save the drift and diffusion ODEs
        driftmat[i, ] = lsol[["z"]]
        residmat[i,] = lsol[["m"]]
        diffarr[,,i]  = lsol[["V"]]
        
        new_x = z + lsol[["m"]]
        # if (noise) {
        #     new_x = mvrnorm(1, z + lsol[["m"]], lsol[["V"]])
        #     while (any(new_x < 0)) {
        #         new_x = mvrnorm(1, z + lsol[["m"]], lsol[["V"]])
        #     }
        # }
        xmat[i, ] = c(xmat[i - 1, 1] + ddt, new_x)
        m = xmat[i, -1] - lsol[["z"]]

    }
    colnames(xmat) = c("Time", rownames(model$get_stoic()))
    return(list(path = xmat, driftmat = driftmat, residmat = residmat, diffarr = diffarr))
}
```

### Setting up the LNA in the `issb` package
We now set up the simple SIR model in terms of the counting processes in the `issb` package. 
```{r}
# function for computing the hazards - expected change in cumulative number of events
# x = (N_{S_I}, N_{IR}); pars = (beta, mu, S_0, I_0, R_0)
h = function(x, pars) {
   hazs = numeric(length(x))
   hazs[1] = pars[1]*(pars[3] - x[1]) * (pars[4] + x[1] - x[2])
   hazs[2] = pars[2]*(pars[4] + x[1] - x[2])
   return(hazs)
}

# jacobian matrix
f = get_f = function(x, pars)
{
   fmat = matrix(0, nrow=2, ncol=2)
   fmat[1,1] = pars[1]*(pars[3] - pars[4] - 2*x[1] + x[2])
   fmat[1,2] = -pars[1]*(pars[3] - x[1])
   fmat[2,1] = pars[2]
   fmat[2,2] = -pars[2]
   return(fmat)
}

# stoichiometry matrix
smat = diag(1,2)
rownames(smat) = c("N_SI", "N_IR")

# initial condition
initial = c(0.0, 0.0)

# parameter values
pars = c(beta = 0.00001, mu = 1/7, S0 = 50000.0, I0 = 10.0, R0 = 50.0)

# create the model object
model = create_model(smat, h, initial, pars, f)

ddt = 0.001
# run the LNA
issb_path = lna(model, maxtime=2, ddt=ddt)
```

### Setting up the model in the `stemr` package - merely pulling the code out of the simulation function.
```{r}
compartments <- c("S","I","R")
rates <- list(rate("beta * I", "S", "I", incidence = FALSE),
              rate("mu", "I", "R"))
state_initializer <- stem_initializer(c(S = 50000, I = 10, R = 50), fixed = T)
parameters <- c(beta = 0.00001, mu = 1/7, rho = 0.5)
tcovar <- NULL
constants <- NULL
strata <- NULL
t0 <- 0; tmax <- 2; 
timestep <- NULL
adjacency <- NULL
messages <- T
nsim = 1
census_times = seq(0,tmax, by = ddt)

dynamics <- stem_dynamics(rates = rates, parameters = parameters, tmax = tmax, state_initializer = state_initializer, compartments=compartments, strata = strata, tcovar = tcovar, messages = TRUE, compile_ode = F, compile_rates = T)

stem_object <- stem(dynamics = dynamics)

# set the vectors of times when the LNA is evaluated and censused
lna_times <- sort(unique(c(census_times, stem_object$dynamics$.dynamics_args$tcovar[,1])))

# generate the matrix of parameters, constants, and time-varying covariates
lna_pars <- matrix(0.0, nrow = length(lna_times), ncol = length(stem_object$dynamics$lna_param_codes))
colnames(lna_pars) <- c(names(stem_object$dynamics$lna_param_codes))

# insert parameters, constants, and time-varying covariates
parameter_inds <- 1:length(stem_object$dynamics$param_codes)
constant_inds  <- (length(parameter_inds)+1):(length(parameter_inds) + length(stem_object$dynamics$const_codes))
tcovar_inds  <- (max(constant_inds)+1):ncol(lna_pars)
lna_pars[, parameter_inds] <- matrix(stem_object$dynamics$parameters, nrow = nrow(lna_pars), ncol = length(parameter_inds), byrow = T)
lna_pars[, constant_inds]  <- matrix(stem_object$dynamics$constants, nrow = nrow(lna_pars), ncol = length(constant_inds), byrow = T)

if(!is.null(stem_object$dynamics$.dynamics_args$tcovar)) {
        tcovar_rowinds          <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
        lna_pars[, tcovar_inds] <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
}

# generate some auxilliary objects
param_update_inds <- is.na(match(lna_times, census_times))

# simulate the LNA paths
census_paths <- vector(mode = "list", length = nsim)
lna_paths    <- vector(mode = "list", length = nsim)

# retrieve the initial state
init_state <- lna_pars[1, stem_object$dynamics$lna_initdist_inds + 1]

stemr_path <- propose_lna(lna_times,
                          lna_pars,
                          param_update_inds,
                          stem_object$dynamics$flow_matrix_lna,
                          stem_object$dynamics$lna_pointers$lna_pointer,
                          stem_object$dynamics$lna_pointers$lna_set_pars_ptr)

```

## Plotting the paths of the drift and diffusion processes, which appear to match.
```{r}
pdf("stemr_vs_issb_odes_rk.pdf")
par(mfrow = c(1,2))
plot(x = seq(0,tmax,by=ddt), y = issb_path$driftmat[,1], type = "l", col = "red", main = "Number of infections", ylab = "N_SI", xlab = "Time")
lines(x = seq(0,tmax,by=ddt), stemr_path$drift[,1], col = "blue", lty = 2)

plot(x = seq(0,tmax,by=ddt), y = issb_path$driftmat[,2], type = "l", col = "red", main = "Number of recoveries", ylab = "N_IR", xlab = "Time")
lines(x = seq(0,tmax,by=ddt), stemr_path$drift[,2], col = "blue", lty = 2)

plot(x = seq(0,tmax,by=ddt), y = issb_path$driftmat[,1] - stemr_path$drift[,1], "l", ylab = "ISSB_N_SI - stemr_N_SI")
plot(x = seq(0,tmax,by=ddt), y = issb_path$driftmat[,2] - stemr_path$drift[,2], "l", ylab = "ISSB_N_IR - stemr_N_IR")

par(mfrow = c(2,2))
plot(x = seq(0,tmax,by=ddt), y = issb_path$diffarr[1,1,], type = "l", col = "red", main = "Sigma_11", ylab = NULL, xlab = "Time")
lines(x = seq(0,tmax,by=ddt), stemr_path$diffusion[1,1,], col = "blue", lty = 2)

plot(x = seq(0,tmax,by=ddt), y = issb_path$diffarr[1,2,], type = "l", col = "red", main = "Sigma_12", ylab = NULL, xlab = "Time")
lines(x = seq(0,tmax,by=ddt), stemr_path$diffusion[1,2,], col = "blue", lty = 2)

plot(x = seq(0,tmax,by=ddt), y = issb_path$diffarr[2,1,], type = "l", col = "red", main = "Sigma_21", ylab = NULL, xlab = "Time")
lines(x = seq(0,tmax,by=ddt), stemr_path$diffusion[2,1,], col = "blue", lty = 2)

plot(x = seq(0,tmax,by=ddt), y = issb_path$diffarr[2,2,], type = "l", col = "red", main = "Sigma_22", ylab = NULL, xlab = "Time")
lines(x = seq(0,tmax,by=ddt), stemr_path$diffusion[2,2,], col = "blue", lty = 2)
dev.off()
```

We also check that the residual process is correctly integrated from time 1 to time 2 (it is zero between 0 and 1). 
```{r}
z         = stemr_path$drift[2,] # drift ODE initialized here
N         = max((2 + .Machine$double.eps^0.5)/1 + 1, 2)
xmat      = matrix(0, nrow = N, ncol = length(z) + 1)
xmat[1, ] = c(0, z)
driftmat  = xmat[,-1] # matrix in which to store the drift
residmat  = xmat[,-1] # matrix in which to store the residual
diffarr   = array(0.0, dim = c(length(z), length(z), N)) # array in which to store the diffusion
m = stemr_path$res_path[2,-1]
V = matrix(0, length(z), length(z))

u = length(z)
state = c(z, m, rep(0, u^2))
s = model$get_stoic()
u = nrow(s)
z0 = state[1:u]
m0 = state[(u + 1):(2 * u)]
V0 = matrix(state[(2 * u + 1):length(state)], ncol = u)
Ft = model$get_jacobian(z0)
h = model$get_haz(z0)

# test if hazards are equal
h_stemr = c((pars[1]*(pars[4]+state[1]-state[2]))*(pars[3]-state[1]), (pars[2])*(pars[4]+state[1]-state[2]))
all.equal(h, unname(h_stemr))

# test if jacobian is equal
Ft_stemr = matrix(c(pars[1]*(pars[3]-state[1])-(pars[1]*(pars[4]+state[1]-state[2])), 
             -(pars[1]*(pars[3]-state[1])), 
             (pars[2]), 
             -(pars[2])), 2, byrow = T)
all.equal(Ft, Ft_stemr)

# test if diffusion is equal
V = V0 %*% t(Ft) %*% t(s) + s %*% diag(h) %*% t(s) + s %*% Ft %*% V0
V_stemr = V0%*%Ft_stemr + diag(h_stemr) + Ft_stemr%*%V0
all.equal(V, V_stemr, check.attributes = F)

z         = stemr_path$drift[2,] # drift ODE initialized here
N         = max((2 + .Machine$double.eps^0.5)/1 + 1, 2)
xmat      = matrix(0, nrow = N, ncol = length(z) + 1)
xmat[1, ] = c(0, z)
driftmat  = xmat[,-1] # matrix in which to store the drift
residmat  = xmat[,-1] # matrix in which to store the residual
diffarr   = array(0.0, dim = c(length(z), length(z), N)) # array in which to store the diffusion
m = stemr_path$res_path[2,-1]
V = matrix(0, length(z), length(z))

state = c(z, m, rep(0.0, u^2))
sol = ode(y = state, func = issb:::lnafun, times = c(0, ddt), parms = model)[2,-1]
lsol = list(z = sol[1:u], m = sol[(u+1):(2*u)], V = matrix(sol[-(1:(2 * u))], ncol = u))
lsol = issb:::lnastep(model, z, m, 1)
all.equal(unname(lsol$m), unname(stemr_path$residual[3,]))
all.equal(unname(lsol$z), unname(stemr_path$drift[3,]))
all.equal(lsol$V, stemr_path$diffusion[,,3])

z = stemr_path$drift[3,] # drift ODE initialized here
m = stemr_path$res_path[3,-1]

u = length(z)
state = c(z, m, rep(0, u^2))
s = model$get_stoic()
u = nrow(s)
z0 = state[1:u]
m0 = state[(u + 1):(2 * u)]
V0 = matrix(state[(2 * u + 1):length(state)], ncol = u)
Ft = model$get_jacobian(z0)
h = model$get_haz(z0)

Ft_stemr = matrix(c(pars[1]*(pars[3]-state[1])-(pars[1]*(pars[4]+state[1]-state[2])), 
             -(pars[1]*(pars[3]-state[1])), 
             (pars[2]), 
             -(pars[2])), 2, byrow = T)
all.equal(Ft, Ft_stemr)

h_stemr = c((pars[1]*(pars[4]+state[1]-state[2]))*(pars[3]-state[1]), (pars[2])*(pars[4]+state[1]-state[2]))
all.equal(h, unname(h_stemr))

```


We can map the counting process onto the natural state space of compartment counts, $\mathcal{S} = \lbrace S,I,R \rbrace$, by applying the transformation, $X_t = f(N_t) = X_0 + A^TN_t$, where $A$ is the flow matrix for the SIR model (the transpose of the stoichiometry matrix). By the delta method, the diffusion matrix of $X_t$ is $A^T \Phi(t, N_t)A$. We now plot the transformed diffusion ODEs against the diffusion ODEs for the LNA on its natural state space (Fearnhead style LNA).

```{r}
# function for computing the hazards - expected change in cumulative number of events
# x = (N_{S_I}, N_{IR}); pars = (beta, mu, S_0, I_0, R_0)
h = function(x, pars) {
   hazs = numeric(length(pars))
   hazs[1] = pars[1]*x[1]*x[2]
   hazs[2] = pars[2]*x[2]
   return(hazs)
}

# jacobian matrix
f = get_f = function(x, pars)
{
   fmat = matrix(0, nrow=2, ncol=3)
   fmat[1,1] = pars[1] * x[2]
   fmat[1,2] = pars[1] * x[1]
   fmat[2,2] = pars[2]
   return(fmat)
}

# stoichiometry matrix
smat = matrix(c(-1,1,0,0,-1,1), ncol = 2)
rownames(smat) = c("S", "I", "R")

# initial condition
initial = c(50000,10,50)

# parameter values
pars = c(beta = 0.00001, mu = 1/7)

# create the model object
model = create_model(smat, h, initial, pars, f)

# run the LNA
issb_path_nat = lna(model, maxtime=tmax, ddt=1)

# transform the stemr diffusion process
stemr_diff_trans <- array(0,dim = c(3,3,length(seq(0,tmax))))
for(k in seq_along(seq(0,tmax,by=ddt))) {
        stemr_diff_trans[,,k] <- smat %*% stemr_path$diffusion[,,k] %*% t(smat)
}

compnames <- c("S", "I", "R")
par(mfrow = c(3,3)) 
for(j in 1:3) {
        for(k in 1:3) {
                plot(x = seq(0,tmax,by=ddt), y = issb_path_nat$diffarr[j,k,], 
                     type = "l", col = "red", main = paste0("Sigma_",compnames[j],compnames[k]), ylab = "", xlab = "Time")
                lines(x = seq(0,tmax,by=ddt), stemr_diff_trans[j,k,], col = "blue", lty = 2)
        }
}
```