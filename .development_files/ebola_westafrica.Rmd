---
title: "Fitting a multi-country model for Ebola transmission in West Africa using the stemr package"
author: "Jonathan Fintz, Jon Wakefield, and Vladimir N. Minin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fitting a multi-country model for Ebola transmission in West Africa using the stemr package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
- \usepackage{caption}
- \usepackage{multirow}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>")
```

# Overview

This vignette demonstrates how to simulate from and fit a multi-country SEIR model incorporating
within-country transmission as well as importation of cases from neighboring 
countries to partially observed incidence data using the the `stemr` package. 
This model was described and used in Fintzi, et al. (2019) to analyze national 
level incidence counts from the 2014-2015 outbreak of Ebola in West Africa, though
the focus of this vignette will be on fitting the model to simulated data in order 
to also demonstrate the simulation functionality of the package. The real data is
included in the package and is accessible by calling `data("ebola")` once the 
package is loaded. The models fit to the West Africa data and simulated data are 
largely the same, with only slight differences in the prior hyperparameters and the 
length of the simulated outbreak (70 vs. 73 weeks). Hence, the code used to fit 
the model to simulated data can also be used to analyze the real-world outbreak data . 
This vignette also includes code that can be used to fit the model to the simulated 
data using using the `pomp` package, as well as code for fitting the multi-country SEIR 
model to data from the 2014-2015 West Africa outbreak. 

# Model description

We will simulate from and fit a multi--country model for the spread of Ebola in Guinea, Liberia, and Sierra Leone under country--specific SEIR transmission dynamics, illustrated in the figure below. Cross--border transmission was incorporated via virtual migration of infectious individuals and was parameterized by extrinsic reproduction numbers, interpretable as the expected number of secondary cases in a country per index case in another country. Transmission was assumed to commence in Liberia on March 2$^{nd}$, 2014, and in Sierra Leone on May 4$ ^{th}$, 2014, corresponding to three weeks prior to the first cases in those countries. The observed incidence in each country was modeled as a negative binomial sample of the true incidence. The total incidence in each country was small relative to the population size, suggesting that only a fraction of the population was geographically or socially linked to ongoing transmission. Hence, we estimated the effective population size in each country, interpreted as the size of the sub--population within which the outbreak occurred.

![Diagram of state transitions for a joint model for Ebola transmission in Guinea, Liberia, and Sierra Leone. Dotted boxes denote countries, nodes in circles denote the model compartments: susceptible but removed from infectious contact $(S^R)$, susceptible but exposed to infectious contact $(S^E)$, exposed $(E)$, infectious $(I)$, recovered $(R)$. Compartments  are subscripted with country indicators. Solid lines with arrows indicate stochastic transitions between model compartments, which occur continuously in time. Dashed lines indicate that infected individuals in one country contribute to the force of infection in another country. Rates at which individuals transition between compartments are denoted by $\lambda$ and are subscripted by compartments and superscripted by countries, e.g., $\lambda_{S^EE}^L$ is the rate at which susceptible individuals become exposed in Liberia. Transmission in Liberia and Sierra Leone was assumed to commence at 10 and 19 weeks, respectively.](ebola_mod_fig.png)

| Parameter | Interpretation | Transition |
|:-:|:-:|:-:|
$\beta_A(t)$ | Per--contact rate of transmission within country $A$.| $S^{E}_A \rightarrow E_A$|
$\alpha_{AB}(t)$ | Per--contact rate of transmission from country $A$ to $B$. | $S^{E}_A \rightarrow E_A$ |
$\omega_A(t)$ | Rate at which latent individuals become infectious. | $E_A \rightarrow I_A$|
$\mu_A(t)$ | Rate at which infectious individuals recover. | $I_A \rightarrow R_A$|
$P_{eff,A}$| Effective population size. | ---|
$\rho_A$ | Mean case detection rate. | --- |
$\phi_A$ | Negative binomial overdispersion. | ---|
:Parameters and their interpretations. Subscripts, $A,B$, indicate countries. 

| Rate | Transition |
|:-:|:-:|
$\lambda^{A}_{S^EE}(t) = \beta_A(t)\left (I_A + \alpha_{BA}(t)I_B + \alpha_{CA}(t)I_C\right )S^E_A$ | $S^E_A\rightarrow E_A$|
$\lambda^{A}_{EI}(t) = \omega_A(t)E_A$ | $E_A\rightarrow I_A$ |
$\lambda^A_{IR}(t) = \mu_A(t)I_A$ | $I_A \rightarrow R_A$|
:Rates of state transition. Subscripts for rates indicate model compartments and superscripts indicate countries, while subscripts for compartments and parameters indicate countries. All rates of state transition for Liberia and Sierra Leone are zero until three weeks prior to the first detected case, when transmission was assumed to commence in each country.

# Simulating from and fitting the model

We initialize parameters and instatiate the SIR model in the code block below. 

```{r, echo = TRUE, warnings = FALSE}
library(stemr)
set.seed(52787)

# total population sizes
popsize_guin <- 11.8e6
popsize_lib <- 4.4e6
popsize_sln <- 7.1e6

log_popsize_guin <- log(popsize_guin)
log_popsize_lib <- log(popsize_lib)
log_popsize_sln <- log(popsize_sln)

# effective population sizes (i.e., number of susceptibles)
ep_guin <- 2e4
ep_lib <- 3.5e4
ep_sln <- 2.5e4

# initialize model dynamics
# each country is a stratum with SEIR compartments
strata <- c("guin", "lib", "sln")

# compartments given in a list, ALL is a reserved keyword indicating that 
# the compartment is present in all strata (countries). alternately, a character
# vector of strata in which each compartment occurs could be supplied
compartments <- list(S = "ALL", E = "ALL", I = "ALL", R = "ALL")

# rates of state transition - see help('rate') for additional details on specifying 
# rates. note that transmission_lib and transmission_sln are time-varying covariates
# that will be declared below.
rates <- 
      list(
            rate(
                  rate = "beta_guin * (I_guin + transmission_lib * alpha_lib2guin * I_lib + transmission_sln * alpha_sln2guin * I_sln) * S_guin",
                  from = "S",
                  to = "E",
                  strata = "guin",
                  lumped = TRUE,
                  incidence = T
            ),
            rate(
                  "transmission_lib * beta_lib * (I_lib + alpha_guin2lib * I_guin + transmission_sln * alpha_sln2lib * I_sln) * S_lib",
                  from = "S",
                  to = "E",
                  strata = "lib",
                  lumped = TRUE,
                  incidence = T
            ),
            rate(
                  "transmission_sln * beta_sln * (I_sln + alpha_guin2sln * I_guin + transmission_lib * alpha_lib2sln * I_lib) * S_sln",
                  from = "S",
                  to = "E",
                  strata = "sln",
                  lumped = TRUE,
                  incidence = T
            ),
            rate(
                  "omega_guin",
                  from = "E",
                  to = "I",
                  strata = "guin",
                  incidence = T
            ),
            rate(
                  "transmission_lib * omega_lib",
                  from = "E",
                  to = "I",
                  strata = "lib",
                  incidence = T
            ),
            rate(
                  "transmission_sln * omega_sln",
                  from = "E",
                  to = "I",
                  strata = "sln",
                  incidence = T
            ),
            rate(
                  "mu_guin",
                  from = "I",
                  to = "R",
                  strata = "guin",
                  incidence = T
            ),
            rate(
                  "transmission_lib * mu_lib",
                  from = "I",
                  to = "R",
                  strata = "lib",
                  incidence = T
            ),
            rate(
                  "transmission_sln * mu_sln",
                  from = "I",
                  to = "R",
                  strata = "sln",
                  incidence = T
            )
      )

# function for initializing the compartment volumes at time 0
# this is a list of stem_initializer lists, one for each stratum
state_initializer <- 
      list(
            stem_initializer(
                  c(
                        S_guin = ep_guin - 30,
                        E_guin = 15,
                        I_guin = 10,
                        R_guin = 5
                  ),
                  fixed = TRUE,
                  strata = "guin",
                  prior = c(popsize_guin - 30, 15, 10, 5)
            ),
            stem_initializer(
                  c(
                        S_lib = ep_lib - 30,
                        E_lib = 15,
                        I_lib = 10,
                        R_lib = 5
                  ),
                  fixed = TRUE,
                  strata = "lib",
                  prior = c(popsize_lib - 30, 15, 10, 5)
            ),
            stem_initializer(
                  c(
                        S_sln = ep_sln - 30,
                        E_sln = 15,
                        I_sln = 10,
                        R_sln = 5
                  ),
                  fixed = TRUE,
                  strata = "sln",
                  prior = c(popsize_sln - 30, 15, 10, 5)
            )
      )

# we declare time 0 as a constant and declare tmax
constants <- c(t0 = 0)
t0 <- 0; tmax <- 70;

# assume there is no transmission in liberia and sierra leone before weeks 10 and 19.
# we encode this using time-varying covariates. 
tcovar <- cbind(time = 0:tmax,
                transmission_lib = c(rep(0, 10), rep(1, (tmax + 1) - 10)),
                transmission_sln = c(rep(0, 19), rep(1, (tmax + 1) - 19)))

# recovery rates
mu_guin <- 0.9
mu_lib <- 1.1
mu_sln <- 1

# named vector of parameters on their natural scales (i.e., the scale on which they
# enter the rate functions). 
parameters = c(beta_guin = 1.2 / ep_guin * mu_guin, # backing out per-contact infec. from R0
               beta_lib = 1.35 / ep_lib * mu_lib,
               beta_sln = 1.45 / ep_sln * mu_sln,
               alpha_guin2lib = 0.02 / ep_lib * mu_guin,
               alpha_guin2sln = 0.02 / ep_sln * mu_guin,
               alpha_lib2guin = 0.02 / ep_guin * mu_lib,
               alpha_lib2sln  = 0.02 / ep_sln * mu_lib,
               alpha_sln2guin = 0.02 / ep_guin * mu_sln,
               alpha_sln2lib  = 0.02 / ep_lib * mu_sln,
               omega_guin = 1.2,
               omega_lib = 1,
               omega_sln = 0.8,
               mu_guin = mu_guin,
               mu_lib = mu_lib,
               mu_sln = mu_sln,
               rho_guin = 100/150,
               rho_lib = 100/175,
               rho_sln = 100/125,
               phi_guin = 100,
               phi_lib = 100,
               phi_sln = 100)

# save the true parameters for later
true_pars <- parameters

# initialize the model dynamics
dynamics <-
      stem_dynamics(
            rates = rates,
            tmax = tmax,
            timestep = NULL,
            parameters = parameters,
            state_initializer = state_initializer,
            compartments = compartments,
            constants = constants,
            strata = strata,
            tcovar = tcovar,
            messages = F,
            compile_ode = T,
            compile_rates = T,
            compile_lna = T,
            rtol = 1e-5,
            atol = 1e-5,
            step_size = 1e-7
      )

# the next step is to initialize the measurement process, see help("emission") for
# additional details on specifying the emission distributions.
# here we have different case detection rates and overdispersions for each country
emissions <-
      list(
            emission(
                  meas_var = "guin_cases",
                  distribution = "negbinomial",
                  emission_params = c("phi_guin", "E_guin2I_guin * rho_guin"),
                  incidence = TRUE,
                  obstimes = seq(1, tmax, by = 1)
            ),
            emission(
                  meas_var = "lib_cases",
                  distribution = "negbinomial",
                  emission_params = c("phi_lib", "E_lib2I_lib * rho_lib"),
                  incidence = TRUE,
                  obstimes = seq(10, tmax, by = 1)
            ),
            emission(
                  meas_var = "sln_cases",
                  distribution = "negbinomial",
                  emission_params = c("phi_sln", "E_sln2I_sln * rho_sln"),
                  incidence = TRUE,
                  obstimes = seq(19, tmax, by = 1)
            )
      )

# compile the measurement process
measurement_process <-
      stem_measure(emissions = emissions,
                   dynamics = dynamics,
                   messages = F)

# put it all together in a stem object - no data since we haven't simulated it yet
stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process)

```

After compiling the model, we simulate an outbreak from the MJP  using Gillespie's
direct algorithm as well as the observed incidence.  

```{r sim_dat, echo = TRUE}

# simulate the outbreak and dataset - defaults to simulation via the MJP
sim <- simulate_stem(stem_object)

# save the true path of the outbreak and the data
true_path   <- sim$paths[[1]]    # true incidence path
dat         <- sim$datasets[[1]] # data
total_cases <- colSums(dat[,-1]) # for priors as in Web Appendix D of Fintzi. et al. (2020)
```

```{r plot_sim, echo = TRUE, fig.width=8, fig.height=4}
require(ggplot2)
require(cowplot)

sim_dat = 
  data.frame(Country = rep(c("Guinea", "Liberia", "Sierra Leone"), each = tmax),
             Week = seq_len(tmax),
             Type = rep(c("True incidence", "Observed incidence"), each = 3*tmax),
             Count = 
               c(c(true_path[-1,c("E_guin2I_guin","E_lib2I_lib", "E_sln2I_sln")]),
               c(dat[,c("guin_cases", "lib_cases", "sln_cases")])))

sim_dat = subset(sim_dat,
                 !(Country == "Liberia" & Week < 10) & 
                   !(Country == "Sierra Leone" & Week < 19))

ggplot(sim_dat, 
       aes(x = Week, y = Count, shape = Type, colour = Country, fill = Type)) +
  geom_point(size = 2, alpha = 0.6) + 
  scale_shape_manual(breaks = c("True incidence", "Observed incidence"),
                     values = c(1, 16)) + 
  scale_colour_brewer(type = "qual", palette = 6) + 
  theme_minimal() + 
  # theme(legend.position = "bottom") + 
  facet_grid(.~Country)
```

# Fitting the model in stemr via the LNA or ODE approximations

We'll need to recompile the model dynamics and measurement process, both to tweak
the model to now estimate the effective population size and to let the package 
know that we're going to be fitting the model to data. After that, we'll specify
priors along, along with functions for going to and from the MCMC estimation scale. Details of the priors are given in Appendix E of Fintzi, et al. (2020).   

```{r recompile_mod, echo = TRUE}
set.seed(12511)

# tweaking the rates to accommodate an adjustment to the effective population 
# size. effpop_guin, effpop_lib, effpop_sln are the size of the susceptible 
# populations in each country that are effectively removed from transmission.
# So, for example, S_guin - effpop_guin is equal to the effective number of 
# susceptibles in Guinea

rates <-
  list(
    rate(
      rate = "beta_guin * (I_guin + transmission_lib * alpha_lib2guin * I_lib + transmission_sln * alpha_sln2guin * I_sln) * (S_guin - effpop_guin)",
      from = "S",
      to = "E",
      strata = "guin",
      lumped = TRUE,
      incidence = T
    ),
    rate(
      rate = "transmission_lib * beta_lib * (I_lib + alpha_guin2lib * I_guin + transmission_sln * alpha_sln2lib * I_sln) * (S_lib - effpop_lib)",
      from = "S",
      to = "E",
      strata = "lib",
      lumped = TRUE,
      incidence = T
    ),
    rate(
      rate = "transmission_sln * beta_sln * (I_sln + alpha_guin2sln * I_guin + transmission_lib * alpha_lib2sln * I_lib) * (S_sln - effpop_sln)",
      from = "S",
      to = "E",
      strata = "sln",
      lumped = TRUE,
      incidence = T
    ),
    rate(
      rate = "omega_guin",
      from = "E",
      to = "I",
      strata = "guin",
      incidence = T
    ),
    rate(
      rate = "transmission_lib * omega_lib",
      from = "E",
      to = "I",
      strata = "lib",
      incidence = T
    ),
    rate(
      rate = "transmission_sln * omega_sln",
      from = "E",
      to = "I",
      strata = "sln",
      incidence = T
    ),
    rate(
      rate = "mu_guin",
      from = "I",
      to = "R",
      strata = "guin",
      incidence = T
    ),
    rate(
      rate = "transmission_lib * mu_lib",
      from = "I",
      to = "R",
      strata = "lib",
      incidence = T
    ),
    rate(
      rate = "transmission_sln * mu_sln",
      from = "I",
      to = "R",
      strata = "sln",
      incidence = T
    )
  )

# initial states, now inferred as parameters in the model
state_initializer <-
  list(
    stem_initializer(
      c(
        S_guin = popsize_guin - 30,
        E_guin = 15,
        I_guin = 10,
        R_guin = 5
      ),
      fixed = FALSE,
      strata = "guin",
      prior = c(popsize_guin - 30, 15, 10, 5)
    ),
    stem_initializer(
      c(
        S_lib = popsize_lib - 30,
        E_lib = 15,
        I_lib = 10,
        R_lib = 5
      ),
      fixed = FALSE,
      strata = "lib",
      prior = c(popsize_lib - 30, 15, 10, 5)
    ),
    stem_initializer(
      c(
        S_sln = popsize_sln - 30,
        E_sln = 15,
        I_sln = 10,
        R_sln = 5
      ),
      fixed = FALSE,
      strata = "sln",
      prior = c(popsize_sln - 30, 15, 10, 5)
    )
  )

# same assumptions about transmission commencing in liberia and sierra leone
tcovar <- cbind(time = 0:tmax,
                transmission_lib = c(rep(0, 10), rep(1, (tmax+1) - 10)),
                transmission_sln = c(rep(0, 19), rep(1, (tmax+1) - 19)))

# parameters
parameters = c(beta_guin = 1.25 / ep_guin * mu_guin, 
               beta_lib = 1.35 / ep_lib * mu_lib,
               beta_sln = 1.45 / ep_sln * mu_sln,
               alpha_guin2lib = 0.02 / ep_lib * mu_guin,
               alpha_guin2sln = 0.02 / ep_sln * mu_guin,
               alpha_lib2guin = 0.02 / ep_guin * mu_lib,
               alpha_lib2sln  = 0.02 / ep_sln * mu_lib,
               alpha_sln2guin = 0.02 / ep_guin * mu_sln,
               alpha_sln2lib  = 0.02 / ep_lib * mu_sln,
               effpop_guin = popsize_guin - ep_guin,
               effpop_lib = popsize_lib - ep_lib,
               effpop_sln = popsize_sln - ep_sln,
               omega_guin = 1,
               omega_lib = 1,
               omega_sln = 1,
               mu_guin = mu_guin,
               mu_lib = mu_lib,
               mu_sln = mu_sln,
               rho_guin = 100/150,
               rho_lib = 100/175,
               rho_sln = 100/125,
               phi_guin = 50,
               phi_lib = 50,
               phi_sln = 50)

# declare t0 as a constant
constants <- c(t0 = 0)
t0 <- 0; tmax <- nrow(dat);

# compile the dynamics
dynamics <-
      stem_dynamics(
            rates = rates,
            tmax = tmax,
            timestep = NULL,
            parameters = parameters,
            state_initializer = state_initializer,
            compartments = compartments,
            constants = constants,
            strata = strata,
            tcovar = tcovar,
            messages = F,
            compile_ode = T,
            compile_rates = T,
            compile_lna = T,
            rtol = 1e-5,
            atol = 1e-5,
            step_size = 1e-7
      )

# compile the measurement process
emissions <-
  list(
    emission(
      meas_var = "guin_cases",
      distribution = "negbinomial",
      emission_params = c("phi_guin", "E_guin2I_guin * rho_guin"),
      incidence = TRUE,
      obstimes = seq(1, tmax, by = 1)
    ),
    emission(
      meas_var = "lib_cases",
      distribution = "negbinomial",
      emission_params = c("phi_lib", "E_lib2I_lib * rho_lib"),
      incidence = TRUE,
      obstimes = seq(10, tmax, by = 1)
    ),
    emission(
      meas_var = "sln_cases",
      distribution = "negbinomial",
      emission_params = c("phi_sln", "E_sln2I_sln * rho_sln"),
      incidence = TRUE,
      obstimes = seq(19, tmax, by = 1)
    )
  )

# recompile stemr object
measurement_process <-
  stem_measure(
    data = dat,
    emissions = emissions,
    dynamics = dynamics,
    messages = F
  )

stem_object <- stem(dynamics = dynamics, 
                    measurement_process = measurement_process)

#### initialize the inference
popsizes <- c(popsize_guin, popsize_lib, popsize_sln)

# to and from the MCMC estimation scale
to_estimation_scale <- function(params_nat) {
      
      l_effpops      <- log(popsizes - params_nat[10:12])
      l_Neffs_x_rhos <- l_effpops + log(params_nat[19:21])
      l_infecdurs    <- -log(params_nat[16:18])
      l_Reffs_m1     <- log(expm1(log(params_nat[1:3]) + l_effpops + l_infecdurs))
      
      return(c(
            l_Reffs_m1 + l_Neffs_x_rhos,
            log(params_nat[4:9]) + 
              l_effpops[c(2,3,1,3,1,2)] + l_infecdurs[c(1,1,2,2,3,3)],
            l_Neffs_x_rhos,
            log(params_nat[13:15]) + l_infecdurs,
            l_infecdurs,
            logit(params_nat[19:21]),
            -0.5 * log(params_nat[22:24])
      ))
}

from_estimation_scale <- function(params_est) {
      
      rhos       <- expit(params_est[19:21])
      l_effpops  <- params_est[10:12] - log(rhos)
      l_Reffs_m1 <- params_est[1:3] - params_est[10:12]
      
      return(c(
            exp(log1p(exp(l_Reffs_m1)) - l_effpops - params_est[16:18]),
            exp(params_est[4:9] - 
                  l_effpops[c(2,3,1,3,1,2)] - 
                  params_est[c(16, 16, 17, 17, 18, 18)]),
            popsizes - exp(l_effpops), 
            exp(params_est[13:15] - params_est[16:18]),
            exp(-params_est[16:18]),
            expit(params_est[19:21]),                                     
            exp(-2 * params_est[22:24])                                        
      ))
}

# function for calculating log prior density
prior_density =
         function(params_nat, params_est) {
           rhos       <- expit(params_est[19:21])
           l_effpops  <- params_est[10:12] - log(rhos)

           sum(
             dnorm(params_est[1:3]-params_est[10:12],log(0.5), 1.08, log = TRUE), 
             dexp(exp(params_est[4:9]), 40, log = TRUE) + params_est[4:9],
             dnorm(l_effpops, c(9.8, 10.5, 10.6), c(0.62, 0.62, 0.62), log = TRUE),
             dnorm(params_est[13:15], 0, 0.3, log = TRUE),
             dnorm(params_est[16:18], 0, 0.3, log = TRUE), 
             dnorm(params_est[19:21], 0.85, 0.75, log = TRUE),
             dexp(exp(params_est[22:24]), log = TRUE) + params_est[22:24])
           }

# put MCMC kernel functions into a list
priors <- 
  list(prior_density         = prior_density,
       to_estimation_scale   = to_estimation_scale,
       from_estimation_scale = from_estimation_scale)

# initialize covariance matrix starting with names of parameters on their 
# estimation scale
covmat_names <- c(
      "log_Reff_guin_o",
      "log_Reff_lib_o",
      "log_Reff_sln_o",
      "log_Rext_g2l",
      "log_Rext_g2s",
      "log_Rext_l2g",
      "log_Rext_l2s",
      "log_Rext_s2g",
      "log_Rext_s2l",
      "log_Neff_x_rho_guin",
      "log_Neff_x_rho_lib",
      "log_Neff_x_rho_sln",
      "log_omega_d_mu_guin",
      "log_omega_d_mu_lib",
      "log_omega_d_mu_sln",
      "log_infecdur_guin",
      "log_infecdur_lib",
      "log_infecdur_sln",
      "logit_rho_guin",
      "logit_rho_lib",
      "logit_rho_sln",
      "log_sqrt_phi_inv_guin",
      "log_sqrt_phi_inv_lib",
      "log_sqrt_phi_inv_sln"
)

covmat <- diag(c(rep(0.05,3),  # l_Reffs
                 rep(0.1, 6),  # Rext
                 rep(1, 3),    # log_effpop_x_rho
                 rep(0.05, 3), # log_omega_d_mu
                 rep(0.05, 3), # log_carriage_dur
                 rep(0.5, 3),  # logit_rho
                 rep(0.05, 3))) # log_phi
rownames(covmat) <- colnames(covmat) <- covmat_names

# create an MCMC kernel, we'll block update parameters using a multivariate
# normal slice sampler
mcmc_kernel <-
      kernel(
            method = "mvnss",
            sigma = covmat,
            scale_constant = 0.5,
            scale_cooling = 0.7,
            stop_adaptation = 5e2, # set to 5e4 in the paper
            step_size = 0.5,
            nugget = 1e-5, 
            harss_warmup = 0,
            mvnss_setting_list = 
                  mvnss_settings(n_mvnss_updates = 1, 
                                 initial_bracket_width = 0.5,
                                 bracket_limits = c(0.001, 5),
                                 nugget_cooling = 0.99, 
                                 nugget_step_size = 0.001),
            parameter_blocks = 
                  list(parblock(c("log_Reff_guin_o",
                                  "log_Rext_l2g", 
                                  "log_Rext_s2g",
                                  "log_Neff_x_rho_guin",
                                  "log_omega_d_mu_guin",
                                  "log_infecdur_guin",
                                  "logit_rho_guin",
                                  "log_sqrt_phi_inv_guin")),
                       parblock(c("log_Reff_lib_o", 
                                  "log_Rext_g2l", 
                                  "log_Rext_s2l",
                                  "log_Neff_x_rho_lib",
                                  "log_omega_d_mu_lib",
                                  "log_infecdur_lib",
                                  "logit_rho_lib",
                                  "log_sqrt_phi_inv_lib")),
                       parblock(c("log_Reff_sln_o", 
                                  "log_Rext_g2s", 
                                  "log_Rext_l2s",
                                  "log_Neff_x_rho_sln",
                                  "log_omega_d_mu_sln",
                                  "log_infecdur_sln",
                                  "logit_rho_sln",
                                  "log_sqrt_phi_inv_sln"))),
            joint_block_update = FALSE,
            messages = FALSE
      )

# initializing parameters at random values
stem_object$dynamics$parameters <- 
  function() {
    setNames(
      from_estimation_scale(
        to_estimation_scale(parameters) + 
          rnorm(length(parameters), 0, 0.1)),
      names(parameters))
}
```

We are now ready to fit the model. For the purpose of this vignette, we'll set 
the inference method to "ode". Fitting the model via the LNA only requires that 
the method be set to "lna". 

```{r fit_mod_sim, echo = T}
res <- 
  stem_inference(stem_object = stem_object,
                 method = "ode",     # change this to "lna" for linear noise approx.
                 iterations = 1.5e2, # set to 1.5e5 for paper
                 thin_params = 50, 
                 thin_latent_proc = 50, 
                 initialization_attempts = 500,
                 priors = priors,
                 mcmc_kernel = mcmc_kernel,
                 t0_kernel = t0_kernel,
                 ess_args = ess_settings(n_ess_updates = 1,
                                         ess_warmup = 100, 
                                         initdist_bracket_width = 2*pi,
                                         initdist_bracket_update = 5e3,
                                         lna_bracket_width = 2*pi,
                                         lna_bracket_update = 5e3,
                                         joint_strata_update = FALSE,
                                         joint_initdist_update = FALSE),
                 print_progress = 0,
                 messages = F)
```

The `stem_inference` function returns a list of MCMC samples, latent epidemic paths, and MCMC tuning parameters (e.g., global scaling parameter adapted in the MCMC). These can be accessed as follows:

```{r access_res, echo = TRUE}
runtime = res$results$time
mcmc_samples = res$results$MCMC_results
ode_paths = res$results$ode_paths # or res$results$lna_paths if using LNA
adapt_par = res$results$adaptation_record$adaptation_scale_record
```

# Fitting the SIR model with pomp

We can fit the model using the `pomp` package as follows. Note that pomp version 1.17 was used as a benchmark method in the paper. 

```{r pomp_fit, echo = TRUE, warning=FALSE, eval = FALSE}

# Load libraries ----------------------------------------------------------

library(pomp)

# Load data ------------------------------------------------

# data should be a data frame
dat <- as.data.frame(dat)

# set zero measurements to NA
dat[1:10,3] = NA
dat[1:19,4] = NA

# time-varying covariates for transmission
tcovar_pomp <-
      data.frame(time = seq(0, max(dat[,1]), by = 1/7))
tcovar_pomp$transmission_lib <- ifelse(tcovar_pomp$time < 10, 0.0, 1.0)
tcovar_pomp$transmission_sln <- ifelse(tcovar_pomp$time < 19, 0.0, 1.0)

# Set up pomp objects -----------------------------------------------------
# 
# # Measurement process objects
rmeas <- "
guin_cases = rnbinom_mu(exp(-2 * log_sqrt_phi_inv_guin), E2I_guin / (1 + exp(-logit_rho_guin)));
lib_cases  = rnbinom_mu(exp(-2 * log_sqrt_phi_inv_lib), E2I_lib / (1 + exp(-logit_rho_lib)));
sln_cases  = rnbinom_mu(exp(-2 * log_sqrt_phi_inv_sln), E2I_sln / (1 + exp(-logit_rho_sln)));
"

dmeas <- "
      double loglik_guin;
      double loglik_lib;
      double loglik_sln;

      loglik_guin = dnbinom_mu(guin_cases, exp(-2 * log_sqrt_phi_inv_guin), E2I_guin / (1 + exp(-logit_rho_guin)), 1);

      if(ISNA(lib_cases)) {
            loglik_lib = 0.0;
      } else {
            loglik_lib = dnbinom_mu(lib_cases, exp(-2 * log_sqrt_phi_inv_lib), E2I_lib / (1 + exp(-logit_rho_lib)), 1);
      }

      if(ISNA(sln_cases)) {
            loglik_sln = 0.0;
      } else {
            loglik_sln = dnbinom_mu(sln_cases, exp(-2 * log_sqrt_phi_inv_sln), E2I_sln / (1 + exp(-logit_rho_sln)), 1);
      }

      lik = loglik_guin + loglik_lib + loglik_sln;
      lik = (give_log) ? lik : exp(lik);
"

# define the stepper
ebola.step<-"
      // per contact infection
      double beta_guin;
      double beta_lib;
      double beta_sln;

      // cross country transmission
      double alpha_guin2lib;
      double alpha_guin2sln;
      double alpha_lib2guin;
      double alpha_lib2sln;
      double alpha_sln2guin;
      double alpha_sln2lib;

      // log effective population sizes
      double log_effpop_guin;
      double log_effpop_lib;
      double log_effpop_sln;

      // effective population sizes
      double effpop_guin;
      double effpop_lib;
      double effpop_sln;
      
      // effective numbers of susceptibles
      double S_eff_guin;
      double S_eff_lib;
      double S_eff_sln;

      // latent to infectious
      double omega_guin;
      double omega_lib;
      double omega_sln;

      // infectious to recovered
      double mu_guin;
      double mu_lib;
      double mu_sln;

      // detection rates
      double rho_guin;
      double rho_lib;
      double rho_sln;

      // rates and state transitions
      double rates[9];
      double dN[9];

      // get the parameters on their natural scales
      rho_guin = 1 / (1 + exp(-logit_rho_guin));
      rho_lib  = 1 / (1 + exp(-logit_rho_lib));
      rho_sln  = 1 / (1 + exp(-logit_rho_sln));

      log_effpop_guin = log_Neff_x_rho_guin - log(rho_guin);
      log_effpop_lib  = log_Neff_x_rho_lib - log(rho_lib);
      log_effpop_sln  = log_Neff_x_rho_sln - log(rho_sln);

      effpop_guin = 11800000 - exp(log_effpop_guin);
      effpop_lib  = 4400000 - exp(log_effpop_lib);
      effpop_sln  = 7100000 - exp(log_effpop_sln);

      beta_guin = exp(log(1 + exp(log_Reff_m1_o_guin - log_Neff_x_rho_guin)) - log_effpop_guin - log_mu_inv_guin);
      beta_lib  = exp(log(1 + exp(log_Reff_m1_o_lib - log_Neff_x_rho_lib)) - log_effpop_lib - log_mu_inv_lib);
      beta_sln  = exp(log(1 + exp(log_Reff_m1_o_sln - log_Neff_x_rho_sln)) - log_effpop_sln - log_mu_inv_sln);

      alpha_guin2lib = exp(log_Rext_g2l - log_effpop_lib  - log_mu_inv_guin);
      alpha_guin2sln = exp(log_Rext_g2s - log_effpop_sln  - log_mu_inv_guin);
      alpha_lib2guin = exp(log_Rext_l2g - log_effpop_guin - log_mu_inv_lib);
      alpha_lib2sln  = exp(log_Rext_l2s - log_effpop_sln  - log_mu_inv_lib);
      alpha_sln2guin = exp(log_Rext_s2g - log_effpop_guin - log_mu_inv_sln);
      alpha_sln2lib  = exp(log_Rext_s2l - log_effpop_lib  - log_mu_inv_sln);

      omega_guin = exp(log_omega_d_mu_guin - log_mu_inv_guin);
      omega_lib  = exp(log_omega_d_mu_lib - log_mu_inv_lib);
      omega_sln  = exp(log_omega_d_mu_sln - log_mu_inv_sln);

      mu_guin = exp(-log_mu_inv_guin);
      mu_lib  = exp(-log_mu_inv_lib);
      mu_sln  = exp(-log_mu_inv_sln);
      
      // compute effective number of susceptibles
      S_eff_guin = S_guin - effpop_guin;
      S_eff_lib = S_lib - effpop_lib;
      S_eff_sln = S_sln - effpop_sln;
      
      if(S_eff_guin < 0.0) S_eff_guin = 0.0;
      if(S_eff_lib < 0.0) S_eff_lib = 0.0;
      if(S_eff_sln < 0.0) S_eff_sln = 0.0;

      // compute rates
      rates[0] = beta_guin * (I_guin + transmission_lib * alpha_lib2guin * I_lib + transmission_sln * alpha_sln2guin * I_sln) / S_guin * S_eff_guin;
      rates[1] = transmission_lib * beta_lib * (I_lib + alpha_guin2lib * I_guin + transmission_sln * alpha_sln2lib * I_sln) / S_lib * S_eff_lib;
      rates[2] = transmission_sln * beta_sln * (I_sln + alpha_guin2sln * I_guin + transmission_lib * alpha_lib2sln * I_lib) / S_sln * S_eff_sln;
      rates[3] = omega_guin;
      rates[4] = transmission_lib * omega_lib;
      rates[5] = transmission_sln * omega_sln;
      rates[6] = mu_guin;
      rates[7] = transmission_lib * mu_lib;
      rates[8] = transmission_sln * mu_sln;

      // generate the incidence increments
      reulermultinom(1, S_guin, &rates[0], dt, &dN[0]);
      reulermultinom(1, S_lib, &rates[1], dt, &dN[1]);
      reulermultinom(1, S_sln, &rates[2], dt, &dN[2]);
      reulermultinom(1, E_guin, &rates[3], dt, &dN[3]);
      reulermultinom(1, E_lib,  &rates[4], dt, &dN[4]);
      reulermultinom(1, E_sln,  &rates[5], dt, &dN[5]);
      reulermultinom(1, I_guin, &rates[6], dt, &dN[6]);
      reulermultinom(1, I_lib,  &rates[7], dt, &dN[7]);
      reulermultinom(1, I_sln,  &rates[8], dt, &dN[8]);

      // increment the compartment counts
      S_guin += -dN[0];
      S_lib  += -dN[1];
      S_sln  += -dN[2];

      E_guin += dN[0] - dN[3];
      E_lib  += dN[1] - dN[4];
      E_sln  += dN[2] - dN[5];

      I_guin += dN[3] - dN[6];
      I_lib  += dN[4] - dN[7];
      I_sln  += dN[5] - dN[8];

      R_guin += dN[6];
      R_lib  += dN[7];
      R_sln  += dN[8];

      // increment the incidence
      E2I_guin += dN[3];
      E2I_lib  += dN[4];
      E2I_sln  += dN[5];
"

# instatiate the euler stepper function
ebola_sim <- euler.sim(step.fun = Csnippet(ebola.step), delta.t = 1/7)

# Define the priors
prior_density = function(params,..., log) {
      lik <- sum(
            # endogenous effective reproduction numbers - 1
            dnorm(params[c("log_Reff_m1_o_guin", "log_Reff_m1_o_lib", "log_Reff_m1_o_sln")] -
                        params[c("log_Neff_x_rho_guin", "log_Neff_x_rho_lib", "log_Neff_x_rho_sln")], log(0.5), 1.08, log = TRUE) +

            # exogenous effective reproduction numbers
            dexp(exp(params[c("log_Rext_g2l", "log_Rext_g2s", "log_Rext_l2g", "log_Rext_l2s", "log_Rext_s2g", "log_Rext_s2l")]), 40, log = TRUE) +
            params[c("log_Rext_g2l", "log_Rext_g2s", "log_Rext_l2g", "log_Rext_l2s", "log_Rext_s2g", "log_Rext_s2l")] +

            # effective population sizes
            dnorm(params[c("log_Neff_x_rho_guin", "log_Neff_x_rho_lib", "log_Neff_x_rho_sln")] -
                        log(expit(params[c("logit_rho_guin", "logit_rho_lib", "logit_rho_sln")])), c(9.8, 10.5, 10.6), c(0.62, 0.62, 0.62), log = TRUE) +

            # ratios of latent and infectious period durations
            dnorm(params[c("log_omega_d_mu_guin", "log_omega_d_mu_lib", "log_omega_d_mu_sln",
                           "log_mu_inv_guin", "log_mu_inv_lib", "log_mu_inv_sln")], 0, 0.3, log = TRUE) +

            # mean case detection rates
            dnorm(params[c("logit_rho_guin", "logit_rho_lib", "logit_rho_sln")], 0.85, 0.75, log = TRUE) +

            # negative binomial overdispersions
            dexp(exp(params[c("log_sqrt_phi_inv_guin", "log_sqrt_phi_inv_lib", "log_sqrt_phi_inv_sln")]), log = TRUE))

      if(!log) lik <- exp(lik)
      return(lik)
}

ebola_mod <- pomp(
      data = dat,
      times = "time",
      covar = tcovar_pomp,
      tcovar = "time",
      t0 = 0,                      # initial time point
      dmeasure = Csnippet(dmeas),  # evaluates the density of the measurement process
      rmeasure = Csnippet(rmeas),  # simulates from the measurement process
      rprocess = ebola_sim,        # simulates from the latent process
      obsnames = c("guin_cases", "lib_cases", "sln_cases"),
      statenames = c("S_guin", "E_guin", "I_guin", "R_guin",
                     "S_lib", "E_lib", "I_lib", "R_lib",
                     "S_sln", "E_sln", "I_sln", "R_sln",
                     "E2I_guin", "E2I_lib", "E2I_sln"),
      paramnames = c("log_Reff_m1_o_guin", "log_Reff_m1_o_lib", "log_Reff_m1_o_sln",
                     "log_Rext_g2l", "log_Rext_g2s", "log_Rext_l2g", "log_Rext_l2s", "log_Rext_s2g", "log_Rext_s2l",
                     "log_Neff_x_rho_guin", "log_Neff_x_rho_lib", "log_Neff_x_rho_sln",
                     "log_omega_d_mu_guin", "log_omega_d_mu_lib", "log_omega_d_mu_sln",
                     "log_mu_inv_guin", "log_mu_inv_lib", "log_mu_inv_sln",
                     "logit_rho_guin", "logit_rho_lib", "logit_rho_sln",
                     "log_sqrt_phi_inv_guin", "log_sqrt_phi_inv_lib", "log_sqrt_phi_inv_sln"),
      covarnames = c("transmission_lib", "transmission_sln"),
      zeronames = c("E2I_guin", "E2I_lib", "E2I_sln"),
      initializer = function (params, t0, ...)
      {
        init_counts <-
          setNames(
            c(rmultinom(1, popsize_guin, c(popsize_guin - 30, 15, 10, 5)),
              rmultinom(1, popsize_lib, c(popsize_lib - 30, 15, 10, 5)),
              rmultinom(1, popsize_sln, c(popsize_sln - 30, 15, 10, 5)),
              rep(0, 3)),
            c("S_guin","E_guin","I_guin","R_guin",
              "S_lib","E_lib","I_lib","R_lib",
              "S_sln","E_sln","I_sln","R_sln",
              "E2I_guin","E2I_lib","E2I_sln")
          )
        while (all(init_counts[c("E_guin", "I_guin")] == 0)) {
          init_counts <-
            setNames(
              c(rmultinom(1, popsize_guin, c(popsize_guin - 30, 15, 10, 5)),
                rmultinom(1, popsize_lib, c(popsize_lib - 30, 15, 10, 5)),
                rmultinom(1, popsize_sln, c(popsize_sln - 30, 15, 10, 5)),
                rep(0, 3)),
              c("S_guin","E_guin","I_guin","R_guin",
                "S_lib","E_lib","I_lib","R_lib",
                "S_sln","E_sln","I_sln","R_sln",
                "E2I_guin","E2I_lib","E2I_sln")
            )
        }
        return(init_counts)
      },
      params = c(log_Reff_m1_o_guin = 8.1,
                 log_Reff_m1_o_lib = 8.9,
                 log_Reff_m1_o_sln = 9.1,
                 log_Rext_g2l = -3.9,
                 log_Rext_g2s = -3.9,
                 log_Rext_l2g = -3.9,
                 log_Rext_l2s = -3.9,
                 log_Rext_s2g = -3.9,
                 log_Rext_s2l = -3.9,
                 log_Neff_x_rho_guin = 9.5,
                 log_Neff_x_rho_lib = 9.9,
                 log_Neff_x_rho_sln = 9.9,
                 log_omega_d_mu_guin = 0.1,
                 log_omega_d_mu_lib = -0.1,
                 log_omega_d_mu_sln = 0,
                 log_mu_inv_guin = 0.1,
                 log_mu_inv_lib = -0.1,
                 log_mu_inv_sln = 0,
                 logit_rho_guin = 0.7,
                 logit_rho_lib = 0.3,
                 logit_rho_sln = 1.4,
                 log_sqrt_phi_inv_guin = -2,
                 log_sqrt_phi_inv_lib = -2,
                 log_sqrt_phi_inv_sln = -2),
      dprior = prior_density
)

# initial values
params_init <- c(log_Reff_m1_o_guin = 8.1,
                 log_Reff_m1_o_lib = 8.9,
                 log_Reff_m1_o_sln = 9.1,
                 log_Rext_g2l = -3.9,
                 log_Rext_g2s = -3.9,
                 log_Rext_l2g = -3.9,
                 log_Rext_l2s = -3.9,
                 log_Rext_s2g = -3.9,
                 log_Rext_s2l = -3.9,
                 log_Neff_x_rho_guin = 9.5,
                 log_Neff_x_rho_lib = 9.9,
                 log_Neff_x_rho_sln = 9.9,
                 log_omega_d_mu_guin = 0.1,
                 log_omega_d_mu_lib = -0.1,
                 log_omega_d_mu_sln = 0,
                 log_mu_inv_guin = 0.1,
                 log_mu_inv_lib = -0.1,
                 log_mu_inv_sln = 0,
                 logit_rho_guin = 0.7,
                 logit_rho_lib = 0.3,
                 logit_rho_sln = 1.4,
                 log_sqrt_phi_inv_guin = -2,
                 log_sqrt_phi_inv_lib = -2,
                 log_sqrt_phi_inv_sln = -2)

starts <- function() params_init + rnorm(length(params_init), 0, 0.1)

# run the MCMC
covmat <- diag(0.01, length(params_init))
rownames(covmat) <- colnames(covmat) <- names(params_init)

# run pomp
res_adapt = 
  pmcmc(ebola_mod,
      Nmcmc  = 5e1, # set to 5e4 in paper
      Np     = 1e1, # set to 1e3 in paper
      start  = starts(),
      proposal =
        mvn.rw.adaptive(rw.var = covmat,
                        scale.cooling = 0.99975,
                        scale.start = 100,
                        shape.start = 100
                        ))
                              
# freeze adaptation and do final run
res <- continue(res_adapt,
                Nmcmc = 3e2, # set to 3e5 in the paper
                proposal =
                mvn.rw(covmat(res_adapt)))

```

# Fitting the model to data from the 2014-2015 West Africa outbreak

National level WHO incidence counts from the 2014-2015 Ebola outbreak in West Africa are included in the package and may be accessed via `data("ebola")` after
the package is loaded. The only changes vis-a-vis the simulation code shown above
were to the outbreak length (73 vs. 70 weeks) and to the priors for the effective
population sizes, which were tuned by inflating the observed outbreak sizes by
some crude estimates of the case detection ratio to match the expected outbreak
sizes under our priors for the basic reproduction number. This is further explained in Web Appendices D and E of Fintzi, et al. (2020). 

```{r ebola_westafr, echo = T, eval = FALSE}
rm(list=ls(all.names = T))
data("ebola")
dat = ebola; rm(ebola) # just renaming
colnames(dat)[2:4] = c("guin_cases", "lib_cases", "sln_cases")
tmax <- nrow(dat)

popsize_guin <- 11.8e6
popsize_lib <- 4.4e6
popsize_sln <- 7.1e6

log_popsize_guin <- log(popsize_guin)
log_popsize_lib <- log(popsize_lib)
log_popsize_sln <- log(popsize_sln)

# stemr object separate dynamics for all countries --------------------------------------------------
set.seed(12511)
strata <- c("guin", "lib", "sln")
compartments <- list(S = "ALL", E = "ALL", I = "ALL", R = "ALL")

# rates
rates <-
  list(
    rate(
      "beta_guin * (I_guin + transmission_lib * alpha_lib2guin * I_lib + transmission_sln * alpha_sln2guin * I_sln) * (S_guin - effpop_guin)",
      from = "S",
      to = "E",
      strata = "guin",
      lumped = TRUE,
      incidence = T
    ),
    rate(
      "transmission_lib * beta_lib * (I_lib + alpha_guin2lib * I_guin + transmission_sln * alpha_sln2lib * I_sln) * (S_lib - effpop_lib)",
      from = "S",
      to = "E",
      strata = "lib",
      lumped = TRUE,
      incidence = T
    ),
    rate(
      "transmission_sln * beta_sln * (I_sln + alpha_guin2sln * I_guin + transmission_lib * alpha_lib2sln * I_lib) * (S_sln - effpop_sln)",
      from = "S",
      to = "E",
      strata = "sln",
      lumped = TRUE,
      incidence = T
    ),
    rate(
      "omega_guin",
      from = "E",
      to = "I",
      strata = "guin",
      incidence = T
    ),
    rate(
      "transmission_lib * omega_lib",
      from = "E",
      to = "I",
      strata = "lib",
      incidence = T
    ),
    rate(
      "transmission_sln * omega_sln",
      from = "E",
      to = "I",
      strata = "sln",
      incidence = T
    ),
    rate(
      "mu_guin",
      from = "I",
      to = "R",
      strata = "guin",
      incidence = T
    ),
    rate(
      "transmission_lib * mu_lib",
      from = "I",
      to = "R",
      strata = "lib",
      incidence = T
    ),
    rate(
      "transmission_sln * mu_sln",
      from = "I",
      to = "R",
      strata = "sln",
      incidence = T
    )
  )

# initial state

state_initializer <-
  list(
    stem_initializer(
      c(
        S_guin = popsize_guin - 30,
        E_guin = 15,
        I_guin = 10,
        R_guin = 5
      ),
      fixed = FALSE,
      strata = "guin",
      prior = c(popsize_guin - 30, 15, 10, 5)
    ),
    stem_initializer(
      c(
        S_lib = popsize_lib - 30,
        E_lib = 15,
        I_lib = 10,
        R_lib = 5
      ),
      fixed = FALSE,
      strata = "lib",
      prior = c(popsize_lib - 30, 15, 10, 5)
    ),
    stem_initializer(
      c(
        S_sln = popsize_sln - 30,
        E_sln = 15,
        I_sln = 10,
        R_sln = 5
      ),
      fixed = FALSE,
      strata = "sln",
      prior = c(popsize_sln - 30, 15, 10, 5)
    )
  )

# time varying covariates
tcovar <- cbind(time = 0:tmax,
                transmission_lib = c(rep(0, 10), rep(1, (tmax+1) - 10)),
                transmission_sln = c(rep(0, 19), rep(1, (tmax+1) - 19)))

# effective population sizes
ep_guin <- 1.5e4
ep_lib  <- 3e4
ep_sln  <- 4.5e4

parameters = c(beta_guin = 1.25 / ep_guin,
               beta_lib = 1.5 / ep_lib,
               beta_sln = 1.5 / ep_sln,
               alpha_guin2lib = 0.02 / ep_lib,
               alpha_guin2sln = 0.02 / ep_sln,
               alpha_lib2guin = 0.02 / ep_guin,
               alpha_lib2sln  = 0.02 / ep_sln,
               alpha_sln2guin = 0.02 / ep_guin,
               alpha_sln2lib  = 0.02 / ep_lib,
               effpop_guin = popsize_guin - ep_guin,
               effpop_lib = popsize_lib - ep_lib,
               effpop_sln = popsize_sln - ep_sln,
               omega_guin = 1,
               omega_lib = 1,
               omega_sln = 1,
               mu_guin = 1,
               mu_lib = 1,
               mu_sln = 1,
               rho_guin = 0.75,
               rho_lib = 0.75,
               rho_sln = 0.75,
               phi_guin = 10,
               phi_lib = 10,
               phi_sln = 10)

constants <- c(t0 = 0)
t0 <- 0; tmax <- nrow(dat);

dynamics <-
      stem_dynamics(
            rates = rates,
            tmax = tmax,
            timestep = NULL,
            parameters = parameters,
            state_initializer = state_initializer,
            compartments = compartments,
            constants = constants,
            strata = strata,
            tcovar = tcovar,
            messages = F,
            compile_ode = T,
            compile_rates = T,
            compile_lna = T,
            rtol = 1e-5,
            atol = 1e-5,
            step_size = 1e-6
      )

# emission distribution
emissions <-
  list(
    emission(
      "guin_cases",
      "negbinomial",
      c("phi_guin", "E_guin2I_guin * rho_guin"),
      incidence = TRUE,
      obstimes = seq(1, tmax, by = 1)
    ),
    emission(
      "lib_cases",
      "negbinomial",
      c("phi_lib", "E_lib2I_lib * rho_lib"),
      incidence = TRUE,
      obstimes = seq(10, tmax, by = 1)
    ),
    emission(
      "sln_cases",
      "negbinomial",
      c("phi_sln", "E_sln2I_sln * rho_sln"),
      incidence = TRUE,
      obstimes = seq(19, tmax, by = 1)
    )
  )

# recompile stemr object
measurement_process <- 
  stem_measure(data = dat, 
               emissions = emissions, 
               dynamics = dynamics, 
               messages = F)

stem_object <- stem(dynamics = dynamics, measurement_process = measurement_process)

#### initialize the MCMC objects
popsizes     <- c(popsize_guin, popsize_lib, popsize_sln)

# to and from the MCMC estimation scale
to_estimation_scale <- function(params_nat) {
      
      l_effpops      <- log(popsizes - params_nat[10:12])
      l_Neffs_x_rhos <- l_effpops + log(params_nat[19:21])
      l_infecdurs    <- -log(params_nat[16:18])
      l_Reffs_m1     <- log(expm1(log(params_nat[1:3]) + l_effpops + l_infecdurs))
      
      return(c(
            l_Reffs_m1 + l_Neffs_x_rhos,
            log(params_nat[4:9]) + l_effpops[c(2,3,1,3,1,2)] + l_infecdurs[c(1,1,2,2,3,3)],
            l_Neffs_x_rhos,
            log(params_nat[13:15]) + l_infecdurs,
            l_infecdurs,
            logit(params_nat[19:21]),
            -0.5 * log(params_nat[22:24])
      ))
}

from_estimation_scale <- function(params_est) {
      
      rhos       <- expit(params_est[19:21])
      l_effpops  <- params_est[10:12] - log(rhos)
      l_Reffs_m1 <- params_est[1:3] - params_est[10:12]
      
      return(c(
            exp(log1p(exp(l_Reffs_m1)) - l_effpops - params_est[16:18]),
            exp(params_est[4:9] - l_effpops[c(2,3,1,3,1,2)] - params_est[c(16, 16, 17, 17, 18, 18)]),                               
            popsizes - exp(l_effpops), 
            exp(params_est[13:15] - params_est[16:18]),
            exp(-params_est[16:18]),                                                   
            expit(params_est[19:21]),                                     
            exp(-2 * params_est[22:24])                                        
      ))
}

priors <- list(
  prior_density =
    function(params_nat, params_est) {
      rhos       <- expit(params_est[19:21])
      l_effpops  <- params_est[10:12] - log(rhos)
      
      sum(
        dnorm(params_est[1:3] - params_est[10:12], log(0.5), 1.08, log = TRUE),
        dexp(exp(params_est[4:9]), 40, log = TRUE) + params_est[4:9],
        dnorm(l_effpops, c(9.6, 9.9, 10.7), c(0.62, 0.62, 0.62), log = TRUE),
        dnorm(params_est[13:15], 0, 0.3, log = TRUE),
        dnorm(params_est[16:18], 0, 0.3, log = TRUE),
        dnorm(params_est[19:21], 0.85, 0.75, log = TRUE),
        dexp(exp(params_est[22:24]), 0.69, log = TRUE) + params_est[22:24]
      )
    },
  to_estimation_scale   = to_estimation_scale,
  from_estimation_scale = from_estimation_scale
)

covmat_names <- c(
      "log_Reff_guin_o",
      "log_Reff_lib_o",
      "log_Reff_sln_o",
      "log_Rext_g2l",
      "log_Rext_g2s",
      "log_Rext_l2g",
      "log_Rext_l2s",
      "log_Rext_s2g",
      "log_Rext_s2l",
      "log_Neff_x_rho_guin",
      "log_Neff_x_rho_lib",
      "log_Neff_x_rho_sln",
      "log_omega_d_mu_guin",
      "log_omega_d_mu_lib",
      "log_omega_d_mu_sln",
      "log_infecdur_guin",
      "log_infecdur_lib",
      "log_infecdur_sln",
      "logit_rho_guin",
      "logit_rho_lib",
      "logit_rho_sln",
      "log_sqrt_phi_inv_guin",
      "log_sqrt_phi_inv_lib",
      "log_sqrt_phi_inv_sln"
)

covmat <- diag(c(rep(0.05,3),  # l_Reffs
                 rep(0.1, 6),  # Rext
                 rep(1, 3),    # log_effpop_x_rho
                 rep(0.05, 3), # log_omega_d_mu
                 rep(0.05, 3), # log_carriage_dur
                 rep(0.5, 3),  # logit_rho
                 rep(0.05, 3))) # log_phi
rownames(covmat) <- colnames(covmat) <- covmat_names

mcmc_kernel <-
      kernel(
            method = "mvnss",
            sigma = covmat,
            scale_constant = 0.5,
            scale_cooling = 0.7,
            stop_adaptation = 5e4,
            step_size = 0.5,
            nugget = 1e-5, 
            harss_warmup = 0,
            mvnss_setting_list = 
                  mvnss_settings(n_mvnss_updates = 1, 
                                 initial_bracket_width = 0.5,
                                 bracket_limits = c(0.001, 5),
                                 nugget_cooling = 0.99, 
                                 nugget_step_size = 0.001),
            parameter_blocks = 
                  list(parblock(c("log_Reff_guin_o",
                                  "log_Rext_l2g", 
                                  "log_Rext_s2g",
                                  "log_Neff_x_rho_guin",
                                  "log_omega_d_mu_guin",
                                  "log_infecdur_guin",
                                  "logit_rho_guin",
                                  "log_sqrt_phi_inv_guin")),
                       parblock(c("log_Reff_lib_o", 
                                  "log_Rext_g2l", 
                                  "log_Rext_s2l",
                                  "log_Neff_x_rho_lib",
                                  "log_omega_d_mu_lib",
                                  "log_infecdur_lib",
                                  "logit_rho_lib",
                                  "log_sqrt_phi_inv_lib")),
                       parblock(c("log_Reff_sln_o", 
                                  "log_Rext_g2s", 
                                  "log_Rext_l2s",
                                  "log_Neff_x_rho_sln",
                                  "log_omega_d_mu_sln",
                                  "log_infecdur_sln",
                                  "logit_rho_sln",
                                  "log_sqrt_phi_inv_sln"))),
            joint_block_update = FALSE,
            messages = FALSE
      )

stem_object$dynamics$parameters <- function() {
      setNames(from_estimation_scale(to_estimation_scale(parameters) + rnorm(length(parameters), 0, 0.1)),
               names(parameters))
}

# fit the model
res <- 
  stem_inference(stem_object = stem_object,
                 method = "ode",
                 iterations = 1.5e5, 
                 thin_params = 50, 
                 thin_latent_proc = 50, 
                 initialization_attempts = 500,
                 priors = priors,
                 mcmc_kernel = mcmc_kernel,
                 t0_kernel = t0_kernel,
                 ess_args = ess_settings(n_ess_updates = 1,
                                         ess_warmup = 100, 
                                         initdist_bracket_width = 2*pi,
                                         initdist_bracket_update = 5e3,
                                         lna_bracket_width = 2*pi,
                                         lna_bracket_update = 5e3,
                                         joint_strata_update = FALSE),
                 print_progress = 1e3,
                 messages = F)
```


# References

Fintzi, J., Wakefield, J., & Minin, V. N. (2020). __A linear noise approximation for stochastic epidemic models fit to partially observed incidence counts.__ arXiv preprint arXiv:2001.05099.
