// Copyright Timothy H. Keitt 2015
// See license for odeintr package

// [[Rcpp::depends(odeintr)]]


// [[Rcpp::plugins(cpp11)]]

// [[Rcpp::depends(BH)]]
#include "boost/numeric/odeint.hpp"
namespace odeint = boost::numeric::odeint;

// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
using namespace arma;;

namespace odeintr
{
  static const std::size_t N = 6;

  typedef std::vector<double> state_type;
  
  static state_type state(N);
  
  typedef odeint::runge_kutta_dopri5<state_type> stepper_type;
  
  static auto stepper = odeint::make_dense_output(1e-08, 1e-08, stepper_type());
  
  typedef std::vector<double> vec_type;
  static std::vector<vec_type> rec_x(N);
  static vec_type rec_t;
  
  std::array<double, 9> pars;static arma::vec Z(2,arma::fill::zeros);
static arma::vec exp_Z(2,arma::fill::zeros);
static arma::vec exp_neg_Z(2,arma::fill::zeros);
static arma::vec exp_neg_2Z(2,arma::fill::zeros);
static arma::vec hazards(2,arma::fill::zeros);
static arma::mat jacobian(2,2,arma::fill::zeros);
static arma::mat diffusion(2,2,arma::fill::zeros);
static arma::vec diffusion_ode(4,arma::fill::zeros);;
  
  #include "utils.h"
  
  static void
  sys(const state_type x, state_type &dxdt, const double t)
  {
    odeintr::Z = arma::vec(x).subvec(0,1);
odeintr::exp_Z = arma::exp(odeintr::Z);
odeintr::exp_neg_Z = arma::exp(-odeintr::Z);
odeintr::exp_neg_2Z = arma::square(odeintr::exp_neg_Z);
odeintr::diffusion = arma::reshape(arma::vec(x).subvec(2,5),2,2);
odeintr::hazards[0] = (odeintr::exp_neg_Z[0]-0.5*odeintr::exp_neg_2Z[0])*((odeintr::pars[0]*(odeintr::pars[5]+(odeintr::exp_Z[0]-1)-(odeintr::exp_Z[1]-1)))*(odeintr::pars[4]-(odeintr::exp_Z[0]-1)));
odeintr::hazards[1] = (odeintr::exp_neg_Z[1]-0.5*odeintr::exp_neg_2Z[1])*((odeintr::pars[1])*(odeintr::pars[5]+(odeintr::exp_Z[0]-1)-(odeintr::exp_Z[1]-1)));
odeintr::jacobian(0, 0) = (odeintr::exp_neg_Z[0]-0.5*odeintr::exp_neg_2Z[0])*(odeintr::pars[0]*odeintr::exp_Z[0]*(odeintr::pars[4]-(odeintr::exp_Z[0]-1))-(odeintr::pars[0]*(odeintr::pars[5]+(odeintr::exp_Z[0]-1)-(odeintr::exp_Z[1]-1)))*odeintr::exp_Z[0])-(odeintr::exp_neg_Z[0]-0.5*(odeintr::exp_neg_2Z[0]*2))*((odeintr::pars[0]*(odeintr::pars[5]+(odeintr::exp_Z[0]-1)-(odeintr::exp_Z[1]-1)))*(odeintr::pars[4]-(odeintr::exp_Z[0]-1)));
odeintr::jacobian(0, 1) = -((odeintr::exp_neg_Z[0]-0.5*odeintr::exp_neg_2Z[0])*(odeintr::pars[0]*odeintr::exp_Z[1]*(odeintr::pars[4]-(odeintr::exp_Z[0]-1))));
odeintr::jacobian(1, 0) = (odeintr::exp_neg_Z[1]-0.5*odeintr::exp_neg_2Z[1])*((odeintr::pars[1])*odeintr::exp_Z[0]);
odeintr::jacobian(1, 1) = -((odeintr::exp_neg_Z[1]-0.5*odeintr::exp_neg_2Z[1])*((odeintr::pars[1])*odeintr::exp_Z[1])+(odeintr::exp_neg_Z[1]-0.5*(odeintr::exp_neg_2Z[1]*2))*((odeintr::pars[1])*(odeintr::pars[5]+(odeintr::exp_Z[0]-1)-(odeintr::exp_Z[1]-1))));
odeintr::diffusion_ode = arma::vectorise(odeintr::diffusion * odeintr::jacobian.t() + arma::diagmat(odeintr::exp_neg_2Z % odeintr::hazards) + odeintr::jacobian * odeintr::diffusion, 0);
dxdt[0] = odeintr::hazards[0];
dxdt[1] = odeintr::hazards[1];
dxdt[2] = odeintr::diffusion_ode[0];
dxdt[3] = odeintr::diffusion_ode[1];
dxdt[4] = odeintr::diffusion_ode[2];
dxdt[5] = odeintr::diffusion_ode[3];;
  }

  static void
  obs(const state_type x, const double t)
  {
    for (int i = 0; i != N; ++i)
      rec_x[i].push_back(x[i]);
    rec_t.push_back(t);
  }
  
}; // namespace odeintr

static void
reserve(odeintr::vec_type::size_type n)
{
  odeintr::rec_t.reserve(n);
  for (auto &i : odeintr::rec_x) i.reserve(n);
}

// [[Rcpp::export]]
Rcpp::List INTEGRATE_LNA_get_output()
{
  Rcpp::List out;
  out("Time") = Rcpp::wrap(odeintr::rec_t);
  for (int i = 0; i != odeintr::N; ++i)
  {
    auto cnam = std::string("X") + std::to_string(i + 1);
    out(cnam) = Rcpp::wrap(odeintr::rec_x[i]);
  }
  out.attr("class") = "data.frame";
  int rows_out = odeintr::rec_t.size();
  auto rn = Rcpp::IntegerVector::create(NA_INTEGER, -rows_out);
  out.attr("row.names") = rn;
  return out;
};

// [[Rcpp::export]]
void INTEGRATE_LNA_set_state(Rcpp::NumericVector new_state)
{
  if (new_state.size() != odeintr::N)
    Rcpp::stop("Invalid initial state");
  std::copy(new_state.begin(),
            new_state.end(),
            odeintr::state.begin());
}

// [[Rcpp::export]]
std::vector<double>
INTEGRATE_LNA_get_state()
{
  return odeintr::state;
}

// [[Rcpp::export]]
void INTEGRATE_LNA_reset_observer()
{
  for (auto &i : odeintr::rec_x) i.resize(0);
  odeintr::rec_t.resize(0);  
}

// [[Rcpp::export]]
Rcpp::List INTEGRATE_LNA_adap(Rcpp::NumericVector init,
                             double duration,
                             double step_size = 1.0,
                             double start = 0.0)
{
  INTEGRATE_LNA_set_state(init);
  INTEGRATE_LNA_reset_observer(); reserve(duration / step_size);
  odeint::integrate_adaptive(odeintr::stepper, odeintr::sys, odeintr::state,
                             start, start + duration, step_size,
                             odeintr::obs);
  return INTEGRATE_LNA_get_output();
}

// [[Rcpp::export]]
Rcpp::List INTEGRATE_LNA_at(Rcpp::NumericVector init,
                           std::vector<double> times,
                           double step_size = 1.0,
                           double start = 0.0)
{
  INTEGRATE_LNA_set_state(init);
  INTEGRATE_LNA_reset_observer(); reserve(times.size());
  odeint::integrate_const(odeintr::stepper, odeintr::sys, odeintr::state,
                          start, times[0], step_size);
  odeint::integrate_times(odeintr::stepper, odeintr::sys, odeintr::state,
                          times.begin(), times.end(), step_size, odeintr::obs);
  return INTEGRATE_LNA_get_output();
}

// [[Rcpp::export]]
Rcpp::List
INTEGRATE_LNA_continue_at(std::vector<double> times, double step_size = 1.0)
{
  double start = odeintr::rec_t.back();
  INTEGRATE_LNA_reset_observer(); reserve(odeintr::rec_t.size() + times.size());
  odeint::integrate_const(odeintr::stepper, odeintr::sys, odeintr::state,
                          start, times[0], step_size);
  odeint::integrate_times(odeintr::stepper, odeintr::sys, odeintr::state,
                          times.begin(), times.end(), step_size, odeintr::obs);
  return INTEGRATE_LNA_get_output();
}

// [[Rcpp::export]]
Rcpp::List INTEGRATE_LNA(Rcpp::NumericVector init,
                       double duration,
                       double step_size = 1.0,
                       double start = 0.0)
{
  INTEGRATE_LNA_set_state(init);
  INTEGRATE_LNA_reset_observer(); reserve(duration / step_size);
  odeint::integrate_const(odeintr::stepper, odeintr::sys, odeintr::state,
                          start, start + duration, step_size,
                          odeintr::obs);
  return INTEGRATE_LNA_get_output();
}

// [[Rcpp::export]]
std::vector<double>
INTEGRATE_LNA_no_record(Rcpp::NumericVector init,
                       double duration,
                       double step_size = 1.0,
                       double start = 0.0)
{
  INTEGRATE_LNA_set_state(init);
  odeint::integrate_adaptive(odeintr::stepper, odeintr::sys, odeintr::state,
                             start, start + duration, step_size);
  return INTEGRATE_LNA_get_state();
}

// [[Rcpp::export]]
void INTEGRATE_LNA_set_params(std::vector<double> p)
{
  if (p.size() != odeintr::pars.size())
    Rcpp::stop("Invalid parameter vector");
  std::copy(p.begin(), p.end(), odeintr::pars.begin());
}
// [[Rcpp::export]]
std::vector<double> INTEGRATE_LNA_get_params()
{
  return std::vector<double>(odeintr::pars.begin(), odeintr::pars.end());
}
;




void INTEGRATE_STEM_LNA(Rcpp::NumericVector& init, double start, double end, double step_size=0.001) {
INTEGRATE_LNA_set_state(init);
odeint::integrate_adaptive(odeintr::stepper, odeintr::sys, odeintr::state, start, end, step_size);
init = Rcpp::wrap(INTEGRATE_LNA_get_state());
}

typedef void(*lna_ptr)(Rcpp::NumericVector& init, double start, double end, double step_size);
// [[Rcpp::export]]
Rcpp::XPtr<lna_ptr> LNA_XPtr() {
return(Rcpp::XPtr<lna_ptr>(new lna_ptr(&INTEGRATE_STEM_LNA)));
}
 
void SET_LNA_PARAMS(Rcpp::NumericVector& p) {
std::copy(p.begin(), p.end(), odeintr::pars.begin());
}

typedef void(*set_pars_ptr)(Rcpp::NumericVector& p);
// [[Rcpp::export]]
Rcpp::XPtr<set_pars_ptr> LNA_set_params_XPtr() {
return(Rcpp::XPtr<set_pars_ptr>(new set_pars_ptr(&SET_LNA_PARAMS)));
}