# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Construct a matrix containing the compartment counts at a sequence of census times.
#'
#' @param path matrix containing the path to be censused.
#' @param census_times vector of census times.
#' @param census_columns vector of column indices to be censused (C++ indexing
#'   beginning at 0).
#'
#' @return matrix containing the compartment counts at census times.
#' @export
build_census_path <- function(path, census_times, census_columns) {
    .Call('_stemr_build_census_path', PACKAGE = 'stemr', path, census_times, census_columns)
}

#' Evaluate the log-density of the measurement process by calling measurement
#' process density functions via external Xptr.
#'
#' @param emitmat matrix of emission probabilities
#' @param emit_inds logical vector of measurement compartments to simulate
#' @param record_ind row in the observation and emission matrices
#' @param record vector of observed counts
#' @param state numeric vector of latent comaprtment counts
#' @param parameters numeric vector of parameter values
#' @param constants numeric vector of constants
#' @param tcovar numeric vector of time-varying covariate values
#' @param r_meas_ptr external pointer to measurement process simulation function
#'
#' @export
CALL_D_MEASURE <- function(emitmat, emit_inds, record_ind, record, state, parameters, constants, tcovar, d_meas_ptr) {
    invisible(.Call('_stemr_CALL_D_MEASURE', PACKAGE = 'stemr', emitmat, emit_inds, record_ind, record, state, parameters, constants, tcovar, d_meas_ptr))
}

#' Compute the hazards by calling the hazard functions via external Xptr.
#'
#' @param init initial condition
#' @param state time at left endpoint of interval
#' @param end time at right endpoint
#' @param step_size set automatically by caller, required argument not specified by user
#' @param lna_ode_ptr external pointer for calling the ODE integrator
#'
#' @export
CALL_INTEGRATE_STEM_LNA <- function(init, start, end, step_size, lna_ode_ptr) {
    invisible(.Call('_stemr_CALL_INTEGRATE_STEM_LNA', PACKAGE = 'stemr', init, start, end, step_size, lna_ode_ptr))
}

#' Update rates by calling rate functions via Xptr.
#'
#' @param rates vector of rates to be modified
#' @param inds logical vector of indices of rates to be modified
#' @param state numeric vector of comaprtment counts
#' @param parameters numeric vector of parameter values
#' @param constants numeric vector of constants
#' @param tcovar numeric vector of time-varying covariate values
#' @param rate_ptr external pointer to rate function
#'
#' @export
CALL_RATE_FCN <- function(rates, inds, state, parameters, constants, tcovar, rate_ptr) {
    invisible(.Call('_stemr_CALL_RATE_FCN', PACKAGE = 'stemr', rates, inds, state, parameters, constants, tcovar, rate_ptr))
}

#' Simulate from the measurement process by calling measurement process
#' functions via external Xptr.
#'
#' @param obsmat observation matrix
#' @param emit_inds logical vector of measurement compartments to simulate
#' @param record_ind row in the observation matrix
#' @param state numeric vector of comaprtment counts
#' @param parameters numeric vector of parameter values
#' @param constants numeric vector of constants
#' @param tcovar numeric vector of time-varying covariate values
#' @param r_meas_ptr external pointer to measurement process simulation function
#'
#' @export
CALL_R_MEASURE <- function(obsmat, emit_inds, record_ind, state, parameters, constants, tcovar, r_meas_ptr) {
    invisible(.Call('_stemr_CALL_R_MEASURE', PACKAGE = 'stemr', obsmat, emit_inds, record_ind, state, parameters, constants, tcovar, r_meas_ptr))
}

#' Compute the hazards by calling the hazard functions via external Xptr.
#'
#' @param t time
#' @param state vector of compartment counts
#' @param parameters vector of model parameters
#' @param constants vector of constants
#' @param vector of time-varying covariate values
#' @param hazard_ptr external pointer to function used to compute the hazards
#'
#' @export
CALL_SET_LNA_PARAMS <- function(p, set_lna_params_ptr) {
    invisible(.Call('_stemr_CALL_SET_LNA_PARAMS', PACKAGE = 'stemr', p, set_lna_params_ptr))
}

#' Construct a matrix containing the compartment counts and the incidence at a sequence of census times.
#'
#' @param path matrix containing the path to be censused (cumulative incidence).
#' @param census_path matrix to be filled out with the path.
#' @param flow_matrix_lna matrix containing the flow matrix for the LNA (no incidence)
#' @param do_prevalence should the prevalence be computed
#' @param init_state the initial compartment counts
#' @param incidence_codes_lna vector of column indices in the LNA path for which
#'   incidence will be computed. This function merely records the cumulative
#'   incidence at the census times from the LNA path.
#'
#' @return matrix containing the compartment counts at census times.
#' @export
census_lna <- function(path, census_path, census_inds, flow_matrix_lna, do_prevalence, init_state, incidence_codes_lna) {
    invisible(.Call('_stemr_census_lna', PACKAGE = 'stemr', path, census_path, census_inds, flow_matrix_lna, do_prevalence, init_state, incidence_codes_lna))
}

#' Difference an incidence variable in a census matrix.
#'
#' @param censusmat matrix of compartment counts at census times, to be updated
#' @param col_inds column indices for which incidence should be computed
#' @param row_inds list of vectors of row indices for each of the incidence variables
#'
#'
#' @return update the census matrix in place
#' @export
compute_incidence <- function(censusmat, col_inds, row_inds) {
    invisible(.Call('_stemr_compute_incidence', PACKAGE = 'stemr', censusmat, col_inds, row_inds))
}

#' Convert an LNA path from the counting process on transition events to the
#' compartment densities on their natural scale, making the conversion in place
#' for an existing census matrix.
#'
#' @param path matrix containing the LNA path in terms of the counting
#'   processes on transition events
#' @param flow_matrix stoichiometry matrix (the transpose of the flow matrix)
#' @param init_state initial compartment counts on the natural scale
#' @param statemat matrix where the compartment counts should be written
#'
#' The process can be re-expressed by left-multiplying each row in the path
#' matrix by the stoichiometry matrix: \eqn{X_t = A'\phi(t, N_t)}.
#'
#' @export
convert_lna2 <- function(path, flow_matrix, init_state, statemat) {
    invisible(.Call('_stemr_convert_lna2', PACKAGE = 'stemr', path, flow_matrix, init_state, statemat))
}

#' Identify which rates to update when a state transition event occurs.
#'
#' @param lnapars matrix of lna parameters, constants, and time-varying covars
#' @param parameters vector of parameters to be copied into the matrix
#'
#' @return modifies the lna parameter matrix in place
#' @export
pars2lnapars <- function(lnapars, parameters) {
    invisible(.Call('_stemr_pars2lnapars', PACKAGE = 'stemr', lnapars, parameters))
}

#' Copy an element from one vector into another
#'
#' @param dest destination row vector
#' @param orig origin row vector
#' @param ind C++ style index for the element to be copied
#'
#' @return copy an element of one row vector into another.
#' @export
copy_elem <- function(dest, orig, ind) {
    invisible(.Call('_stemr_copy_elem', PACKAGE = 'stemr', dest, orig, ind))
}

#' Copy the contents of one vector into another
#'
#' @param dest destination row vector
#' @param orig origin row vector
#'
#' @return copy the elements of one row vector into another.
#' @export
copy_vec <- function(dest, orig) {
    invisible(.Call('_stemr_copy_vec', PACKAGE = 'stemr', dest, orig))
}

#' Copy the contents of one matrix into another
#'
#' @param dest destination matrix
#' @param orig origin matrix
#'
#' @return copy the elements of one matrix into another.
#' @export
copy_mat <- function(dest, orig) {
    invisible(.Call('_stemr_copy_mat', PACKAGE = 'stemr', dest, orig))
}

#' Copy the contents of one matrix into another
#'
#' @param dest destination matrix
#' @param orig origin matrix
#' @param ind column index
#'
#' @return copy the elements of one matrix into another.
#' @export
copy_col <- function(dest, orig, ind) {
    invisible(.Call('_stemr_copy_col', PACKAGE = 'stemr', dest, orig, ind))
}

#' Copy some of the rows of one matrix into another
#'
#' @param dest destination matrix
#' @param orig origin matrix
#' @param inds column index
#'
#' @return copy the elements of one matrix into another.
#' @export
copy_2_rows <- function(dest, orig, inds) {
    invisible(.Call('_stemr_copy_2_rows', PACKAGE = 'stemr', dest, orig, inds))
}

#' Componentwise Metropolis random walk transition kernel with componentwise
#'   adaptive scaling
#'
#' @param params_prop vector in which the proposed parameters should be stored
#' @param params_cur vector containing the current parameter vector
#' @param ind C++ style index for the component index
#' @param kernel_cov vector of component proposal standard deviations
#' @param proposal_scaling vector of scaling factors
#' @param nugget vector of fixed variance nugget contributions
#'
#' @return propose new parameter values in place
#' @export
c_rw_adaptive <- function(params_prop, params_cur, ind, kernel_cov, proposal_scaling, nugget) {
    invisible(.Call('_stemr_c_rw_adaptive', PACKAGE = 'stemr', params_prop, params_cur, ind, kernel_cov, proposal_scaling, nugget))
}

#' Componentwise Metropolis random walk transition kernel
#'
#' @param params_prop vector in which the proposed parameters should be stored
#' @param params_cur vector containing the current parameter vector
#' @param ind C++ style index for the component index
#' @param kernel_cov vector of component proposal standard deviations
#'
#' @return propose new parameter values in place
#' @export
c_rw <- function(params_prop, params_cur, ind, kernel_cov) {
    invisible(.Call('_stemr_c_rw', PACKAGE = 'stemr', params_prop, params_cur, ind, kernel_cov))
}

#' Evaluate the log-density of the measurement process by calling measurement
#' process density functions via external Xptr.
#'
#' @param emitmat matrix of emission probabilities
#' @param obsmat matrix containing the data
#' @param statemat matrix containing the compartment counts at the observation
#'   times
#' @param measproc_indmat logical matrix indicating which compartments are
#'   observed at every observation time
#' @param parameters numeric vector of parameter values
#' @param constants numeric vector of constants
#' @param tcovar_censusmat numeric vector of time-varying covariate values
#' @param d_meas_ptr external pointer to measurement process density function
#'
#' @export
evaluate_d_measure <- function(emitmat, obsmat, statemat, measproc_indmat, parameters, constants, tcovar_censusmat, d_meas_ptr) {
    invisible(.Call('_stemr_evaluate_d_measure', PACKAGE = 'stemr', emitmat, obsmat, statemat, measproc_indmat, parameters, constants, tcovar_censusmat, d_meas_ptr))
}

#' Evaluate the log-density of a possibly time-verying measurement process
#' by calling measurement process density functions via external Xptr.
#'
#' @param emitmat matrix of emission probabilities
#' @param obsmat matrix containing the data
#' @param censusmat matrix containing the state of the latent process at
#'   observation times
#' @param measproc_indmat logical matrix indicating which compartments are
#'   observed at every observation time
#' @param lna_parameters matrix containing the LNA parameters, constants and
#'   time-varying coariates.
#' @param current_params container for storing the LNA parameters at each
#'   observation time.
#' @param lna_param_inds indices for the model parameters.
#' @param lna_const_inds indices for the constants.
#' @param lna_tcovar_inds indices for the time-varying covariates.
#' @param param_update_inds logical vector indicating when model parameters
#'   should be updated.
#' @param census_indices vector of indices when the LNA path has been censused.
#' @param d_meas_ptr external pointer to measurement process density function
#'
#' @export
evaluate_d_measure_LNA <- function(emitmat, obsmat, censusmat, measproc_indmat, lna_parameters, lna_param_inds, lna_const_inds, lna_tcovar_inds, param_update_inds, census_indices, d_meas_ptr) {
    invisible(.Call('_stemr_evaluate_d_measure_LNA', PACKAGE = 'stemr', emitmat, obsmat, censusmat, measproc_indmat, lna_parameters, lna_param_inds, lna_const_inds, lna_tcovar_inds, param_update_inds, census_indices, d_meas_ptr))
}

#' Simulate a stochastic epidemic model path via Gillespie's direct method and
#' returns a matrix containing a simulated path from a stochastic epidemic
#' model.
#'
#' @param flow Flow matrix
#' @param parameters Vector of parameters
#' @param constants vector of constants
#' @param tcovar matrix of time-varying covariates
#' @param init_states vector of initial compartment counts
#' @param rate_adjmat adjacency matrix for updating rates after each event
#' @param tcovar_adjmat adjacency matrix for updating rates after each time a
#'   covariate changes
#' @param tcovar_changemat indicator matrix identifying which covariates change
#'   at each time
#' @param init_dims initial estimate for dimensions of the bookkeeping matrix,
#'   calculated as sum_strata(stratum size x number states x 3), rounded to the
#'   next greatest power of 2.
#' @param rate_ptr external function pointer to the lumped rate functions.
#'
#' @return matrix with a simulated path from a stochastic epidemic model.
#' @export
simulate_gillespie <- function(flow, parameters, constants, tcovar, init_states, rate_adjmat, tcovar_adjmat, tcovar_changemat, init_dims, rate_ptr) {
    .Call('_stemr_simulate_gillespie', PACKAGE = 'stemr', flow, parameters, constants, tcovar, init_states, rate_adjmat, tcovar_adjmat, tcovar_changemat, init_dims, rate_ptr)
}

#' Given a vector of interval endpoints \code{breaks}, determine in which
#' intervals the elements of a vector \code{x} fall.
#'
#' @param x vector for whose elements the corresponding intervals are
#'   identified
#' @param breaks vector containing the elements
#' @param rightmost_closed logical; if true, the results for x[j]=breaks[N] is
#'   N-1.
#' @param all_inside logical; if true, 0 is mapped to 1, and N is mapped to N-1
#'
#' The rightmost interval is assumed to be closed. Compares to the behavior of
#' the \code{findInterval} function in \code{R}, when \code{rightmost.closed =
#'  TRUE}
#'
#' @return matrix containing the compartment counts at census times.
#' @export
find_interval <- function(x, breaks, rightmost_closed, all_inside) {
    .Call('_stemr_find_interval', PACKAGE = 'stemr', x, breaks, rightmost_closed, all_inside)
}

#' Get componentwise proposals from a global proposal.
#'
#' @param g2c_mat matrix in which to keep the componentwise proposals
#' @param params_cur vector containing the current parameter vector
#' @param params_prop vector in which the proposed parameters
#'
#' @return fill g2c_mat with componentwise proposals
#' @export
g_prop2c_prop <- function(g2c_mat, params_cur, params_prop) {
    invisible(.Call('_stemr_g_prop2c_prop', PACKAGE = 'stemr', g2c_mat, params_cur, params_prop))
}

#' Compute the density of an LNA path, reintegrating only the drift and
#' residual ODEs (sufficient after elliptical slice sampling).
#'
#' @param path list containing the lna_path, and the drift, residual, and
#'   diffusion processes.
#' @param lna_times vector of times at which the LNA must be evaluated
#' @param lna_pars numeric matrix of parameters, constants, and time-varying
#'   covariates at each of the lna_times
#' @param param_update_inds logical vector indicating at which of the times the
#'   LNA parameters need to be updated.
#' @param flow_matrix original flow matrix giving the changes to compartments
#'   from each reaction
#' @param lna_pointer external pointer to LNA integration fcn
#' @param set_pars_pointer external pointer to the function for setting the LNA
#'   parameters.
#'
#' @return List containing the LNA path, the path of the residual
#'   process, the drift process, the residual process (conditional means), and
#'   diffusion process, along with the log density of the LNA path and the
#'   measurement process.
#' @export
lna_density2 <- function(path, lna_times, lna_pars, param_update_inds, flow_matrix, lna_pointer_ess, lna_ess_set_pars_ptr) {
    .Call('_stemr_lna_density2', PACKAGE = 'stemr', path, lna_times, lna_pars, param_update_inds, flow_matrix, lna_pointer_ess, lna_ess_set_pars_ptr)
}

#' Compute the density of an LNA path, reintegrating all LNA ODEs (as required,
#' e.g. after updating the parameters).
#'
#' @param path list containing the lna_path, and the drift, residual, and
#'   diffusion processes.
#' @param lna_times vector of times at which the LNA must be evaluated
#' @param lna_pars numeric matrix of parameters, constants, and time-varying
#'   covariates at each of the lna_times
#' @param param_update_inds logical vector indicating at which of the times the
#'   LNA parameters need to be updated.
#' @param flow_matrix original flow matrix giving the changes to compartments
#'   from each reaction
#' @param lna_pointer external pointer to LNA integration fcn
#' @param set_pars_pointer external pointer to the function for setting the LNA
#'   parameters.
#'
#' @return List containing the LNA path, the path of the residual
#'   process, the drift process, the residual process (conditional means), and
#'   diffusion process, along with the log density of the LNA path and the
#'   measurement process.
#' @export
lna_density <- function(path, lna_times, lna_pars, param_update_inds, flow_matrix, lna_pointer, set_pars_pointer) {
    .Call('_stemr_lna_density', PACKAGE = 'stemr', path, lna_times, lna_pars, param_update_inds, flow_matrix, lna_pointer, set_pars_pointer)
}

#' Convert an LNA path from the counting process on transition events to the
#' compartment densities on their natural scale.
#'
#' @param path matrix containing the LNA path in terms of the counting
#'   processes on transition events (incidence)
#' @param flow_matrix stoichiometry matrix (the transpose of the flow matrix)
#' @param init_state initial compartment counts on the natural scale
#' @param t0 initial time
#'
#' The process can be re-expressed by left-multiplying each row in the path
#' matrix by the stoichiometry matrix: \eqn{X_t = X_0 + A'N_t}.
#'
#' @export
lna_incid2prev <- function(path, flow_matrix, init_state) {
    .Call('_stemr_lna_incid2prev', PACKAGE = 'stemr', path, flow_matrix, init_state)
}

#' Map N(0,1) stochastic perturbations to an LNA path.
#'
#' @param pathmat matrix where the LNA path should be stored
#' @param draws matrix of N(0,1) draws to be mapped to an LNA path
#' @param lna_times vector of interval endpoint times
#' @param lna_pars numeric matrix of parameters, constants, and time-varying
#'   covariates at each of the lna_times
#' @param init_start index in the parameter vector where the initial compartment
#'   volumes start
#' @param param_update_inds logical vector indicating at which of the times the
#'   LNA parameters need to be updated.
#' @param stoich_matrix stoichiometry matrix giving the changes to compartments
#'   from each reaction
#' @param lna_pointer external pointer to LNA integration function.
#' @param set_pars_pointer external pointer to the function for setting the LNA
#'   parameters.
#'
#' @return fill out pathmat with the LNA path corresponding to the stochastic
#'   perturbations.
#'
#' @export
map_draws_2_lna <- function(pathmat, draws, lna_times, lna_pars, init_start, param_update_inds, stoich_matrix, lna_pointer, set_pars_pointer) {
    invisible(.Call('_stemr_map_draws_2_lna', PACKAGE = 'stemr', pathmat, draws, lna_times, lna_pars, init_start, param_update_inds, stoich_matrix, lna_pointer, set_pars_pointer))
}

#' Produce samples from a multivariate normal density using the Cholesky
#' decomposition
#'
#' @param n number of samples
#' @param mu mean vector
#' @param sigma covariance matrix
#'
#' (source: http://gallery.rcpp.org/articles/simulate-multivariate-normal/)
#'
#' @export
rmvtn <- function(n, mu, sigma) {
    .Call('_stemr_rmvtn', PACKAGE = 'stemr', n, mu, sigma)
}

#' Multivariate normal density
#'
#' @param x matrix of draws for which to evaluate the density
#' @param mu mean vector of the distribution
#' @param sigma covariance matrix
#' @param logd should the log be returned
#'
#' (source: http://gallery.rcpp.org/articles/dmvnorm_arma/)
#'
#' @export
dmvtn <- function(x, mu, sigma, logd = FALSE) {
    .Call('_stemr_dmvtn', PACKAGE = 'stemr', x, mu, sigma, logd)
}

#' Global Metropolis random walk with global adaptive scaling
#'
#' @param params_prop vector in which the proposed parameters should be stored
#' @param params_cur vector containing the current parameter vector
#' @param kernel_cov vector of component proposal standard deviations
#' @param proposal_scaling scaling parameter for the proposal
#' @param nugget fixed covariance nugget contribution
#'
#' @return propose new parameter values in place
#' @export
mvn_c_adaptive <- function(params_prop, params_cur, kernel_cov, proposal_scaling, sqrt_scalemat, nugget) {
    invisible(.Call('_stemr_mvn_c_adaptive', PACKAGE = 'stemr', params_prop, params_cur, kernel_cov, proposal_scaling, sqrt_scalemat, nugget))
}

#' Global Metropolis random walk with global adaptive scaling
#'
#' @param params_prop vector in which the proposed parameters should be stored
#' @param params_cur vector containing the current parameter vector
#' @param kernel_cov vector of component proposal standard deviations
#' @param proposal_scaling scaling parameter for the proposal
#' @param nugget fixed covariance nugget contribution
#'
#' @return propose new parameter values in place
#' @export
mvn_g_adaptive <- function(params_prop, params_cur, kernel_cov, proposal_scaling, nugget) {
    invisible(.Call('_stemr_mvn_g_adaptive', PACKAGE = 'stemr', params_prop, params_cur, kernel_cov, proposal_scaling, nugget))
}

#' Random walk Metropolis-Hastings transition kernel.
#'
#' @param params_prop vector in which the proposed parameters should be stored
#' @param params_cur vector containing the current parameter vector
#' @param sigma_chol upper triangular portion of the Cholesky decomposition of
#'   the proposal covariance matrix
#'
#' @return propose new parameter values in place
#' @export
mvn_rw <- function(params_prop, params_cur, sigma_chol) {
    invisible(.Call('_stemr_mvn_rw', PACKAGE = 'stemr', params_prop, params_cur, sigma_chol))
}

#' Simulate an LNA path using a non-centered parameterization for the
#' log-transformed counting process LNA.
#'
#' @param lna_times vector of interval endpoint times
#' @param lna_pars numeric matrix of parameters, constants, and time-varying
#'   covariates at each of the lna_times
#' @param init_start index in the parameter vector where the initial compartment
#'   volumes start
#' @param param_update_inds logical vector indicating at which of the times the
#'   LNA parameters need to be updated.
#' @param stoich_matrix stoichiometry matrix giving the changes to compartments
#'   from each reaction
#' @param lna_pointer external pointer to LNA integration function.
#' @param set_pars_pointer external pointer to the function for setting the LNA
#'   parameters.
#'
#' @return list containing the stochastic perturbations (i.i.d. N(0,1) draws) and
#' the LNA path on its natural scale which is determined by the perturbations.
#'
#' @export
propose_lna <- function(lna_times, lna_pars, init_start, param_update_inds, stoich_matrix, lna_pointer, set_pars_pointer) {
    .Call('_stemr_propose_lna', PACKAGE = 'stemr', lna_times, lna_pars, init_start, param_update_inds, stoich_matrix, lna_pointer, set_pars_pointer)
}

#' Identify which rates to update when a state transition event occurs.
#'
#' @param rate_inds vector of rate indices to be modified
#' @param M adjacency matrix for which rates need to be updated in response to a transition
#' @param event_code column in the rate adjacency matrix
#'
#' @return modifies logical vector stating which rates need to be updated
#' @export
rate_update_event <- function(rate_inds, M, event_code) {
    invisible(.Call('_stemr_rate_update_event', PACKAGE = 'stemr', rate_inds, M, event_code))
}

#' Identify which rates to update based on changes in the time-varying covariates.
#'
#' @param rate_inds vector of rate indices to be modified
#' @param M time-varying covariate adjacency matrix
#' @param I logical vector indicating which covariates changed at a particular time.
#'
#' @return logical vector stating which rates need to be updated
#' @export
rate_update_tcovar <- function(rate_inds, M, I) {
    invisible(.Call('_stemr_rate_update_tcovar', PACKAGE = 'stemr', rate_inds, M, I))
}

#' Insert the compartment counts at a sequence of census times into an existing census matrix.
#'
#' @param censusmat matrix of compartment counts at census times, to be updated
#' @param path matrix containing the path to be censused.
#' @param census_times vector of census times.
#' @param census_columns vector of column indices to be censused (C++ indexing
#'   beginning at 0).
#'
#' @return matrix containing the compartment counts at census times.
#' @export
retrieve_census_path <- function(censusmat, path, census_times, census_columns) {
    invisible(.Call('_stemr_retrieve_census_path', PACKAGE = 'stemr', censusmat, path, census_times, census_columns))
}

#' Simulate a data matrix from the measurement process of a stochastic epidemic
#' model.
#'
#' @param censusmat matrix of compartment counts at observation times
#' @param measproc_indmat logical matrix for which measure variables are
#'        observed at which times
#' @param parameters numeric vector of model parameters
#' @param constants numeric vector of constants
#' @param tcovar numeric matrix of time-varying covariate values at observation
#'        times.
#' @param r_measure_ptr external pointer to measurement process simulation fcn
#'
#' @return matrix with a simulated dataset from a stochastic epidemic model.
#' @export
simulate_r_measure <- function(censusmat, measproc_indmat, parameters, constants, tcovar, r_measure_ptr) {
    .Call('_stemr_simulate_r_measure', PACKAGE = 'stemr', censusmat, measproc_indmat, parameters, constants, tcovar, r_measure_ptr)
}

