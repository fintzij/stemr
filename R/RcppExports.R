# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Construct a matrix containing the compartment counts at a sequence of census times.
#'
#' @param path matrix containing the path to be censused.
#' @param census_times vector of census times.
#' @param census_columns vector of column indices to be censused (C++ indexing
#'   beginning at 0).
#'
#' @return matrix containing the compartment counts at census times.
#' @export
build_census_path <- function(path, census_times, census_columns) {
    .Call('stemr_build_census_path', PACKAGE = 'stemr', path, census_times, census_columns)
}

#' Evaluate the log-density of the measurement process by calling measurement
#' process density functions via external Xptr.
#'
#' @param emitmat matrix of emission probabilities
#' @param emit_inds logical vector of measurement compartments to simulate
#' @param record_ind row in the observation and emission matrices
#' @param record vector of observed counts
#' @param state numeric vector of latent comaprtment counts
#' @param parameters numeric vector of parameter values
#' @param constants numeric vector of constants
#' @param tcovar numeric vector of time-varying covariate values
#' @param r_meas_ptr external pointer to measurement process simulation function
#'
#' @export
CALL_D_MEASURE <- function(emitmat, emit_inds, record_ind, record, state, parameters, constants, tcovar, d_meas_ptr) {
    invisible(.Call('stemr_CALL_D_MEASURE', PACKAGE = 'stemr', emitmat, emit_inds, record_ind, record, state, parameters, constants, tcovar, d_meas_ptr))
}

#' Simulate from the measurement process by calling measurement process
#' functions via external Xptr.
#'
#' @param obsmat observation matrix
#' @param emit_inds logical vector of measurement compartments to simulate
#' @param record_ind row in the observation matrix
#' @param state numeric vector of comaprtment counts
#' @param parameters numeric vector of parameter values
#' @param constants numeric vector of constants
#' @param tcovar numeric vector of time-varying covariate values
#' @param r_meas_ptr external pointer to measurement process simulation function
#'
#' @export
CALL_R_MEASURE <- function(obsmat, emit_inds, record_ind, state, parameters, constants, tcovar, r_meas_ptr) {
    invisible(.Call('stemr_CALL_R_MEASURE', PACKAGE = 'stemr', obsmat, emit_inds, record_ind, state, parameters, constants, tcovar, r_meas_ptr))
}

#' Update rates by calling rate functions via Xptr.
#'
#' @param rates vector of rates to be modified
#' @param inds logical vector of indices of rates to be modified
#' @param state numeric vector of comaprtment counts
#' @param parameters numeric vector of parameter values
#' @param constants numeric vector of constants
#' @param tcovar numeric vector of time-varying covariate values
#' @param rate_ptr external pointer to rate function
#'
#' @export
CALL_RATE_FCN <- function(rates, inds, state, parameters, constants, tcovar, rate_ptr) {
    invisible(.Call('stemr_CALL_RATE_FCN', PACKAGE = 'stemr', rates, inds, state, parameters, constants, tcovar, rate_ptr))
}

#' Difference an incidence variable in a census matrix.
#'
#' @param censusmat matrix of compartment counts at census times, to be updated
#' @param col_inds column indices for which incidence should be computed
#' @param row_inds list of vectors of row indices for each of the incidence variables
#'
#'
#' @return update the census matrix in place
#' @export
compute_incidence <- function(censusmat, col_inds, row_inds) {
    invisible(.Call('stemr_compute_incidence', PACKAGE = 'stemr', censusmat, col_inds, row_inds))
}

#' Given a vector of interval endpoints \code{breaks}, determine in which
#' intervals the elements of a vector \code{x} fall.
#'
#' @param x vector for whose elements the corresponding intervals are
#'   identified
#' @param breaks vector containing the elements
#' @param rightmost_closed logical; if true, the results for x[j]=breaks[N] is
#'   N-1.
#' @param all_inside logical; if true, 0 is mapped to 1, and N is mapped to N-1
#'
#' The rightmost interval is assumed to be closed. Compares to the behavior of
#' the \code{findInterval} function in \code{R}, when \code{rightmost.closed =
#'  TRUE}
#'
#' @return matrix containing the compartment counts at census times.
#' @export
find_interval <- function(x, breaks, rightmost_closed, all_inside) {
    .Call('stemr_find_interval', PACKAGE = 'stemr', x, breaks, rightmost_closed, all_inside)
}

#' Identify which rates to update when a state transition event occurs.
#'
#' @param rate_inds vector of rate indices to be modified
#' @param M adjacency matrix for which rates need to be updated in response to a transition
#' @param event_code column in the rate adjacency matrix
#'
#' @return modifies logical vector stating which rates need to be updated
#' @export
rate_update_event <- function(rate_inds, M, event_code) {
    invisible(.Call('stemr_rate_update_event', PACKAGE = 'stemr', rate_inds, M, event_code))
}

#' Identify which rates to update based on changes in the time-varying covariates.
#'
#' @param rate_inds vector of rate indices to be modified
#' @param M time-varying covariate adjacency matrix
#' @param I logical vector indicating which covariates changed at a particular time.
#'
#' @return logical vector stating which rates need to be updated
#' @export
rate_update_tcovar <- function(rate_inds, M, I) {
    invisible(.Call('stemr_rate_update_tcovar', PACKAGE = 'stemr', rate_inds, M, I))
}

#' Insert the compartment counts at a sequence of census times into an existing census matrix.
#'
#' @param censusmat matrix of compartment counts at census times, to be updated
#' @param path matrix containing the path to be censused.
#' @param census_times vector of census times.
#' @param census_columns vector of column indices to be censused (C++ indexing
#'   beginning at 0).
#'
#' @return matrix containing the compartment counts at census times.
#' @export
retrieve_census_path <- function(censusmat, path, census_times, census_columns) {
    invisible(.Call('stemr_retrieve_census_path', PACKAGE = 'stemr', censusmat, path, census_times, census_columns))
}

#' Simulate a stochastic epidemic model path via Gillespie's direct method and
#' returns a matrix containing a simulated path from a stochastic epidemic
#' model.
#'
#' @param flow Flow matrix
#' @param parameters Vector of parameters
#' @param constants vector of constants
#' @param tcovar matrix of time-varying covariates
#' @param init_states vector of initial compartment counts
#' @param rate_adjmat adjacency matrix for updating rates after each event
#' @param tcovar_adjmat adjacency matrix for updating rates after each time a
#'   covariate changes
#' @param tcovar_changemat indicator matrix identifying which covariates change
#'   at each time
#' @param init_dims initial estimate for dimensions of the bookkeeping matrix,
#'   calculated as sum_strata(stratum size x number states x 3), rounded to the
#'   next greatest power of 2.
#' @param rate_ptr external function pointer to the lumped rate functions.
#'
#' @return matrix with a simulated path from a stochastic epidemic model.
#' @export
simulate_gillespie <- function(flow, parameters, constants, tcovar, init_states, rate_adjmat, tcovar_adjmat, tcovar_changemat, init_dims, rate_ptr) {
    .Call('stemr_simulate_gillespie', PACKAGE = 'stemr', flow, parameters, constants, tcovar, init_states, rate_adjmat, tcovar_adjmat, tcovar_changemat, init_dims, rate_ptr)
}

