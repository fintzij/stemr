#' Generate the objects governing the dynamics of a stochastic epidemic model.
#'
#' @param rates list of rate lists, each generated by a call to the
#'   \code{\link{rate}} function.
#' @param parameters numeric vector with named elements, the model parameters.
#'   Note that this includes ALL model parameters, including those refered to in
#'   the measurement process. Note too that the initial time, \code{t0}, must
#'   either be specified as either a parameter or a constant in the model.
#' @param state_initializer list of initializer lists, each generated by a call
#'   to \code{\link{stem_initializer}}. Used to initialize the system at the
#'   first observation time.
#' @param compartments character vector of compartment names if there is a
#'   single stratum, or if there are multiple strata a list of character vectors
#'   where the name of each character vector is the compartment name and the
#'   character vector lists the strata to in which the compartment exists. The
#'   reserved word "ALL" can be used instead of listing all strata.
#' @param tcovar Matrix or data frame of time varying covariates, the first
#'   column of which contains the times at which covariates change.
#' @param strata vector of stratum names, required if the "ALL" reserved word is
#'   used
#'
#'   (e.g. compartments = list(S = "ALL", I = "ALL", R = "ALL", D = "old");
#'   strata = c("infants", "young", "old");
#' @inheritParams simulate_stem
#' @param constants optional. numeric vector with named elements that are
#'   constants referenced in the rate functions.
#' @param adjacency optional matrix specifying the adjacency structure of
#'   strata, with 0 entries indicating non-adjacency and 1 for adjacency. Rows
#'   and columns must be labeled.
#'
#'   Important note: care should be taken to make sure that there are no partial
#'   string matches between the building blocks of a model. For example, if the
#'   population size is given by the string constant "N", then "N" should not
#'   appear in any of parameter names, compartment names, etc. In particular,
#'   suppose there is a parameter named "BETA_N". When the rate functions are
#'   parsed internally, the rate strings will be parsed incorrectly due to the
#'   partial match.
#' @param compile_rates should the rate functions be compiled? Defaults to TRUE.
#' @param stan_lna_code should the user defined functions for fitting the
#'   restarting log-transformed LNA in Stan be generated?
#'
#' @return list with evaluated rate functions and objects for managing the
#'   bookkeeping for epidemic paths. The objects in the list are as follows:
#'
#'   \describe{ \item{rates}{list of parsed rate functions}
#'   \item{rate_ptrs}{vector of external function pointers to compiled rate
#'   functions.} \item{parameters}{named numeric vector of model parameters}
#'   \item{tcovar}{matrix of time-varying covariates, with column names}
#'   \item{constants}{named numeric vector of constants, with stratum sizes and
#'   population size included} \item{state_initializer}{list of model
#'   initializer lists} \item{initdist_params}{named numeric vector of
#'   parameters governing the initial distribution of compartment counts}
#'   \item{fixed_inits}{logical indicating whether the initial distribution
#'   parameters are fixed compartment counts (TRUE) or parameters of a dirichlet
#'   distribution (FALSE)} \item{flow_matrix}{matrix of flow between model
#'   compartments associated with each transition event} \item{lna_rates}{list
#'   with lna pointers and lna code} \item{strata_sizes}{named numeric vector of
#'   strata sizes} \item{popsize}{population size} \item{comp_codes}{named
#'   vector of (C++) compartment codes} \item{param_codes}{named vector of (C++)
#'   parameter codes} \item{tcovar_codes}{named vector of (C++) time-varying
#'   covariate codes} \item{const_codes}{named vector of (C++) constant codes}
#'   \item{strata_codes}{named vector of (C++) strata codes}
#'   \item{incidence_codes}{named vector of (C++) incidence compartment codes
#'   (colum location in the path matrix)} \item{incidence_sources}{named vector
#'   of (C++) codes for compartments corresponding to each incidence
#'   compartment} \item{lna_param_codes}{named vector of (C++) codes for the
#'   concatenated LNA parameters} \item{progressive}{logical indicating whether
#'   the model is progressive} \item{absorbing_states}{logical vector indicating
#'   which model compartments are absorbing states} \item{rate_adjmat}{adjacency
#'   matrix indicating which rates need to be updated when a transition event
#'   occurs} \item{timevarying}{logical indicating whether there are any
#'   smoothly time-varying covariates in the model (either time, or
#'   seasonality)} \item{timecode}{index of column in the time-varying covariate
#'   matrix for time (as a variable, not an index)}
#'   \item{tcovar_adjmat}{adjacency matrix indicating which rates need to be
#'   updated when a time-varying covariate value changes}
#'   \item{tcovar_changemat}{indicator matrix indicating which time-varying
#'   covariates change at which time in the tcovar matrix}
#'   \item{t0}{initialization time for the system} \item{tmax}{time until which
#'   the system evolves} \item{n_strata}{number of strata}
#'   \item{n_compartments}{number of compartments} \item{n_params}{number of
#'   model parameters} \item{n_tcovar}{number of time-varying covariates,
#'   including time} \item{n_consts}{number of constants in the model}
#'   \item{.dynamics_args}{original arguments supplied to \code{stem_dynamics}}
#'   }
#'
#' @export
stem_dynamics <- function(rates, parameters, state_initializer, compartments, tmax, tcovar = NULL, timestep = NULL, strata = NULL, constants = NULL, adjacency = NULL, messages = TRUE, compile_rates = TRUE, compile_ode = FALSE, ...) {

        # check consistency of specification and throw errors if inconsistent
        if(is.list(compartments) && ("ALL" %in% compartments) && is.null(strata)) {
                stop("In order to use 'ALL' to specify that some compartments are present for all strata, a character vector of stratum names must be supplied")
        }

        # check for partial matches in parameter names
        param_match <- rep(FALSE, length(parameters)); param_names <- names(parameters)
        for(p in seq_along(parameters)) {
                param_match[p] <- any(grepl(param_names[p], param_names[-p]))
        }
        if(any(param_match)) {
                stop(paste("Parameter(s)", paste(which(param_match), collapse = ", "), "have a partial name match with another parameter. Give unique names to resolve ambiguities."))
        }

        # check that none of the strata are named "TIME", "ALL", "ADJ", or "SELF", and
        # that these strings do not appear in subscripts
        if(any(c("TIME", "ALL", "ADJ", "SELF") %in% strata)){
                stop("'TIME', 'ALL', 'ADJ', and 'SELF' are reserved words and cannot be used in stratum names")
        }

        # check that "TIME" is not listed as one of the parameters
        if("TIME" %in% names(parameters)) {
                stop("'TIME' is a reserved word and should not be one of the parameter names.")
        }

        # check that "TIME" is not listed as one of the constants
        if("TIME" %in% names(constants)) {
                stop("'TIME' is a reserved word and should not be one of the names of constants.")
        }

        if(!is.null(strata) && (any(sapply(state_initializer, "[[", 2) == TRUE) & any(sapply(state_initializer, "[[", 2) == FALSE))) {
                stop("The initial states in each stratum must either all be fixed, or all be random.")
        }

        # check that the strata names in the compartment list match the strata
        if(is.list(compartments) && !all(unlist(compartments[unlist(compartments)]) %in% strata)) {
                stop(sQuote(unlist(compartments)[which((!unlist(compartments) %in% strata) & (unlist(compartments) != "ALL"))]), "is not in the supplied vector of stratum names")
        }

        # check that the strata argument is specified for all rates if there are
        # multiple strata the rate list is invalid if it is of length three so
        # that strata are not supplied, or if seasonal terms are added, but are supplied in the fourth list element
        if(!is.null(strata)) {
                for(k in 1:length(rates)) {
                        if(is.null(rates[[k]]$strata)) {
                                stop("If strata are specified in the model, they must also be specified in all rate functions.")
                        }
                }
        }

        args = list(...)
        if(!"stan_lna_code" %in% names(args) || args$stan_lna_code == F) {
                stan_lna_code = F
        } else {
                if("t0" %in% names(parameters)) {
                        stop("Stan cannot handle t0 as a parameter. Please specify t0 as a constant.")
                }
                stan_lna_code = T
        }

        # create a hidden list of user supplied arguments prior to processing
        .dynamics_args <- list(rates             = rates,
                               parameters        = parameters,
                               state_initializer = state_initializer,
                               compartments      = compartments,
                               tcovar            = tcovar,
                               timestep          = timestep,
                               strata            = strata,
                               constants         = constants,
                               adjacency         = adjacency,
                               messages          = messages,
                               compile_rates     = compile_rates,
                               stan_lna_code     = stan_lna_code,
                               compile_ode       = compile_ode)

        if(!"t0" %in% c(names(parameters), names(constants))) {
                stop("t0 must be specified either as a parameter or a constant in the stochastic epidemic model.")
        }

        # identify whether t0 is fixed or random, and isolate it
        if("t0" %in% names(parameters)) {
                t0_fixed   <- FALSE
                t0         <- parameters["t0"]

        } else {
                t0_fixed  <- TRUE
                t0        <- constants["t0"]
        }

        # build the vector of full compartment names
        if(!is.list(compartments)) {
                compartment_names <- compartments

        } else if(is.list(compartments)){

                comp_names <- names(compartments) # just the names of compartments without strata
                compartment_names <- vector("list", length(compartments)) # list with full compartment_strata names

                for(k in seq_along(compartment_names)) {
                        if(!identical(compartments[[k]], "ALL")) {
                                compartment_names[[k]] <- do.call(paste, list(comp_names[k], compartments[[k]], sep = "_"))
                        } else {
                                compartment_names[[k]] <- do.call(paste, list(comp_names[k], strata, sep = "_"))
                        }
                }
                compartment_names <- unlist(compartment_names)
        }


        if(messages) {
                if(any(sapply(c(compartment_names, names(parameters), colnames(tcovar), names(constants)), function(x) nchar(x) < 4))) {
                        warning("It is highly suggested that all compartments, parameters, time-varying covariates, and constants have names that are at least four characters long to avoid errors when parsing the rate functions!")
                }
        }

        # check that there are no partial matches among compartment names
        comp_match <- rep(FALSE, length(compartments))
        for(p in seq_along(compartments)) {
                comp_match[p] <- any(grepl(compartment_names[p], compartment_names[-p]))
        }
        if(any(comp_match)) {
                stop(paste("Compartment(s)", paste(which(comp_match), collapse = ", "), "have a partial name match with another compartment. Give unique names to resolve ambiguities."))
        }

        # get the number of strata, the number of compartments, number of parameters, and number of time-varying covariates (plus time)
        n_strata        <- max(1,length(strata));
        n_compartments  <- length(compartment_names)
        n_params        <- length(parameters)
        n_consts        <- length(constants)

        # ensure that time and time-varying covariates will be properly accounted for
        timevarying <- any(sapply(rates, function(x) grepl("TIME", x[["rate"]]))) ||
                           any(sapply(rates, function(x)! is.null(x[["seasonality"]])))

        if(!timevarying) {
                tcovar_names <- tcovar_codes <- NULL
                n_tcovar     <- 0
        } else {
                if(is.null(tcovar)) {
                        tcovar_names <- "TIME"
                        n_tcovar <- 1
                        tcovar_codes <- 1; names(tcovar_codes) <- "TIME"
                } else {
                        tcovar_names    <- c(colnames(tcovar)[2:ncol(tcovar)], "TIME")
                        n_tcovar        <- length(tcovar_names)
                        tcovar_codes    <- seq_len(n_tcovar); names(tcovar_codes) <- tcovar_names # the first column will be the times, so codes start at 1
                }
        }

        # compute the time discretization interval if it is not supplied and there are smooth time-varying covariates
        if(is.null(timestep) && timevarying) {
                timestep <- (tmax - t0)/50

        } else if(is.null(timestep) && !timevarying){
                timestep <- tmax - t0
        }

        # ensure that there are no partial matches amongst names of time-varying covariates
        if(timevarying) {
                tcovar_match <- rep(FALSE, length(tcovar_names))
                for(p in seq_along(tcovar_match)) {
                        tcovar_match[p] <- any(grepl(tcovar_names[p], tcovar_names[-p]))
                }
                if(any(tcovar_match)) {
                        stop(paste("Time-varying covariate(s)", paste(which(param_match), collapse = ", "), "have a partial name match with another time-varying covariate. Give unique names to resolve ambiguities."))
                }
        }

        # construct the mapping for the compartment_strata to the columns in the bookkeeping matrix
        compartment_codes <- 0:(n_compartments - 1);    names(compartment_codes)<- compartment_names

        param_codes <- 0:(n_params - 1)
        param_names <- names(parameters)
        names(param_codes) <- param_names

        if(n_strata) {
                strata_codes            <- 0:(n_strata - 1)
                names(strata_codes)     <- strata
        } else {
                strata_codes <- NULL
        }

        # check if it is necessary to add pi as a constant
        addpi <- rep(FALSE, length(rates))
        for(p in seq_along(addpi)) {
                addpi[p] <- !is.null(rates[[p]]$seasonality)
        }
        if(any(addpi)) {
                constants <- c(constants, pi)
                names(constants) <- c(names(constants), "M_PI")
                n_consts <- length(constants)
        }

        if(n_consts) {
                const_codes             <- 0:(n_consts - 1)
                const_names             <- names(constants)
                names(const_codes)      <- const_names
        } else {
                const_codes <- NULL
                const_names <- NULL
        }

        if(!is.null(constants)) {
                # ensure that there are no partial matches amongst names of constants
                const_match <- rep(FALSE, length(const_names))
                for(p in seq_along(const_match)) {
                        const_match[p] <- any(grepl(const_names[p], const_names[-p]))
                }
                if(any(const_match)) {
                        stop(paste("Constant(s)", paste(which(param_match), collapse = ", "), "have a partial name match with another constant or a generated constant corresponding to the population size or one of the stratum sizes. Give unique names to resolve ambiguities."))
                }
        }

        # if there are multiple strata, ensure that the rate functions are
        # specified for all compartments in their respective risk sets
        if(!is.null(strata)) {

                rate_fcns <- vector(mode = "list", length = length(rates))
                comp_all  <- paste(comp_names, "ALL", sep = "_")
                comp_adj  <- paste(comp_names, "ADJ", sep = "_")

                for(k in seq_along(rates)) {

                        # get the relevant strata
                        if(identical(rates[[k]]$strata, "ALL")) {
                                rel_strata <- strata
                        } else {
                                rel_strata <-rates[[k]]$strata
                        }

                        # ensure that there is one rate function per stratum
                        rate_fcns[[k]] <- vector(mode = "list", length = length(rel_strata))

                        # if there are rates with common_seasonal terms, add the parameters onto the parameter vector
                        if(!is.null(rates[[k]]$seasonality) && rates[[k]]$seasonality$common_seasonality) {

                                s_param_names <- names(rates[[k]]$seasonality$s_params)

                                # substitute the from and to arguments into the parameter names
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        rates[[k]]$seasonality$seasonality <- gsub(s_param_names[s],
                                                                                   paste0(s_param_names[s], "_",
                                                                                          rates[[k]]$from,
                                                                                          rates[[k]]$to),
                                                                                   rates[[k]]$seasonality$seasonality)
                                }

                                names(rates[[k]]$seasonality$s_params) <- paste0(s_param_names, "_", rates[[k]]$from, rates[[k]]$to)
                                parameters <- c(parameters, rates[[k]]$seasonality$s_params)
                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- param_names <- names(parameters)

                        }

                        # modify the rate function to reflect the stratum
                        for(j in seq_along(rel_strata)) {

                                strat_self <- rel_strata[j] # get stratum name

                                rate_fcns[[k]][[j]] <- vector(mode = "list", length = 6)
                                names(rate_fcns[[k]][[j]]) <- c("unlumped", "lumped", "from", "to", "incidence", "unparsed")
                                rate_fcns[[k]][[j]][c(1,3,4,5)] <- rates[[k]][c("rate", "from", "to", "incidence")] # copy rate function. slot 2 is lumped rate.


                                # if seasonal terms were supplied, instatiate
                                # them. If they are not common to all strata,
                                # add them to the parameter vector.
                                if(!is.null(rates[[k]]$seasonality)) {

                                        if(rates[[k]]$seasonality$common_seasonality) {
                                                rate_fcns[[k]][[j]]$unlumped <- paste(rate_fcns[[k]][[j]]$unlumped,
                                                                                      rates[[k]]$seasonality$seasonality, sep = " + ")

                                        } else {
                                                # make substitution in parameter names and add to parameter vector
                                                s_params_kj <- rates[[k]]$seasonality$s_params # get the seasonality parameters
                                                s_param_names_kj <- names(rates[[k]]$seasonality$s_params) # get the seasonality parameter names
                                                s_fcn_kj <- rates[[k]]$seasonality$seasonality # get the seasonality function
                                                # make seasonality compartment specific
                                                for(s in seq_along(s_params_kj)) {
                                                        s_param_names_kj[s] <- gsub("SELF", paste0(strat_self,"_",rates[[k]]$from, rates[[k]]$to), s_param_names_kj[s])
                                                        s_fcn_kj    <- gsub(names(rates[[k]]$seasonality$s_params)[s], s_param_names_kj[s], s_fcn_kj)
                                                }
                                                names(s_params_kj) <- s_param_names_kj

                                                # add to the parameter vector and param_codes
                                                parameters <- c(parameters, s_params_kj)
                                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- param_names <- names(parameters)

                                                # paste the seasonality into the rate function
                                                rate_fcns[[k]][[j]]$unlumped <- paste(rate_fcns[[k]][[j]]$unlumped, s_fcn_kj, sep = " + ")
                                        }
                                }



                                # make substitutions in the rate string
                                # SELF substitution
                                if(grepl("SELF", rates[[k]][[1]])) {
                                        rate_fcns[[k]][[j]][[1]] <- gsub("SELF", strat_self, rate_fcns[[k]][[j]][[1]])
                                }

                                # ALL substitution
                                if(grepl("ALL", rates[[k]][[1]])) {
                                        which_all <- sapply(comp_all, FUN = grepl, rate_fcns[[k]][[j]][[1]])
                                        which_sub <- comp_all[which_all]

                                        for(l in seq_along(which_sub)) {
                                                sub_comp <- comp_names[which(comp_all == which_sub[l])]
                                                sub_all  <- compartment_names[compartment_names %in% paste(sub_comp, strata, sep = "_")]
                                                rate_fcns[[k]][[j]][[1]] <- sub_comp_rate(rate_fcns[[k]][[j]][[1]], comp = which_sub, subs = sub_all)
                                        }
                                }

                                # ADJ substitution
                                if(grepl("ADJ", rates[[k]][[1]])) {
                                        # vector of adjacent strata
                                        strat_adj <- colnames(adjacency)[adjacency[strat_self,] == 1] # names of adjacent strata

                                        which_adj <- sapply(comp_adj, FUN = grepl, rate_fcns[[k]][[j]][[1]])
                                        which_sub <- comp_adj[which_adj] # string to be replaced, *_ADJ

                                        for(l in seq_along(which_sub)) {
                                                sub_comp <- comp_names[which(comp_adj == which_sub[l])]
                                                sub_adj  <- compartment_names[grepl(pattern = sub_comp, x = compartment_names)]

                                                # names of compartments to be substituted for *_ADJ
                                                sub_adj  <- compartment_names[which(compartment_names %in% paste(sub_comp, strat_adj, sep = "_"))]

                                                # make the substitution
                                                rate_fcns[[k]][[j]][[1]] <- sub_comp_rate(rate_fcns[[k]][[j]][[1]], comp = which_sub, subs = sub_adj)
                                        }
                                }

                                # make substitutions in the 'from' and 'to' arguments
                                if((!rate_fcns[[k]][[j]][[3]] %in% compartment_names) && (rate_fcns[[k]][[j]][[3]] %in% comp_names)) {
                                        rate_fcns[[k]][[j]][[3]] <- paste(rate_fcns[[k]][[j]][[3]], strat_self, sep = "_")
                                }

                                if((!rate_fcns[[k]][[j]][[4]] %in% compartment_names) && (rate_fcns[[k]][[j]][[4]] %in% comp_names)) {
                                        rate_fcns[[k]][[j]][[4]] <- paste(rate_fcns[[k]][[j]][[4]], strat_self, sep = "_")
                                }
                        }
                }

                rate_fcns <- unlist(rate_fcns, recursive = FALSE)

                # Instatiate the lumped rate functions, save the unconverted rates, then
                # make the substitutions for parameters, covariates, constants and states
                for(k in seq_along(rate_fcns)) {

                        # instatiate lumped rate functions
                        rate_fcns[[k]][[6]] <- paste0("(", rate_fcns[[k]][[1]], ") * ", rate_fcns[[k]][[3]])

                        # make the substitutions for the parameter codes
                        for(s in seq_along(param_codes)) {
                                code_name <- param_names[s]
                                code      <- param_codes[s]
                                rate_fcns[[k]][[1]] <- gsub(code_name, paste0("parameters[",code,"]"), rate_fcns[[k]][[1]])
                        }

                        # make the substitutions for the constant codes
                        for(s in seq_along(tcovar_codes)) {
                                code_name <- names(tcovar_codes)[s]
                                code      <- tcovar_codes[s]
                                rate_fcns[[k]][[1]] <- gsub(code_name, paste0("tcovar[",code,"]"), rate_fcns[[k]][[1]])
                        }

                        # make the substitutions for the constant codes
                        if(!is.null(const_codes)) {
                                for(s in seq_along(const_codes)) {
                                        code_name <- names(const_codes)[s]
                                        code      <- const_codes[s]
                                        rate_fcns[[k]][[1]] <- gsub(code_name, paste0("constants[",code,"]"), rate_fcns[[k]][[1]])
                                }
                        }

                        # instatiate lumped rate functions
                        rate_fcns[[k]][[2]] <- paste0("(", rate_fcns[[k]][[1]], ") * ", rate_fcns[[k]][[3]])

                        # make substitutions for compartment codes
                        for(t in seq_along(compartment_codes)) {
                                code_name <- names(compartment_codes)[t]
                                code      <- compartment_codes[t]
                                rate_fcns[[k]]$lumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]]$lumped)
                                rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]]$unlumped)
                        }
                }

                # unpack the initialization lists
                initializer     <- vector(mode = "list", length = length(state_initializer))
                initdist_params <- vector(mode = "list", length = length(state_initializer))
                initdist_priors <- vector(mode = "list", length = length(state_initializer))
                param_inds <- 0

                for(k in seq_along(state_initializer)) {

                        # get the relevant strata
                        if (identical(state_initializer[[k]]$strata, "ALL") ||
                            all(strata %in% state_initializer[[k]]$strata)) {
                                rel_strata <- strata
                        } else {
                                rel_strata <- state_initializer[[k]]$strata
                        }

                        # ensure that there is one initializer function per stratum
                        initializer[[k]] <- vector(mode = "list", length = length(rel_strata))

                        # handle initial parameters
                        initdist_params[[k]] <- vector(mode = "list", length = length(rel_strata))
                        initdist_priors[[k]] <- vector(mode = "list", length = length(rel_strata))

                        for(j in seq_along(initializer[[k]])) {
                                initializer[[k]][[j]]$init_states <- state_initializer[[k]]$init_states
                                initializer[[k]][[j]]$prior       <- state_initializer[[k]]$prior
                                initializer[[k]][[j]]$fixed       <- state_initializer[[k]]$fixed
                                initializer[[k]][[j]]$strata      <- rel_strata[j]
                                initializer[[k]][[j]]$codes       <-
                                        match(paste(names(initializer[[k]][[j]]$init_states), rel_strata[j], sep = "_"),
                                              names(compartment_codes))

                                initdist_params[[k]][[j]] <- state_initializer[[k]]$init_states
                                initdist_priors[[k]][[j]] <- state_initializer[[k]]$prior
                                param_inds <- max(param_inds) + seq_along(state_initializer[[k]]$init_states)
                                initializer[[k]][[j]]$param_inds <- param_inds
                        }
                }

                initializer     <- unlist(initializer, recursive = FALSE);
                initdist_params <- unlist(initdist_params)
                initdist_priors <- unlist(initdist_priors)

                # determine if initial states are fixed
                fixed_inits <- all(sapply(initializer, "[[", "fixed") == TRUE)

                strata_sizes <- sapply(initializer, function(x) sum(x[["init_states"]]));
                names(strata_sizes) <- paste0("popsize_", sapply(initializer, "[[", "strata"))
                popsize <- sum(strata_sizes)

                constants   <- c(constants, popsize = popsize, strata_sizes)
                const_codes <- seq_along(c(const_codes, popsize, strata_sizes)) - 1
                names(const_codes) <- names(constants)

                # check that either all parameters are random or that initial state is fixed for each stratum
                if (!(all(sapply(initializer, function(x) x$fixed == TRUE)) ||
                      all(sapply(initializer, function(x) x$fixed == FALSE)))) {
                        stop("All of the initial state parameters must either be fixed, or all must be random.")
                }

        } else {

                rate_fcns <- vector(mode = "list", length = length(rates))

                for(k in seq_along(rates)) {

                        rate_fcns[[k]] <- vector(mode = "list", length = 6)
                        names(rate_fcns[[k]]) <- c("unlumped", "lumped", "from", "to", "incidence", "unparsed")
                        rate_fcns[[k]][c(1,3,4,5)] <- rates[[k]][c("rate", "from", "to", "incidence")]

                        # if there are common_seasonal terms add them, and add
                        # the parameters onto the parameter vector
                        if(!is.null(rates[[k]]$seasonality)) {

                                # substitute the from and to arguments into the
                                # parameter names
                                s_param_names <- names(rates[[k]]$seasonality$s_params)
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        rates[[k]]$seasonality$seasonality <- gsub(s_param_names[s],
                                                                                   paste0(s_param_names[s], "_", rates[[k]]$from, rates[[k]]$to),
                                                                                   rates[[k]]$seasonality$seasonality)
                                }

                                names(rates[[k]]$seasonality$s_params) <- s_param_names <- paste0(s_param_names, "_", rates[[k]]$from, rates[[k]]$to)
                                parameters <- c(parameters, rates[[k]]$seasonality$s_params)
                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- param_names <- names(parameters)

                                # add the seasonality
                                rate_fcns[[k]][[1]] <- paste(rate_fcns[[k]][[1]], rates[[k]]$seasonality$seasonality, sep = " + ")
                        }

                        # save the unparsed rate
                        rate_fcns[[k]][[6]] <- paste0("(", rate_fcns[[k]][[1]], ") * ", rate_fcns[[k]][[3]])

                        # make the substitutions for the parameter codes
                        for(s in seq_along(param_codes)) {
                                code_name <- names(param_codes)[s]
                                code      <- param_codes[s]
                                rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("parameters[",code,"]"), rate_fcns[[k]]$unlumped)
                        }

                        # make the substitutions for the covariate codes
                        for(s in seq_along(tcovar_codes)) {
                                code_name <- names(tcovar_codes)[s]
                                code      <- tcovar_codes[s]
                                rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("tcovar[",code,"]"), rate_fcns[[k]]$unlumped)
                        }

                        # make the substitutions for the constant codes
                        if(!is.null(const_codes)) {
                                for(s in seq_along(const_codes)) {
                                        code_name <- names(const_codes)[s]
                                        code      <- const_codes[s]
                                        rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("constants[",code,"]"), rate_fcns[[k]]$unlumped)
                                }
                        }

                        # make the substitutions for the compartment codes
                        for(s in seq_along(compartment_codes)) {
                                code_name <- names(compartment_codes)[s]
                                code      <- compartment_codes[s]
                                rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]]$unlumped)
                        }

                        # instatiate the lumped rate function
                        rate_fcns[[k]][[2]] <- paste0("(", rate_fcns[[k]][[1]], ") * state[", compartment_codes[rate_fcns[[k]][[3]]], "]")
                }

                initializer            <- state_initializer
                initdist_params        <- state_initializer$init_states
                initdist_priors        <- state_initializer$prior
                initializer$param_inds <- seq_along(initdist_params)
                initializer$codes      <- match(names(initializer$init_states), names(compartment_codes))

                fixed_inits  <- state_initializer$fixed
                strata_sizes <- NULL
                popsize      <- sum(initializer$init_states)

                constants          <- c(constants, popsize = popsize)
                const_codes        <- c(const_codes, length(const_codes))
                names(const_codes) <- names(constants)
        }

        # construct the flow matrix
        flow_matrix <- build_flowmat(rate_fcns, compartment_names)

        # recreate the incidence compartment codes
        incidence_comps <- !is.na(match(colnames(flow_matrix), rownames(flow_matrix)))
        incidence_codes <- which(incidence_comps) - 1
        if(length(incidence_codes)) {
                names(incidence_codes) <- colnames(flow_matrix)[incidence_comps]
                incidence_sources      <- sapply(names(incidence_codes),
                                                 function(x) compartment_codes[which(flow_matrix[x,] == -1)])
        } else {
                incidence_codes   <- NULL
                incidence_sources <- NULL
        }

        # determine whether the model is progressive and whether there are absorbing states
        progressive      <- is_progressive(flow_matrix)
        absorbing_states <- which_absorbing(flow_matrix)

        # construct the rate adjacency matrix -- specifies which rates need to
        # be updates when a transition occurs
        rate_adjmat <- build_rate_adjmat(rate_fcns, compartment_codes)

        # build the time-varying covariate matrix so that it contains the census intervals
        tcovar              <- build_tcovar_matrix(tcovar = tcovar, timestep = timestep, t0 = t0, tmax = tmax)
        tcovar_codes        <- seq_len(ncol(tcovar) - 1)
        names(tcovar_codes) <- colnames(tcovar)[2:ncol(tcovar)]
        n_tcovar            <- ncol(tcovar) - 1
        tcovar_changemat    <- build_tcovar_changemat(tcovar)
        tcovar_adjmat       <- build_tcovar_adjmat(rate_fcns, tcovar_codes)
        timecode            <- which(names(tcovar_codes) == "TIME")

        if(length(tcovar_codes)>1 & stan_lna_code) {
                stop("Time varying covariates not yet available for Stan code generation.")
        }

        # generate the initial distribution
        if(n_strata == 1) {
                param_inds     <- initializer$param_inds # initial distribution parameter indices
                initdist_codes <- initializer$codes # codes, by compartment then stratum
        } else {
                param_inds     <- unlist(lapply(initializer, function(x) x$param_inds))
                initdist_codes <- unlist(lapply(initializer, function(x) x$codes))
        }

        # reorder the initial distribution parameters
        initdist_parameters        <- as.numeric(initdist_params[order(initdist_codes)])
        initdist_priors            <- as.numeric(initdist_priors[order(initdist_codes)])
        names(initdist_parameters) <- paste0(names(compartment_codes), "_0")

        # add the initial state parameters either to the parameters or to the constants
        if(fixed_inits) {
                constants          <- c(constants, initdist_parameters)
                const_codes        <- c(const_codes, seq_along(initdist_codes) + length(const_codes) - 1)
                names(const_codes) <- names(constants)
        } else {
                parameters         <- c(parameters, initdist_parameters)
                param_codes        <- c(param_codes, seq_along(initdist_codes) + length(param_codes) - 1)
                names(param_codes) <- names(parameters)
        }

        # compile the rate functions and get the pointers
        if(compile_rates) {
                rate_ptrs <- parse_rates(rates = rate_fcns, messages = messages)
        } else {
                rate_ptrs <- NULL
        }

        # if LNA functions are requested, compile them
        if(stan_lna_code) {

                # remove the incidence codes from the flow matrix, we don't need them
                if(!is.null(incidence_codes)) {
                        flow_matrix_lna           <- flow_matrix[,-c(incidence_codes+1)]
                        rownames(flow_matrix_lna) <- paste0(sapply(rate_fcns, "[[", "from"),"2",
                                                            sapply(rate_fcns, "[[", "to"))
                } else {
                        flow_matrix_lna       <- flow_matrix
                        rownames(flow_matrix_lna) <- paste0(sapply(rate_fcns, "[[", "from"),"2",
                                                            sapply(rate_fcns, "[[", "to"))
                }

                # remove t0 from the constants or parameters
                if(t0_fixed) {
                        const_codes <- const_codes[-which(names(const_codes) == "t0")]
                        const_names <- names(const_codes)
                        const_codes <- seq_along(const_codes)
                        names(const_codes) <- const_names
                } else {
                        param_codes <- param_codes[-which(names(param_codes) == "t0")]
                        param_names <- names(param_codes)
                        param_codes <- seq_along(param_codes)
                        names(param_codes) <- param_names
                }

                # Stan rates and pointers, done on the event counts
                # first translate the rates into rates on the counting processes
                lna_rates <- rate_fcns_4_lna(rate_fcns         = rate_fcns,
                                             compartment_codes = compartment_codes,
                                             flow_matrix       = flow_matrix_lna)

                lna_comp_codes  <- lna_rates$lna_comp_codes
                lna_rates       <- lna_rates$lna_rates

                lna_rates       <- parse_lna_rates(lna_rates = lna_rates, param_codes = param_codes,
                                                  const_codes = const_codes, tcovar_codes = tcovar_codes,
                                                  lna_comp_codes = lna_comp_codes)

                stan_lna_rates <- lna_rates
                lna_rates <- NULL

        } else {
                lna_rates         <- list(hazards = NULL, derivatives = NULL, lna_param_codes = NULL)
                flow_matrix_lna   <- NULL
                stan_lna_rates <- NULL
        }

        # compile the functions to solve the ODEs for the stochastic epidemic model
        if(compile_ode) {
                ode_rates   <- build_ode_rates(rate_fcns, param_codes, const_codes, tcovar_codes, compartment_codes)
                ode_pointer <- parse_ode_fcns(ode_rates, flow_matrix, messages = messages)
        } else {
                ode_pointer <- NULL
                ode_rates   <- list(hazards = NULL, ode_param_codes = NULL)
        }

        # create the list determining the stem dynamics
        dynamics <- list(rates               = rate_fcns,
                         rate_ptrs           = rate_ptrs,
                         parameters          = parameters,
                         tcovar              = tcovar,
                         constants           = constants,
                         state_initializer   = initializer,
                         initdist_params     = initdist_parameters,
                         initdist_priors     = initdist_priors,
                         fixed_inits         = fixed_inits,
                         flow_matrix         = flow_matrix,
                         flow_matrix_lna     = flow_matrix_lna,
                         lna_rates           = lna_rates,
                         stan_lna_rates      = stan_lna_rates,
                         ode_pointer         = ode_pointer,
                         ode_hazards         = ode_rates$ode_hazards,
                         strata_sizes        = strata_sizes,
                         popsize             = popsize,
                         comp_codes          = compartment_codes,
                         param_codes         = param_codes,
                         tcovar_codes        = tcovar_codes,
                         const_codes         = const_codes,
                         strata_codes        = strata_codes,
                         ode_param_codes     = ode_rates$ode_param_codes,
                         incidence_codes     = incidence_codes,
                         incidence_sources   = incidence_sources,
                         progressive         = progressive,
                         absorbing_states    = absorbing_states,
                         rate_adjmat         = rate_adjmat,
                         timevarying         = timevarying,
                         timecode            = timecode,
                         tcovar_adjmat       = tcovar_adjmat,
                         tcovar_changemat    = tcovar_changemat,
                         t0                  = t0,
                         t0_fixed            = t0_fixed,
                         tmax                = tmax,
                         n_strata            = n_strata,
                         n_compartments      = ncol(flow_matrix),
                         n_params            = n_params,
                         n_tcovar            = n_tcovar,
                         n_consts            = n_consts,
                         .dynamics_args      = .dynamics_args)

        return(dynamics)
}