#' Generate the objects governing the dynamics of a stochastic epidemic model.
#'
#' @param rates list of rate lists, each generated by a call to the
#'   \code{\link{rate}} function.
#' @param parameters numeric vector with named elements, the model parameters.
#' @param state_initializer list of initializer lists, each generated by a call
#'   to \code{\link{stem_initializer}}. Used to initialize the system at the
#'   first observation time.
#' @param compartments character vector of compartment names if there is a
#'   single stratum, or if there are multiple strata a list of character vectors
#'   where the name of each character vector is the compartment name and the
#'   character vector lists the strata to in which the compartment exists. The
#'   reserved word "ALL" can be used instead of listing all strata.
#' @param tcovar Matrix or data frame of time varying covariates, the first
#'   column of which contains the times at which covariates change.
#' @param strata vector of stratum names, required if the "ALL" reserved word is
#'   used
#'
#'   (e.g. compartments = list(S = "ALL", I = "ALL", R = "ALL", D = "old");
#'   strata = c("infants", "young", "old");
#' @inheritParams simulate_stem
#' @param constants optional. numeric vector with named elements that are
#'   constants referenced in the rate functions.
#' @param adjacency optional matrix specifying the adjacency structure of
#'   strata, with 0 entries indicating non-adjacency and 1 for adjacency. Rows
#'   and columns must be labeled.
#' @inheritParams parse_rates
#'
#'   Important note: care should be taken to make sure that there are no partial
#'   string matches between the building blocks of a model. For example, if the
#'   population size is given by the string constant "N", then "N" should not
#'   appear in any of parameter names, compartment names, etc. In particular,
#'   suppose there is a parameter named "BETA_N". When the rate functions are
#'   parsed internally, the rate strings will be parsed incorrectly due to the
#'   partial match.
#'
#' @return list with evaluated rate functions and objects for managing the
#'   bookkeeping for epidemic paths.
#' @export
#'
stem_dynamics <- function(rates, parameters, state_initializer, compartments, tcovar = NULL, t0 = NULL, tmax = NULL, timestep = NULL, strata = NULL, constants = NULL, adjacency = NULL, messages = TRUE) {

        # check consistency of specification and throw errors if inconsistent
        if(is.list(compartments) && ("ALL" %in% compartments) && is.null(strata)) {
                stop("In order to use 'ALL' to specify that some compartments are present for all strata, a character vector of stratum names must be supplied")
        }

        # check for partial matches in parameter names
        param_match <- rep(FALSE, length(parameters)); param_names <- names(parameters)
        for(p in seq_along(parameters)) {
                param_match[p] <- any(grepl(param_names[p], param_names[-p]))
        }
        if(any(param_match)) {
                stop(paste("Parameter(s)", paste(which(param_match), collapse = ", "), "have a partial name match with another parameter. Give unique names to resolve ambiguities."))
        }

        # check that none of the strata are named "TIME", "ALL", "ADJ", or "SELF", and
        # that these strings do not appear in subscripts
        if(any(c("TIME", "ALL", "ADJ", "SELF") %in% strata)){
                stop("'TIME', 'ALL', 'ADJ', and 'SELF' are reserved words and cannot be used in stratum names")
        }

        # check that "TIME" is not listed as one of the parameters
        if("TIME" %in% names(parameters)) {
                stop("'TIME' is a reserved word and should not be one of the parameter names.")
        }

        # check that "TIME" is not listed as one of the constants
        if("TIME" %in% names(constants)) {
                stop("'TIME' is a reserved word and should not be one of the names of constants.")
        }

        if(!is.null(strata) && (any(sapply(state_initializer, "[[", 2) == TRUE) & any(sapply(state_initializer, "[[", 2) == TRUE))) {
                stop("The initial states in each stratum must either all be fixed, or all be random.")
        }

        # check that the strata names in the compartment list match the strata
        if(is.list(compartments) && !all(unlist(compartments[unlist(compartments)]) %in% strata)) {
                stop(sQuote(unlist(compartments)[which((!unlist(compartments) %in% strata) & (unlist(compartments) != "ALL"))]), "is not in the supplied vector of stratum names")
        }

        # check that the strata argument is specified for all rates if there are
        # multiple strata the rate list is invalid if it is of length three so
        # that strata are not supplied, or if seasonal terms are added, but are supplied in the fourth list element
        if(!is.null(strata)) {
                for(k in 1:length(rates)) {
                        if(is.null(rates[[k]]$strata)) {
                                stop("If strata are specified in the model, they must also be specified in all rate functions.")
                        }
                }
        }

        # create a hidden list of user supplied arguments prior to processing
        .dynamics_args <- list(rates             = rates,
                               parameters        = parameters,
                               state_initializer = state_initializer,
                               compartments      = compartments,
                               tcovar            = tcovar,
                               t0                = t0,
                               tmax              = tmax,
                               timestep          = timestep,
                               strata            = strata,
                               constants         = constants,
                               adjacency         = adjacency,
                               messages          = messages)

        # build the vector of full compartment names
        if(!is.list(compartments)) {
                compartment_names <- compartments

        } else if(is.list(compartments)){

                comp_names <- names(compartments) # just the names of compartments without strata
                compartment_names <- vector("list", length(compartments)) # list with full compartment_strata names

                for(k in seq_along(compartment_names)) {
                        if(!identical(compartments[[k]], "ALL")) {
                                compartment_names[[k]] <- do.call(paste, list(comp_names[k], compartments[[k]], sep = "_"))
                        } else {
                                compartment_names[[k]] <- do.call(paste, list(comp_names[k], strata, sep = "_"))
                        }
                }
                compartment_names <- unlist(compartment_names)
        }


        if(messages) {
                if(any(sapply(c(compartment_names, names(parameters), colnames(tcovar), names(constants)), function(x) nchar(x) < 4))) {
                        warning("It is highly suggested that all compartments, parameters, time-varying covariates, and constants have names that are at least four characters long to avoid errors when parsing the rate functions!")
                }
        }

        # check that there are no partial matches among compartment names
        # parameters
        comp_match <- rep(FALSE, length(compartments))
        for(p in seq_along(compartments)) {
                comp_match[p] <- any(grepl(compartment_names[p], compartment_names[-p]))
        }
        if(any(comp_match)) {
                stop(paste("Compartment(s)", paste(which(comp_match), collapse = ", "), "have a partial name match with another compartment. Give unique names to resolve ambiguities."))
        }

        # get the number of strata, the number of compartments, number of parameters, and number of time-varying covariates (plus time)
        n_strata        <- max(1,length(strata));
        n_compartments  <- length(compartment_names)
        n_params        <- length(parameters)
        n_consts        <- length(constants)

        # ensure that time and time-varying covariates will be properly accounted for
        timevarying <- any(sapply(rates, function(x) grepl("TIME", x[[1]]))) || any(sapply(rates, function(x) !is.null(x[[4]])))

        if(!timevarying) {
                tcovar_names <- tcovar_codes <- NULL
                n_tcovar     <- 0
        } else {
                if(is.null(tcovar)) {
                        tcovar_names <- "TIME"
                        n_tcovar <- 1
                        tcovar_codes <- 1; names(tcovar_codes) <- "TIME"
                } else {
                        tcovar_names    <- c(colnames(tcovar)[2:ncol(tcovar)], "TIME")
                        n_tcovar        <- length(tcovar_names)
                        tcovar_codes    <- seq_len(n_tcovar); names(tcovar_codes) <- tcovar_names # the first column will be the times, so codes start at 1
                }
        }

        # specify the time interval within which the process evolves
        if(is.null(t0)) {
                t0 <- 0
        }

        if(is.null(tmax)) {
                tmax <- 1e6
        }

        # compute the time discretization interval if it is not supplied and there are smooth time-varying covariates
        if(is.null(timestep) && timevarying) {
                timestep <- (tmax - t0)/50

        } else if(is.null(timestep) && !timevarying){
                timestep <- tmax - t0
        }

        # ensure that there are no partial matches amongst names of time-varying covariates
        if(timevarying) {
                tcovar_match <- rep(FALSE, length(tcovar_names))
                for(p in seq_along(tcovar_match)) {
                        tcovar_match[p] <- any(grepl(tcovar_names[p], tcovar_names[-p]))
                }
                if(any(tcovar_match)) {
                        stop(paste("Time-varying covariate(s)", paste(which(param_match), collapse = ", "), "have a partial name match with another time-varying covariate. Give unique names to resolve ambiguities."))
                }
        }

        # construct the mapping for the compartment_strata to the columns in the bookkeeping matrix
        compartment_codes <- 0:(n_compartments - 1);    names(compartment_codes)<- compartment_names

        param_codes <- 0:(n_params - 1)
        param_names <- names(parameters)
        names(param_codes) <- param_names

        if(n_strata) {
                strata_codes            <- 0:(n_strata - 1)
                names(strata_codes)     <- strata
        } else {
                strata_codes <- NULL
        }

        # check if it is necessary to add pi as a constant
        addpi <- rep(FALSE, length(rates))
        for(p in seq_along(addpi)) {
                addpi[p] <- !is.null(rates[[p]]$seasonality)
        }
        if(any(addpi)) {
                constants <- c(constants, pi)
                names(constants) <- c(names(constants), "M_PI")
                n_consts <- length(constants)
        }

        if(n_consts) {
                const_codes             <- 0:(n_consts - 1)
                const_names             <- names(constants)
                names(const_codes)      <- const_names
        } else {
                const_codes <- NULL
        }

        if(!is.null(constants)) {
                # ensure that there are no partial matches amongst names of constants
                const_match <- rep(FALSE, length(const_names))
                for(p in seq_along(const_match)) {
                        const_match[p] <- any(grepl(const_names[p], const_names[-p]))
                }
                if(any(const_match)) {
                        stop(paste("Constant(s)", paste(which(param_match), collapse = ", "), "have a partial name match with another constant or a generated constant corresponding to the population size or one of the stratum sizes. Give unique names to resolve ambiguities."))
                }
        }

        # if there are multiple strata, ensure that the rate functions are
        # specified for all compartments in their respective risk sets
        if(!is.null(strata)) {

                rate_fcns <- vector(mode = "list", length = length(rates))
                comp_all  <- paste(comp_names, "ALL", sep = "_")
                comp_adj  <- paste(comp_names, "ADJ", sep = "_")

                for(k in seq_along(rates)) {

                        # get the relevant strata
                        if(identical(rates[[k]]$strata, "ALL")) {
                                rel_strata <- strata
                        } else {
                                rel_strata <-rates[[k]]$strata
                        }

                        # ensure that there is one rate function per stratum
                        rate_fcns[[k]] <- vector(mode = "list", length = length(rel_strata))

                        # if there are rates with common_seasonal terms, add the parameters onto the parameter vector
                        if(!is.null(rates[[k]]$seasonality) && rates[[k]]$seasonality$common_seasonality) {

                                s_param_names <- names(rates[[k]]$seasonality$s_params)

                                # substitute the from and to arguments into the parameter names
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        rates[[k]]$seasonality$seasonality <- gsub(s_param_names[s],
                                                                                   paste0(s_param_names[s], "_",
                                                                                          rates[[k]]$from,
                                                                                          rates[[k]]$to),
                                                                                   rates[[k]]$seasonality$seasonality)
                                }

                                names(rates[[k]]$seasonality$s_params) <- paste0(s_param_names, "_", rates[[k]]$from, rates[[k]]$to)
                                parameters <- c(parameters, rates[[k]]$seasonality$s_params)
                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- param_names <- names(parameters)

                        }

                        # modify the rate function to reflect the stratum
                        for(j in seq_along(rel_strata)) {

                                strat_self <- rel_strata[j] # get stratum name

                                rate_fcns[[k]][[j]] <- vector(mode = "list", length = 4)
                                names(rate_fcns[[k]][[j]]) <- c("unlumped", "lumped", "from", "to")
                                rate_fcns[[k]][[j]][c(1,3,4)] <- rates[[k]][1:3] # copy generic rate function. slot 2 is for the lumped rate.

                                # if seasonal terms were supplied, instatiate
                                # them. If they are not common to all strata,
                                # add them to the parameter vector.
                                if(!is.null(rates[[k]]$seasonality)) {

                                        if(rates[[k]]$seasonality$common_seasonality) {
                                                rate_fcns[[k]][[j]]$unlumped <- paste(rate_fcns[[k]][[j]]$unlumped,
                                                                                      rates[[k]]$seasonality$seasonality, sep = " + ")

                                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                                        code_name <- names(rates[[k]]$seasonality$s_params)[s]
                                                        code <- param_codes[which(param_names == code_name)]
                                                        rate_fcns[[k]][[j]]$unlumped <- gsub(code_name, paste0("parameters[",code,"]"),
                                                                                             rate_fcns[[k]][[j]]$unlumped)
                                                }

                                        } else {
                                                # make substitution in parameter names and add to parameter vector
                                                s_params_kj <- rates[[k]]$seasonality$s_params # get the seasonality parameters
                                                s_param_names_kj <- names(rates[[k]]$seasonality$s_params) # get the seasonality parameter names
                                                s_fcn_kj <- rates[[k]]$seasonality$seasonality # get the seasonality function
                                                # make seasonality compartment specific
                                                for(s in seq_along(s_params_kj)) {
                                                        s_param_names_kj[s] <- gsub("SELF", paste0(strat_self,"_",rates[[k]]$from, rates[[k]]$to), s_param_names_kj[s])
                                                        s_fcn_kj    <- gsub(names(rates[[k]]$seasonality$s_params)[s], s_param_names_kj[s], s_fcn_kj)
                                                }
                                                names(s_params_kj) <- s_param_names_kj
                                                # add to the parameter vector and param_codes
                                                parameters <- c(parameters, s_params_kj)
                                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- param_names <- names(parameters)

                                                # substitute param code for seasonality parameters
                                                for(s in seq_along(s_params_kj)) {
                                                        code_name <- s_param_names_kj[s]
                                                        code <- param_codes[which(names(param_codes) == code_name)]
                                                        s_fcn_kj <- gsub(code_name, paste0("parameters[",code,"]"), s_fcn_kj)
                                                }

                                                rate_fcns[[k]][[j]]$unlumped <- paste(rate_fcns[[k]][[j]]$unlumped, s_fcn_kj, sep = " + ")
                                        }
                                }

                                # make the substitutions for the parameter codes
                                for(s in seq_along(param_codes)) {
                                        code_name <- param_names[s]
                                        code      <- param_codes[s]
                                        rate_fcns[[k]][[j]][[1]] <- gsub(code_name, paste0("parameters[",code,"]"), rate_fcns[[k]][[j]][[1]])
                                }

                                # make the substitutions for the constant codes
                                for(s in seq_along(tcovar_codes)) {
                                        code_name <- names(tcovar_codes)[s]
                                        code      <- tcovar_codes[s]
                                        rate_fcns[[k]][[j]][[1]] <- gsub(code_name, paste0("tcovar[",code,"]"), rate_fcns[[k]][[j]][[1]])
                                }

                                # make the substitutions for the constant codes
                                if(!is.null(const_codes)) {
                                        for(s in seq_along(const_codes)) {
                                                code_name <- names(const_codes)[s]
                                                code      <- const_codes[s]
                                                rate_fcns[[k]][[j]][[1]] <- gsub(code_name, paste0("constants[",code,"]"), rate_fcns[[k]][[j]][[1]])
                                        }
                                }

                                # make substitutions in the rate string
                                # SELF substitution
                                if(grepl("SELF", rates[[k]][[1]])) {
                                        rate_fcns[[k]][[j]][[1]] <- gsub("SELF", strat_self, rate_fcns[[k]][[j]][[1]])
                                }

                                # ALL substitution
                                if(grepl("ALL", rates[[k]][[1]])) {
                                        which_all <- sapply(comp_all, FUN = grepl, rate_fcns[[k]][[j]][[1]])
                                        which_sub <- comp_all[which_all]

                                        for(l in seq_along(which_sub)) {
                                                sub_comp <- comp_names[which(comp_all == which_sub[l])]
                                                sub_all  <- compartment_names[compartment_names %in% paste(sub_comp, strata, sep = "_")]
                                                rate_fcns[[k]][[j]][[1]] <- sub_comp_fcns(rate_fcns[[k]][[j]][[1]], comp = which_sub, subs = sub_all)
                                        }
                                }

                                # ADJ substitution
                                if(grepl("ADJ", rates[[k]][[1]])) {
                                        # vector of adjacent strata
                                        strat_adj <- colnames(adjacency)[adjacency[strat_self,] == 1] # names of adjacent strata

                                        which_adj <- sapply(comp_adj, FUN = grepl, rate_fcns[[k]][[j]][[1]])
                                        which_sub <- comp_adj[which_adj] # string to be replaced, *_ADJ

                                        for(l in seq_along(which_sub)) {
                                                sub_comp <- comp_names[which(comp_adj == which_sub[l])]
                                                sub_adj  <- compartment_names[grepl(pattern = sub_comp, x = compartment_names)]

                                                # names of compartments to be substituted for *_ADJ
                                                sub_adj  <- compartment_names[which(compartment_names %in% paste(sub_comp, strat_adj, sep = "_"))]

                                                # make the substitution
                                                rate_fcns[[k]][[j]][[1]] <- sub_comp_fcns(rate_fcns[[k]][[j]][[1]], comp = which_sub, subs = sub_adj)
                                        }
                                }

                                # make substitutions in the 'from' and 'to' arguments
                                if((!rate_fcns[[k]][[j]][[3]] %in% compartment_names) && (rate_fcns[[k]][[j]][[3]] %in% comp_names)) {
                                        rate_fcns[[k]][[j]][[3]] <- paste(rate_fcns[[k]][[j]][[3]], strat_self, sep = "_")
                                }

                                if((!rate_fcns[[k]][[j]][[4]] %in% compartment_names) && (rate_fcns[[k]][[j]][[4]] %in% comp_names)) {
                                        rate_fcns[[k]][[j]][[4]] <- paste(rate_fcns[[k]][[j]][[4]], strat_self, sep = "_")
                                }

                                # instatiate lumped rate functions
                                rate_fcns[[k]][[j]][[2]] <- paste0("(", rate_fcns[[k]][[j]][[1]], ") * ", rate_fcns[[k]][[j]][[3]])

                                # make substitutions for compartment codes
                                for(t in seq_along(compartment_codes)) {
                                        code_name <- names(compartment_codes)[t]
                                        code      <- compartment_codes[t]
                                        rate_fcns[[k]][[j]]$lumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]][[j]]$lumped)
                                        rate_fcns[[k]][[j]]$unlumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]][[j]]$unlumped)
                                }
                        }
                }

                rate_fcns <- unlist(rate_fcns, recursive = FALSE)

                # unpack the initialization lists
                initializer <- vector(mode = "list", length = length(state_initializer))
                initdist_params <- vector(mode = "list", length = length(state_initializer))
                param_inds <- 0

                for(k in seq_along(state_initializer)) {

                        # get the relevant strata
                        if(identical(state_initializer[[k]]$strata, "ALL")) {
                                rel_strata <- strata
                        } else {
                                rel_strata <- state_initializer[[k]]$strata
                        }

                        # ensure that there is one initializer function per stratum
                        initializer[[k]] <- vector(mode = "list", length = length(rel_strata))

                        # handle initial parameters
                        if(state_initializer[[k]]$shared_params) {
                                initdist_params[[k]] <- state_initializer[[k]]$init_states
                                param_inds <- max(param_inds) + seq_along(state_initializer[[k]]$init_states)
                        } else {
                                initdist_params[[k]] <- vector(mode = "list", length = length(rel_strata))
                        }

                        for(j in seq_along(initializer[[k]])) {
                                initializer[[k]][[j]]$init_states <- state_initializer[[k]]$init_states
                                initializer[[k]][[j]]$fixed       <- state_initializer[[k]]$fixed
                                initializer[[k]][[j]]$strata      <- rel_strata[j]

                                if(state_initializer[[k]]$shared_params) {
                                        initializer[[k]][[j]]$param_inds <- param_inds
                                } else {
                                        initdist_params[[k]][[j]] <- state_initializer[[k]]$init_states
                                        param_inds <- max(param_inds) + seq_along(state_initializer[[k]]$init_states)
                                        initializer[[k]][[j]]$param_inds <- param_inds
                                }
                        }
                }

                initializer <- unlist(initializer, recursive = FALSE); initdist_params <- unlist(initdist_params)
                initdist_strata <- initdist_params;
                for(s in seq_along(initializer)) initdist_strata[initializer[[s]]$param_inds] <- s

                # determine if initial states are fixed
                fixed_inits <- all(sapply(initializer, "[[", 2) == TRUE)

                strata_sizes <- sapply(initializer, function(x) sum(x[[1]]));
                names(strata_sizes) <- sapply(initializer, "[[", 3)
                popsize <- sum(strata_sizes)

                constants <- c(constants, popsize = popsize, strata_sizes)

                # check that either all parameters are random or that initial state is fixed for each stratum
                if(!(all(sapply(initializer, function(x) x[[2]] == TRUE)) | all(sapply(initializer, function(x) x[[2]] == FALSE)))) {
                        stop("All of the initial state parameters must either be fixed, or all must be random.")
                }

        } else {

                rate_fcns <- vector(mode = "list", length = length(rates))

                for(k in seq_along(rates)) {

                        rate_fcns[[k]] <- vector(mode = "list", length = 4); names(rate_fcns[[k]]) <- c("unlumped", "lumped", "from", "to")
                        rate_fcns[[k]][c(1,3,4)] <- rates[[k]][1:3]

                        # if there are common_seasonal terms add them, and add
                        # the parameters onto the parameter vector
                        if(!is.null(rates[[k]]$seasonality)) {

                                # substitute the from and to arguments into the
                                # parameter names
                                s_param_names <- names(rates[[k]]$seasonality$s_params)
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        rates[[k]]$seasonality$seasonality <- gsub(s_param_names[s],
                                                                                   paste0(s_param_names[s], "_", rates[[k]]$from, rates[[k]]$to),
                                                                                   rates[[k]]$seasonality$seasonality)
                                }

                                names(rates[[k]]$seasonality$s_params) <- s_param_names <- paste0(s_param_names, "_", rates[[k]]$from, rates[[k]]$to)
                                parameters <- c(parameters, rates[[k]]$seasonality$s_params)
                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- param_names <- names(parameters)

                                # add the seasonality
                                rate_fcns[[k]][[1]] <- paste(rate_fcns[[k]][[1]], rates[[k]]$seasonality$seasonality, sep = " + ")

                                # make the substitution for the seasonal
                                # parameter codes
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        code_name <- s_param_names[s]
                                        code <- param_codes[which(names(param_codes) == code_name)]
                                        rate_fcns[[k]][[1]] <- gsub(code_name, paste0("parameters[",code,"]"), rate_fcns[[k]][[1]])
                                }
                        }

                        # make the substitutions for the parameter codes
                        for(s in seq_along(param_codes)) {
                                code_name <- names(param_codes)[s]
                                code      <- param_codes[s]
                                rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("parameters[",code,"]"), rate_fcns[[k]]$unlumped)
                        }

                        # make the substitutions for the covariate codes
                        for(s in seq_along(tcovar_codes)) {
                                code_name <- names(tcovar_codes)[s]
                                code      <- tcovar_codes[s]
                                rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("tcovar[",code,"]"), rate_fcns[[k]]$unlumped)
                        }

                        # make the substitutions for the constant codes
                        if(!is.null(const_codes)) {
                                for(s in seq_along(const_codes)) {
                                        code_name <- names(const_codes)[s]
                                        code      <- const_codes[s]
                                        rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("constants[",code,"]"), rate_fcns[[k]]$unlumped)
                                }
                        }

                        # make the substitutions for the compartment codes
                        for(s in seq_along(compartment_codes)) {
                                code_name <- names(compartment_codes)[s]
                                code      <- compartment_codes[s]
                                rate_fcns[[k]]$unlumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]]$unlumped)
                        }

                        # instatiate the lumped rate function
                        rate_fcns[[k]][[2]] <- paste0("(", rate_fcns[[k]][[1]], ") * state[", compartment_codes[rate_fcns[[k]][[3]]], "]")
                }

                initializer  <- state_initializer; initdist_params <- state_initializer$init_states
                initializer$param_inds <- seq_along(initdist_params)
                initdist_strata <- rep(1, length(initdist_params)); names(initdist_strata) <- names(initdist_params)

                fixed_inits <- state_initializer$fixed
                strata_sizes <- NULL
                popsize     <- sum(initializer$init_states)

                constants <- c(constants, popsize = popsize)
        }

        # construct the flow matrix
        flow_matrix <- build_flowmat(rate_fcns, compartment_names)

        # determine whether the model is progressive and whether there are absorbing states
        progressive <- is_progressive(flow_matrix)
        absorbing_states <- which_absorbing(flow_matrix)

        # construct the rate adjacency matrix -- specifies which rates need to
        # be updates when a transition occurs
        rate_adjmat <- build_rate_adjmat(rate_fcns, compartment_codes)

        # build the time-varying covariate matrix so that it contains the census intervals
        tcovar <- build_tcovar_matrix(tcovar = tcovar, timestep = timestep, t0 = t0, tmax = tmax)
        tcovar_codes <- seq_len(ncol(tcovar) - 1)
        names(tcovar_codes) <- colnames(tcovar)[2:ncol(tcovar)]
        n_tcovar <- ncol(tcovar) - 1
        tcovar_changemat <- build_tcovar_changemat(tcovar)
        tcovar_adjmat <- build_tcovar_adjmat(rate_fcns, tcovar_codes)

        timecode <- which(names(tcovar_codes) == "TIME")

        # compile the rate functions and get the pointers
        rate_ptrs <- parse_rates(rates = rate_fcns,
                                 param_codes = param_codes,
                                 compartment_codes = comp_codes,
                                 const_codes = const_codes,
                                 tcovar_codes = tcovar_codes,
                                 messages = messages)

        # parse the rates. rate_vec is a vector of function pointers. The rate
        # functions will be compiled and loaded into the global environment,
        # along with functions that modify a vector of rates in place for
        # forward simulation, and that can be used for solving the system of
        # ODEs for the model using the deSolve package.
        # rates_lumped   <- paste0("RATE", 1:length(rates),"_LUMPED")
        # rates_unlumped <- paste0("RATE", 1:length(rates),"_UNLUMPED")

        # create the list determining the stem dynamics
        dynamics <- list(rates            = rate_fcns,
                         rate_ptrs        = rate_ptrs,
                         parameters       = parameters,
                         tcovar           = tcovar,
                         constants        = constants,
                         state_initializer= initializer,
                         initdist_params  = initdist_params,
                         initdist_strata  = initdist_strata,
                         fixed_inits      = fixed_inits,
                         flow_matrix      = flow_matrix,
                         strata_sizes     = strata_sizes,
                         popsize          = popsize,
                         comp_codes       = compartment_codes,
                         param_codes      = param_codes,
                         tcovar_codes     = tcovar_codes,
                         const_codes      = const_codes,
                         strata_codes     = strata_codes,
                         progressive      = progressive,
                         absorbing_states = absorbing_states,
                         rate_adjmat      = rate_adjmat,
                         timevarying      = timevarying,
                         timecode         = timecode,
                         tcovar_adjmat    = tcovar_adjmat,
                         tcovar_changemat = tcovar_changemat,
                         n_strata         = n_strata,
                         n_compartments   = n_compartments,
                         n_params         = n_params,
                         n_tcovar         = n_tcovar,
                         n_consts         = n_consts,
                         .dynamics_args   = .dynamics_args)

        return(dynamics)
}