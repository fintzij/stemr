#' Generate the objects governing the dynamics of a stochastic epidemic model.
#'
#' @param rates list of rate lists, each generated by a call to the
#'   \code{\link{rate}} function.
#' @param parameters character vector of parameter names
#' @param compartments character vector of compartment names if there is a
#'   single stratum, or if there are multiple strata a list of character vectors
#'   where the name of each character vector is the compartment name and the
#'   character vector lists the strata to in which the compartment exists. The
#'   reserved word "ALL" can be used instead of listing all strata.
#' @param tcovar character vector of time-varying covariate names
#' @param strata vector of stratum names, required only if not all compartments
#'   are common to all strata
#'
#'   (e.g. compartments = list(S = "ALL", I = "ALL", R = "ALL", D = "old");
#'   strata = c("infants", "young", "old");
#' @param constants optional character vector of constants that are referenced
#'   in the rate functions
#' @param adjacency optional matrix specifying the adjacency structure of
#'   strata, with 0 entries indicating non-adjacency and 1 for adjacency. Rows
#'   and columns must be labeled.
#'
#' Important note: care should be taken to make sure that there are no partial
#' string matches between the building blocks of a model. For example, if the
#' population size is given by the string constant "N", then "N" should not
#' appear in any of parameter names, compartment names, etc. In particular,
#' suppose there is a parameter named "BETA_N". When the rate functions are
#' parsed internally, the rate strings will be parsed incorrectly due to the
#' partial match.
#'
#' @return list with evaluated rate functions and objects for managing the
#'   bookkeeping for epidemic paths.
#' @export
#'
stem_dynamics <- function(rates, parameters, compartments, tcovar = NULL, strata = NULL, constants = NULL, adjacency = NULL) {

        # check consistency of specification and throw errors if inconsistent
        if(is.list(compartments) && ("ALL" %in% compartments) && is.null(strata)) {
                stop("In order to use 'ALL' to specify that some compartments are present for all strata, a character vector of stratum names must be supplied")
        }

        # check that none of the strata are named "TIME", "ALL", "ADJ", or "SELF", and
        # that these strings do not appear in subscripts
        if(any(c("TIME", "ALL", "ADJ", "SELF") %in% strata) ||
           (is.list(compartments) && any(sapply(compartments, function(x) any(c("ALL", "TIME", "ADJ", "SELF") %in% x))))) {
                stop("'TIME', 'ALL', 'ADJ', and 'SELF' are reserved words and cannot be used in stratum or compartment names")
        }

        # check that "TIME" is not listed as one of the parameters or constants
        if("TIME" %in% parameters) {
                stop("'TIME' is a reserved word and should not be one of the parameter names.")
        }

        # check that "TIME" is not listed as one of the parameters or constants
        if("TIME" %in% constants) {
                stop("'TIME' is a reserved word and should not be one of the names of constants.")
        }

        # check that the strata names in the compartment list match the strata
        if(is.list(compartments) && !all(unlist(compartments[unlist(compartments)]) %in% strata)) {
                stop(sQuote(unlist(compartments)[which((!unlist(compartments) %in% strata) & (unlist(compartments) != "ALL"))]), "is not in the supplied vector of stratum names")
        }

        # check that the strata argument is specified for all rates if there are
        # multiple strata the rate list is invalid if it is of length three so
        # that strata are not supplied, or if seasonal terms are added, but are supplied in the fourth list element
        if(!is.null(strata)) {
                for(k in 1:length(rates)) {
                        if(is.null(rates[[k]]$strata)) {
                                stop("If strata are specified in the model, they must also be specified in all rate functions.")
                        }
                }
        }

        # check that the time variable in the seasonal terms matches the time variable
        for(k in seq_along(rates)) {
                if(!is.null(rates[[k]]$seasonality) && rates[[k]]$seasonality$timevar != timevar) {
                        stop("The time variable in the rate functions must match the time variable supplied to stem_dynamics.")
                }
        }

        # build the vector of full compartment names
        if(!is.list(compartments)) {
                compartment_names <- compartments

        } else if(is.list(compartments)){

                comp_names <- names(compartments) # just the names of compartments without strata
                compartment_names <- vector("list", length(compartments)) # list with full compartment_strata names

                for(k in seq_along(compartment_names)) {
                        if(!identical(compartments[[k]], "ALL")) {
                                compartment_names[[k]] <- do.call(paste, list(comp_names[k], compartments[[k]], sep = "_"))
                        } else {
                                compartment_names[[k]] <- do.call(paste, list(comp_names[k], strata, sep = "_"))
                        }
                }
                compartment_names <- unlist(compartment_names)
        }

        # get the number of strata, the number of compartments, number of parameters, and number of time-varying covariates (plus time)
        n_strata        <- length(strata)
        n_compartments  <- length(compartment_names)
        n_params        <- length(parameters)
        n_tcovar        <- length(tcovar) + 1 # time is always included as a time-varying covariate
        n_consts        <- length(constants)

        # construct the mapping for the compartment_strata to the columns in the bookkeeping matrix
        compartment_codes <- 0:(n_compartments - 1);    names(compartment_codes)<- compartment_names
        param_codes       <- 0:(n_params - 1);          names(param_codes)      <- parameters
        tcovar_codes      <- 0:(n_tcovar - 1);          names(tcovar_codes)     <- c("TIME", tcovar)
        if(n_consts) {
                const_codes             <- 0:(n_consts - 1)
                names(const_codes)      <- constants
        } else {
                const_codes <- NULL
        }

        # if there are multiple strata, ensure that the rate functions are
        # specified for all compartments in their respective risk sets
        if(!is.null(strata)) {

                rate_fcns <- vector(mode = "list", length = length(rates))
                comp_all  <- paste(comp_names, "ALL", sep = "_")
                comp_adj  <- paste(comp_names, "ADJ", sep = "_")

                for(k in seq_along(rates)) {

                        # make the substitutions for the parameter codes
                        for(s in seq_along(param_codes)) {
                                code_name <- names(param_codes)[s]
                                code      <- param_codes[s]
                                rates[[k]]$rate <- gsub(code_name, paste0("parameters[",code,"]"), rates[[k]]$rate)
                        }

                        # make the substitutions for the constant codes
                        for(s in seq_along(tcovar_codes)) {
                                code_name <- names(tcovar_codes)[s]
                                code      <- tcovar_codes[s]
                                rates[[k]]$rate <- gsub(code_name, paste0("tcovar[",code,"]"), rates[[k]]$rate)
                        }

                        # make the substitutions for the constant codes
                        if(!is.null(const_codes)) {
                                for(s in seq_along(const_codes)) {
                                        code_name <- names(const_codes)[s]
                                        code      <- const_codes[s]
                                        rates[[k]]$rate <- gsub(code_name, paste0("constants[",code,"]"), rates[[k]]$rate)
                                }
                        }

                        # get the relevant strata
                        if(identical(rates[[k]]$strata, "ALL")) {
                                rel_strata <- strata
                        } else {
                                rel_strata <-rates[[k]]$strata
                        }

                        # ensure that there is one rate function per stratum
                        rate_fcns[[k]] <- vector(mode = "list", length = length(rel_strata))

                        # if there are rates with common_seasonal terms, add the parameters onto the parameter vector
                        if(!is.null(rates[[k]]$seasonality) && rates[[k]]$seasonality$common_seasonality) {

                                # substitute the from and to arguments into the parameter names
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        rates[[k]]$seasonality$seasonality <- gsub(rates[[k]]$seasonality$s_params[s],
                                                                                   paste0(rates[[k]]$seasonality$s_params[s], "_", rates[[k]]$from, rates[[k]]$to),
                                                                                   rates[[k]]$seasonality$seasonality)
                                }

                                rates[[k]]$seasonality$s_params <- paste0(rates[[k]]$seasonality$s_params, "_", rates[[k]]$from, rates[[k]]$to)
                                parameters <- c(parameters, rates[[k]]$seasonality$s_params)
                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- parameters

                        }


                        # modify the rate function to reflect the stratum
                        for(j in seq_along(rel_strata)) {

                                strat_self <- rel_strata[j] # get stratum name

                                rate_fcns[[k]][[j]] <- vector(mode = "list", length = 4)
                                names(rate_fcns[[k]][[j]]) <- c("unlumped", "lumped", "from", "to")
                                rate_fcns[[k]][[j]][c(1,3,4)] <- rates[[k]][1:3] # copy generic rate function. slot 2 is for the lumped rate.

                                # if seasonal terms were supplied, instatiate
                                # them. If they are not common to all strata,
                                # add them to the parameter vector.
                                if(!is.null(rates[[k]]$seasonality)) {

                                        if(rates[[k]]$seasonality$common_seasonality) {
                                                rate_fcns[[k]][[j]]$unlumped <- paste(rate_fcns[[k]][[j]]$unlumped,
                                                                                      rates[[k]]$seasonality$seasonality, sep = " + ")

                                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                                        code_name <- rates[[k]]$seasonality$s_params[s]
                                                        code <- param_codes[which(parameters == code_name)]
                                                        rate_fcns[[k]][[j]]$unlumped <- gsub(code_name, paste0("parameters[",code,"]"),
                                                                                             rate_fcns[[k]][[j]]$unlumped)
                                                }

                                        } else {
                                                # make substitution in parameter names and add to parameter vector
                                                s_params_kj <- rates[[k]]$seasonality$s_params # get the seasonality parameters
                                                s_fcn_kj <- rates[[k]]$seasonality$seasonality # get the seasonality function
                                                # make seasonality compartment specific
                                                for(s in seq_along(s_params_kj)) {
                                                        s_params_kj[s] <- gsub("SELF", paste0(strat_self,"_",rates[[k]]$from, rates[[k]]$to), s_params_kj[s])
                                                        s_fcn_kj    <- gsub(rates[[k]]$seasonality$s_params[s], s_params_kj[s], s_fcn_kj)
                                                }
                                                # add to the parameter vector and param_codes
                                                parameters <- c(parameters, s_params_kj);
                                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- parameters

                                                # substitute param code for seasonality parameters
                                                for(s in seq_along(s_params_kj)) {
                                                        code_name <- s_params_kj[s]
                                                        code <- param_codes[which(names(param_codes) == code_name)]
                                                        s_fcn_kj <- gsub(code_name, paste0("parameters[",code,"]"), s_fcn_kj)
                                                }

                                                rate_fcns[[k]][[j]]$unlumped <- paste(rate_fcns[[k]][[j]]$unlumped, s_fcn_kj, sep = " + ")
                                        }
                                }

                                # make substitutions in the rate string
                                # SELF substitution
                                if(grepl("SELF", rates[[k]][[1]])) {
                                        rate_fcns[[k]][[j]][[1]] <- gsub("SELF", strat_self, rate_fcns[[k]][[j]][[1]])
                                }

                                # ALL substitution
                                if(grepl("ALL", rates[[k]][[1]])) {
                                        which_all <- sapply(comp_all, FUN = grepl, rate_fcns[[k]][[j]][[1]])
                                        which_sub <- comp_all[which_all]

                                        for(l in seq_along(which_sub)) {
                                                sub_comp <- comp_names[which(comp_all == which_sub[l])]
                                                sub_all  <- compartment_names[compartment_names %in% paste(sub_comp, strata, sep = "_")]
                                                rate_fcns[[k]][[j]][[1]] <- sub_comp_fcns(rate_fcns[[k]][[j]][[1]], comp = which_sub, subs = sub_all)
                                        }
                                }

                                # ADJ substitution
                                if(grepl("ADJ", rates[[k]][[1]])) {
                                        # vector of adjacent strata
                                        strat_adj <- colnames(adjacency)[adjacency[strat_self,] == 1] # names of adjacent strata

                                        which_adj <- sapply(comp_adj, FUN = grepl, rate_fcns[[k]][[j]][[1]])
                                        which_sub <- comp_adj[which_adj] # string to be replaced, *_ADJ

                                        for(l in seq_along(which_sub)) {
                                                sub_comp <- comp_names[which(comp_adj == which_sub[l])]
                                                sub_adj  <- compartment_names[grepl(pattern = sub_comp, x = compartment_names)]

                                                # names of compartments to be substituted for *_ADJ
                                                sub_adj  <- compartment_names[which(compartment_names %in% paste(sub_comp, strat_adj, sep = "_"))]

                                                # make the substitution
                                                rate_fcns[[k]][[j]][[1]] <- sub_comp_fcns(rate_fcns[[k]][[j]][[1]], comp = which_sub, subs = sub_adj)
                                        }
                                }

                                # make substitutions in the 'from' and 'to' arguments
                                if((!rate_fcns[[k]][[j]][[3]] %in% compartment_names) && (rate_fcns[[k]][[j]][[3]] %in% comp_names)) {
                                        rate_fcns[[k]][[j]][[3]] <- paste(rate_fcns[[k]][[j]][[3]], strat_self, sep = "_")
                                }

                                if((!rate_fcns[[k]][[j]][[4]] %in% compartment_names) && (rate_fcns[[k]][[j]][[4]] %in% comp_names)) {
                                        rate_fcns[[k]][[j]][[4]] <- paste(rate_fcns[[k]][[j]][[4]], strat_self, sep = "_")
                                }

                                # instatiate lumped rate functions
                                rate_fcns[[k]][[j]][[2]] <- paste0("(", rate_fcns[[k]][[j]][[1]], ") * ", rate_fcns[[k]][[j]][[3]])

                                # make substitutions for compartment codes
                                for(t in seq_along(compartment_codes)) {
                                        code_name <- names(compartment_codes)[t]
                                        code      <- compartment_codes[t]
                                        rate_fcns[[k]][[j]]$lumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]][[j]]$lumped)
                                        rate_fcns[[k]][[j]]$unlumped <- gsub(code_name, paste0("state[",code,"]"), rate_fcns[[k]][[j]]$unlumped)
                                }
                        }
                }

                rate_fcns <- unlist(rate_fcns, recursive = FALSE)

        } else {

                rate_fcns <- vector(mode = "list", length = length(rates))

                for(k in seq_along(rates)) {

                        # make the substitutions for the parameter codes
                        for(s in seq_along(param_codes)) {
                                code_name <- names(param_codes)[s]
                                code      <- param_codes[s]
                                rates[[k]]$rate <- gsub(code_name, paste0("parameters[",code,"]"), rates[[k]]$rate)
                        }

                        # make the substitutions for the covariate codes
                        for(s in seq_along(tcovar_codes)) {
                                code_name <- names(tcovar_codes)[s]
                                code      <- tcovar_codes[s]
                                rates[[k]]$rate <- gsub(code_name, paste0("tcovar[",code,"]"), rates[[k]]$rate)
                        }

                        # make the substitutions for the compartment codes
                        for(s in seq_along(compartment_codes)) {
                                code_name <- names(compartment_codes)[s]
                                code      <- compartment_codes[s]
                                rates[[k]]$rate <- gsub(code_name, paste0("state[",code,"]"), rates[[k]]$rate)
                        }

                        # make the substitutions for the constant codes
                        if(!is.null(const_codes)) {
                                for(s in seq_along(const_codes)) {
                                        code_name <- names(const_codes)[s]
                                        code      <- const_codes[s]
                                        rates[[k]]$rate <- gsub(code_name, paste0("constants[",code,"]"), rates[[k]]$rate)
                                }
                        }

                        rate_fcns[[k]] <- vector(mode = "list", length = 4); names(rate_fcns[[k]]) <- c("unlumped", "lumped", "from", "to")
                        rate_fcns[[k]][c(1,3,4)] <- rates[[k]][1:3]

                        # if there are common_seasonal terms add them, and add
                        # the parameters onto the parameter vector
                        if(!is.null(rates[[k]]$seasonality)) {

                                # substitute the from and to arguments into the
                                # parameter names
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        rates[[k]]$seasonality$seasonality <- gsub(rates[[k]]$seasonality$s_params[s],
                                                                                   paste0(rates[[k]]$seasonality$s_params[s], "_", rates[[k]]$from, rates[[k]]$to),
                                                                                   rates[[k]]$seasonality$seasonality)
                                }

                                rates[[k]]$seasonality$s_params <- paste0(rates[[k]]$seasonality$s_params, "_", rates[[k]]$from, rates[[k]]$to)
                                parameters <- c(parameters, rates[[k]]$seasonality$s_params)
                                param_codes <- seq(0, length(parameters)-1); names(param_codes) <- parameters

                                # add the seasonality
                                rate_fcns[[k]][[1]] <- paste(rate_fcns[[k]][[1]], rates[[k]]$seasonality$seasonality, sep = " + ")

                                # make the substitution for the seasonal
                                # parameter codes
                                for(s in seq_along(rates[[k]]$seasonality$s_params)) {
                                        code_name <- rates[[k]]$seasonality$s_params[s]
                                        code <- param_codes[which(names(param_codes) == code_name)]
                                        rate_fcns[[k]][[1]] <- gsub(code_name, paste0("parameters[",code,"]"), rate_fcns[[k]][[1]])
                                }
                        }

                        # instatiate the lumped rate function
                        rate_fcns[[k]][[2]] <- paste0("(", rate_fcns[[k]][[1]], ") * state[", compartment_codes[rate_fcns[[k]][[3]]], "]")
                }
        }

        # construct the flow matrix
        flow_matrix <- build_flowmat(rate_fcns, compartment_names)

        # construct the rate adjacency matrix -- specifies which rates need to
        # be updates when a transition occurs
        rate_adjmat <- build_rate_adjmat(rate_fcns, compartment_codes)

        # check if any of the rates depend on time or if there are time-varying
        # covariates. if so, construct an adjacency matrix.
        if(!is.null(tcovar)) {
                timevarying <- TRUE
        } else {
                timevarying <- FALSE
                for(t in seq_along(rates)) {
                        if(grepl("tcovar\\[0\\]", rate_fcns[[t]]$lumped)) timevarying <- TRUE
                        if(timevarying) break
                }
        }

        if(timevarying) {
                tcovar_adjmat <- build_tcovar_adjmat(rate_fcns, tcovar_codes)
        }

        # parse the rates. rate_vec is a vector of function pointers. The rate
        # functions will be compiled and loaded into the global environment,
        # along with functions that modify a vector of rates in place for
        # forward simulation, and that can be used for solving the system of
        # ODEs for the model using the deSolve package.
        rates_lumped   <- paste0("RATE", 1:length(rates),"_LUMPED")
        rates_unlumped <- paste0("RATE", 1:length(rates),"_UNLUMPED")
        parse_rates(rates = rate_fcns, param_codes = param_codes, compartment_codes = compartment_codes, const_codes = const_codes, tcovar_codes = tcovar_codes)
}