#' Fit a stochastic epidemic model using the linear noise approximation or
#' ordinary differential equations to approximate the latent epidemic process.
#'
#' @param stem_object a stochastic epidemic model object containing the dataset,
#'   model dynamics, and measurement process.
#' @param method either "lna" or ode.
#' @param iterations number of iterations
#' @param priors A list of three functions supplied by the user with names
#'   "prior_density", "to_estimation_scale", and "from_estimation_scale" (N.B.
#'   All three must be supplied). The first of these functions should have two
#'   arguments that are numeric vectors of parameters on their natural and
#'   estimation scales, specified in that order. The functions for converting
#'   parameters to and from their estimation scales. IMPORTANT NOTES: 1) The
#'   scale conversion functions must include the dots argument, "...", in the
#'   function arguments. 2) The priors should not include priors for the initial
#'   compartment counts or t0, which are specified in the
#'   \code{stem_initializer} function and in the \code{t0_kernel} argument.
#' @param mcmc_kern MCMC transition kernel generated by a call to the
#'   \code{mcmc_kernel} function.
#' @param ess_args list of elliptical slice sampling arguments
#' @param thin_params thinning interval for posterior parameter samples,
#'   defaults to 1
#' @param thin_latent_proc thinning interval for latent paths, defaults to
#'   ceiling(iterations/100) so that every 100th path will be saved
#' @param initialization_attempts number of initialization attempts
#' @param print_progress interval at which to print progress to a text file. If
#'   0 (default) progress is not printed.
#' @param status_filename string to pre-append to status files, defaults to LNA
#'   or ODE depending on the method used.
#' @param messages should status messages be printed? defaults to FALSE.
#'
#' @return list with posterior samples for the parameters and the latent
#'   process, along with MCMC diagnostics.
#' @export
fit_stem <-
        function(stem_object,
                 method,
                 priors,
                 mcmc_kern,
                 iterations,
                 lna_ess_args = NULL,
                 tparam_ess_args = NULL,
                 thin_params = ceiling(iterations / 1000),
                 thin_latent_proc = ceiling(iterations / 1000),
                 initialization_attempts = 500,
                 print_progress = 0,
                 status_filename = NULL,
                 messages = FALSE) {
            
        # check that the data, dynamics and measurement process are all supplied
        if (is.null(stem_object$measurement_process$data) ||
            is.null(stem_object$dynamics) ||
            is.null(stem_object$measurement_process)) {
                stop("The dataset, dynamics, and measurement process must all be specified.")
        }

        # check that the appropriate model object is compiled
        if(method == "lna") {
                if(is.null(stem_object$dynamics$lna_pointers)) {
                        stop("LNA is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "LNA"
                
        } else if(method == "ode") {
                if(is.null(stem_object$dynamics$ode_pointers)) {
                        stop("ODE is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "ODE"
        }
                
        # if the MCMC is being restarted, save the existing results
        mcmc_restart <- !is.null(stem_object$stem_settings$restart_objects)
        
        # extract the model objects from the stem_object
        if (is.function(stem_object$dynamics$parameters)) {
                par_init_fcn   <- stem_object$dynamics$parameters
                parameters     <- par_init_fcn()
                
                pd <- priors$prior_density(parameters, priors$to_estimation_scale(parameters))
                par_init_attempt <- 1
                while(is.infinite(pd) && par_init_attempt <= initialization_attempts) {
                        parameters <- par_init_fcn()
                        pd <- priors$prior_density(parameters, priors$to_estimation_scale(parameters))
                        par_init_attempt <- par_init_attempt + 1
                }
                
                if(is.infinite(pd)) {
                        stop("Parameters have log prior density of negative infinity. Try another initialization.")
                }
                
        } else {
                par_init_fcn   <- NULL
                parameters     <- stem_object$dynamics$parameters
                pd <- priors$prior_density(parameters, priors$to_estimation_scale(parameters))
                if(is.infinite(pd)) {
                        stop("Parameters have log prior density of negative infinity. Try another initialization.")
                }
        }
        
        # progress printing interval
        if(print_progress != 0) {
                progress_interval <- print_progress
                print_progress <- TRUE
        } else {
                progress_interval <- NULL
                print_progress <- FALSE
        }
        
        # extract objects
        if(method == "lna") {
                
                flow_matrix         <- stem_object$dynamics$flow_matrix_lna
                stoich_matrix       <- stem_object$dynamics$stoich_matrix_lna
                proc_pointer        <- stem_object$dynamics$lna_pointers$lna_ptr
                set_pars_pointer    <- stem_object$dynamics$lna_pointers$set_lna_params_ptr
                censusmat           <- stem_object$measurement_process$censusmat
                constants           <- stem_object$dynamics$constants
                n_compartments      <- ncol(flow_matrix)
                n_rates             <- nrow(flow_matrix)
                do_prevalence       <- stem_object$measurement_process$lna_prevalence
                event_inds          <- stem_object$measurement_process$incidence_codes_lna
                initializer         <- stem_object$dynamics$initializer
                fixed_inits         <- stem_object$dynamics$fixed_inits
                n_strata            <- stem_object$dynamics$n_strata
                initdist_inds       <- stem_object$dynamics$lna_initdist_inds
                initdist_params_cur <- as.numeric(stem_object$dynamics$initdist_params)
                t0                  <- stem_object$dynamics$t0
                step_size           <- stem_object$dynamics$dynamics_args$step_size
                
        } else if(method == "ode") {
                
                flow_matrix         <- stem_object$dynamics$flow_matrix_ode
                stoich_matrix       <- stem_object$dynamics$stoich_matrix_ode
                proc_pointer        <- stem_object$dynamics$ode_pointers$ode_ptr
                set_pars_pointer    <- stem_object$dynamics$ode_pointers$set_ode_params_ptr
                censusmat           <- stem_object$measurement_process$censusmat
                constants           <- stem_object$dynamics$constants
                n_compartments      <- ncol(flow_matrix)
                n_rates             <- nrow(flow_matrix)
                do_prevalence       <- stem_object$measurement_process$ode_prevalence
                event_inds          <- stem_object$measurement_process$incidence_codes_ode
                initializer         <- stem_object$dynamics$initializer
                fixed_inits         <- stem_object$dynamics$fixed_inits
                n_strata            <- stem_object$dynamics$n_strata
                initdist_inds       <- stem_object$dynamics$ode_initdist_inds
                initdist_params_cur <- as.numeric(stem_object$dynamics$initdist_params)
                t0                  <- stem_object$dynamics$t0
                step_size           <- stem_object$dynamics$dynamics_args$step_size
        }

        class(results) <- "stemr_inference_list"
        return(results)
}