#' Fit a stochastic epidemic model using the linear noise approximation or
#' ordinary differential equations to approximate the latent epidemic process.
#'
#' @param stem_object a stochastic epidemic model object containing the dataset,
#'   model dynamics, and measurement process.
#' @param method either "lna" or ode.
#' @param mcmc_kern MCMC transition kernel generated by a call to the
#'   \code{mcmc_kernel} function.
#' @param iterations number of iterations
#' @param initialization_attempts number of initialization attempts
#' @param thin_params thinning interval for posterior parameter samples,
#'   defaults to 1
#' @param thin_latent_proc thinning interval for latent paths, defaults to
#'   ceiling(iterations/100) so that every 100th path will be saved
#' @param return_adapt_rec should the MCMC adaptation record be returned?
#'   defaults to FALSE.
#' @param print_progress interval at which to print progress to a text file. If
#'   0 (default) progress is not printed.
#' @param status_filename string to pre-append to status files, defaults to LNA
#'   or ODE depending on the method used.
#' @param messages should status messages be printed? defaults to FALSE.
#'
#' @return list with posterior samples for the parameters and the latent
#'   process, along with MCMC diagnostics.
#' @export
fit_stem <-
        function(stem_object,
                 method,
                 mcmc_kern,
                 iterations,
                 initialization_attempts = 500,
                 thin_params = ceiling(iterations / 100),
                 thin_latent_proc = ceiling(iterations / 100),
                 return_adapt_rec = FALSE,
                 print_progress = 0,
                 status_filename = NULL,
                 messages = FALSE) {
            
        # check that the data, dynamics and measurement process are all supplied
        if(is.null(stem_object$measurement_process$data) ||
            is.null(stem_object$dynamics) ||
            is.null(stem_object$measurement_process)) {
                stop("The dataset, dynamics, and measurement process must all be specified.")
        }
        
        # check that the appropriate model object is compiled
        if(method == "lna") {
                if(is.null(stem_object$dynamics$lna_pointers)) {
                        stop("LNA is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "LNA"
                
        } else if(method == "ode") {
                if(is.null(stem_object$dynamics$ode_pointers)) {
                        stop("ODE is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "ODE"
        }
                
        # if the MCMC is being restarted, save the existing results
        mcmc_restart <- !is.null(stem_object$stem_settings$restart_objects)
        
        # unpack mcmc kernel
        param_blocks         = mcmc_kern$parameter_blocks
        lna_ess_control      = mcmc_kern$lna_ess_control
        initdist_ess_control = mcmc_kern$initdist_ess_control
        tparam_ess_control   = mcmc_kern$tparam_ess_control
        
        # match parameters in parblocks with dynamics and check that fcns for 
        # going to and from the estimation scale are 1:1
        # grab the names of parameters on their natural and estimation scales
        param_names_nat <- names(stem_object$dynamics$param_codes)
        param_names_est <- c(sapply(mcmc_kern$parameter_blocks, function(x) x$pars_est))
        n_model_params  <- length(param_names_est)
        parameters = stem_object$dynamics$parameters
        for(s in seq_along(param_blocks)) {
                
                # get indices 
                param_blocks[[s]]$inds_nat = 
                        match(param_blocks[[s]]$pars_nat, names(parameters))
                
                # double check whether the functions for going to and from the estimation scale biject
                if(any(parameters[param_blocks[[s]]$inds_nat] != 
                       param_blocks[[s]]$priors$from_estimation_scale(
                               param_blocks[[s]]$priors$to_estimation_scale(
                                       parameters[param_blocks[[s]]$inds_nat])))) {
                        stop(paste0("Functions for going to and from the estimation scale in parameter block ", s, " do not biject."))
                }
                
                # initialize parameters on their estimation scale
                param_blocks[[s]]$params_est = 
                        
        }
        
        
        if(is.function(stem_object$dynamics$parameters)) {
                
                par_init_fcn <- stem_object$dynamics$parameters
                parameters   <- par_init_fcn()
                
                pd <- logprior(to_estimation_scale(parameters))
                par_init_attempt <- 1
                while(is.infinite(pd) && par_init_attempt <= initialization_attempts) {
                        parameters <- par_init_fcn()
                        pd <- logprior(to_estimation_scale(parameters))
                        par_init_attempt <- par_init_attempt + 1
                }
                
                if(is.infinite(pd)) {
                        stop("Parameters have log prior density of negative infinity. Try another initialization.")
                }
                
        } else {
                par_init_fcn   <- NULL
                parameters     <- stem_object$dynamics$parameters
                pd <- logprior(to_estimation_scale(parameters))
                if(is.infinite(pd)) {
                        stop("Parameters have log prior density of negative infinity. Try another initialization.")
                }
        }
        
        # progress printing interval
        if(print_progress != 0) {
                progress_interval <- print_progress
                print_progress <- TRUE
        } else {
                progress_interval <- NULL
                print_progress <- FALSE
        }
        
        ### Unpack stem_object-------------------------
        # dynamics that are not method specific
        censusmat           <- stem_object$measurement_process$censusmat
        constants           <- stem_object$dynamics$constants
        n_compartments      <- ncol(flow_matrix)
        n_rates             <- nrow(flow_matrix)
        initializer         <- stem_object$dynamics$initializer
        fixed_inits         <- stem_object$dynamics$fixed_inits
        n_strata            <- stem_object$dynamics$n_strata
        initdist_params_cur <- as.numeric(stem_object$dynamics$initdist_params)
        t0                  <- stem_object$dynamics$t0
        step_size           <- stem_object$dynamics$dynamics_args$step_size
        
        # measurement process objects that are not method specific
        measproc_indmat <- stem_object$measurement_process$measproc_indmat
        dat             <- stem_object$measurement_process$obsmat
        obstimes        <- stem_object$measurement_process$obstimes
        
        # dynamics and measurement process objects that are method specific
        if(method == "lna") {
                
                # extract objects from dynamics
                flow_matrix      <- stem_object$dynamics$flow_matrix_lna
                stoich_matrix    <- stem_object$dynamics$stoich_matrix_lna
                proc_pointer     <- stem_object$dynamics$lna_pointers$lna_ptr
                set_pars_pointer <- stem_object$dynamics$lna_pointers$set_lna_params_ptr
                do_prevalence    <- stem_object$measurement_process$lna_prevalence
                event_inds       <- stem_object$measurement_process$incidence_codes_lna
                initdist_inds    <- stem_object$dynamics$lna_initdist_inds
                
                # measurement process
                d_meas_pointer   <- stem_object$measurement_process$meas_pointers_lna$d_measure_ptr
                
                # indices of parameters, constants, and time-varying covariates
                param_inds <- 
                        setdiff(stem_object$dynamics$lna_param_codes,
                                stem_object$dynamics$lna_initdist_inds)
                const_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        seq_along(stem_object$dynamics$const_codes) - 1
                tcovar_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        length(const_inds) + seq_along(stem_object$dynamics$tcovar_codes) - 1
                
                # should initial concentrations be updated jointly with the LNA path
                joint_initdist_update = !fixed_inits & lna_ess_control$joint_initdist_update
                
        } else if(method == "ode") {
                
                # extract objects from dynamics
                flow_matrix         <- stem_object$dynamics$flow_matrix_ode
                stoich_matrix       <- stem_object$dynamics$stoich_matrix_ode
                proc_pointer        <- stem_object$dynamics$ode_pointers$ode_ptr
                set_pars_pointer    <- stem_object$dynamics$ode_pointers$set_ode_params_ptr
                do_prevalence       <- stem_object$measurement_process$ode_prevalence
                event_inds          <- stem_object$measurement_process$incidence_codes_ode
                initdist_inds       <- stem_object$dynamics$ode_initdist_inds
                
                # measurement process
                d_meas_pointer   <- stem_object$measurement_process$meas_pointers_ode$d_measure_ptr
                
                # indices of parameters, constants, and time-varying covariates
                param_inds <- 
                        setdiff(stem_object$dynamics$param_codes, 
                                stem_object$dynamics$ode_initdist_inds)
                const_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        seq_along(stem_object$dynamics$const_codes) - 1
                tcovar_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        length(const_inds) + seq_along(stem_object$dynamics$tcovar_codes) - 1
                
                # obviously, initial distribution is its own ESS update
                joint_initdist_update = FALSE
        }
        
        # LNA ESS schedule --------------------------------------------------------
        if(method == "lna") {
                
                # initialize list with ESS schedule
                joint_strata_update = lna_ess_control$joint_strata_update
                ess_schedule = vector(mode = "list")
                if(joint_strata_update | n_strata == 1) {
                        ess_schedule$ess_inds = seq_len(nrow(flow_matrix))
                        
                } else {
                        ess_schedule$ess_inds =
                                lapply(paste0("_", names(stem_object$dynamics$strata_codes)),
                                       function(x) grep(x, rownames(flow_matrix)))
                }
                
                # get the complement indices for the elliptical slice sampling schedule
                ess_schedule$complementary_inds <- 
                        lapply(ess_schedule$ess_inds, 
                               function(x) setdiff(seq_len(nrow(flow_matrix)), x))
                
                # whether all strata are updated jointly
                ess_schedule$joint_strata_update = joint_strata_update
                ess_schedule$strata_codes        = stem_object$dynamics$strata_codes + 1
                
                # get the corresponding initdist codes
                if(joint_strata_update | n_strata == 1) {
                        ess_schedule$initdist_codes = c("ALL" = 1)
                } else {
                        ess_schedule$initdist_codes = 
                                match(names(ess_schedule$strata_codes), sapply(initializer, function(x) x$strata))
                }
                
                # LNA bracket width
                if(n_strata > 1 & !joint_strata_update & length(lna_ess_control$bracket_width) == 1) {
                        lna_bracket_width <- rep(lna_ess_control$bracket_width, n_strata)
                        names(lna_bracket_width) <- names(stem_object$dynamics$strata_codes)
                        
                } else {
                        lna_bracket_width = lna_ess_control$bracket_width
                }
                
                # for updating the LNA bracket width if requested
                lna_bracket_update_iter = lna_ess_control$bracket_update_iter
                
                if(lna_bracket_update_iter != Inf) {
                        lna_angle_mean  <- rep(0, length(ess_schedule[[1]]))
                        lna_angle_var   <- rep(pi^2 / 3, length(ess_schedule[[1]]))
                        lna_angle_resid <- rep(0, length(ess_schedule[[1]]))
                }
        }
        
        ### Initial distribution objects --------------------------------------------
        if(n_strata == 1) {
                comp_size_vec <- constants["popsize"]
        } else {
                comp_size_vec <- constants[paste0("popsize_", sapply(initializer,"[[","strata"))]
        }
        
        # list for initial compartment volume objects
        initdist_objects <- vector("list", length = n_strata)
        for(t in seq_len(n_strata)) {
                
                # hyperparameters
                comp_prior <- 
                        if(!initializer[[t]]$fixed) {
                                if(!is.null(initializer[[t]]$prior)) {
                                        if(comp_size_vec[t] != 0) {
                                                initializer[[t]]$prior
                                        } else {
                                                rep(0.0, length(initializer[[t]]$init_states))
                                        }
                                } else {
                                        if(comp_size_vec[t] != 0) {
                                                initializer[[t]]$init_states
                                        } else {
                                                rep(0.0, length(initializer[[t]]$init_states))     
                                        }
                                }
                        } else {
                                if(comp_size_vec[t] != 0) {
                                        initializer[[t]]$init_states
                                } else {
                                        rep(0.0, length(initializer[[t]]$init_states))     
                                }
                        }
                
                # compartment probabilities
                comp_probs <- if(sum(comp_prior) != 0) {
                        comp_prior / sum(comp_prior)
                } else {
                        rep(0.0, length(comp_prior))
                }
                
                # unconstrained moments
                comp_mean  <- comp_size_vec[t] * comp_probs
                comp_cov   <- comp_size_vec[t] * (diag(comp_probs) - comp_probs %*% t(comp_probs)) 
                
                if(initializer[[t]]$dist == "dirmultinom") 
                        comp_cov <- comp_cov * ((comp_size_vec[t] + sum(comp_prior))/(1 + sum(comp_prior))) 
                
                comp_cov_svd <- svd(comp_cov)
                comp_cov_svd$d[length(comp_cov_svd$d)] <- 0
                comp_sqrt_cov <- comp_cov_svd$u %*% diag(sqrt(comp_cov_svd$d))
                
                initdist_objects[[t]] <- 
                        list(
                                stratum            = initializer[[t]]$strata,
                                fixed              = initializer[[t]]$fixed,
                                comp_size          = comp_size_vec[t],
                                comp_mean          = comp_mean,
                                comp_sqrt_cov      = comp_sqrt_cov[,-length(comp_mean)],
                                draws_cur          = rnorm(length(comp_mean)-1),
                                draws_prop         = rnorm(length(comp_mean)-1),
                                draws_ess          = rnorm(length(comp_mean)-1),
                                comp_inds_R        = initializer[[t]]$codes,
                                comp_inds_Cpp      = initializer[[t]]$codes - 1
                        )
        }
        
        # names of initial compartment volumes
        convrec_initvol_names <- names(stem_object$dynamics$initdist_params)
        
        # vector for the initial compartment volumes
        init_volumes_cur  <- rep(0.0, n_compartments); copy_vec(init_volumes_cur, initdist_params_cur)
        init_volumes_prop <- rep(0.0, n_compartments); copy_vec(init_volumes_prop, initdist_params_cur)
        names(init_volumes_prop) <- names(init_volumes_cur) <- names(initdist_params_cur)
        
        # initialize initdist draws
        if(!fixed_inits) {
                
                # for recording the ess initdist updates
                if(!joint_initdist_update) {
                        initdist_steps        <- 1.0
                        initdist_angle        <- 0.0
                        initdist_step_record  <- rep(1, floor(iterations / thin_params))
                        initdist_angle_record <- rep(1, floor(iterations / thin_params))
                }
                
                bad_draws             <- rep(TRUE, length(initdist_objects))
                initdist_log_lik <- rep(0.0, floor(iterations / thin_params) + 1)
                
                # map draws to initial volumes
                while(any(bad_draws)) {
                        for(s in seq_along(initdist_objects)) {
                                
                                # map draws
                                copy_vec2(dest = init_volumes_cur,
                                          orig = c(initdist_objects[[s]]$comp_mean + 
                                                           c(initdist_objects[[s]]$comp_sqrt_cov %*% initdist_objects[[s]]$draws_cur)),
                                          inds = initdist_objects[[s]]$comp_inds_Cpp)
                                
                                # check boundary conditions
                                bad_draws[s] <- 
                                        any(init_volumes_cur[initdist_objects[[s]]$comp_inds_R] < 0) | 
                                        any(init_volumes_cur[initdist_objects[[s]]$comp_inds_R] > initdist_objects[[s]]$comp_size)
                                
                                # if outside boundaries, resample
                                if(bad_draws[s]) initdist_objects[[s]]$draws_cur <- rnorm(initdist_objects[[s]]$draws_cur)
                        }      
                }
        }
        
        
        
        # grab time-varying parameters
        if(mcmc_restart) {
                tparam <- stem_object$stem_settings$tparam_for_restart
        } else {
                tparam <- stem_object$dynamics$tparam
        }
        
        class(results) <- "stemr_inference_list"
        return(results)
}