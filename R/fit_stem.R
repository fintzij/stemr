#' Fit a stochastic epidemic model using the linear noise approximation or
#' ordinary differential equations to approximate the latent epidemic process.
#'
#' @param stem_object a stochastic epidemic model object containing the dataset,
#'   model dynamics, and measurement process.
#' @param method either "lna" or ode.
#' @param mcmc_kern MCMC transition kernel generated by a call to the
#'   \code{mcmc_kernel} function.
#' @param iterations number of iterations
#' @param initialization_attempts number of initialization attempts
#' @param thin_params thinning interval for posterior parameter samples,
#'   defaults to 1
#' @param thin_latent_proc thinning interval for latent paths, defaults to
#'   ceiling(iterations/100) so that every 100th path will be saved
#' @param return_adapt_rec should the MCMC adaptation record be returned?
#'   defaults to FALSE.
#' @param print_progress interval at which to print progress to a text file. If
#'   0 (default) progress is not printed.
#' @param status_filename string to pre-append to status files, defaults to LNA
#'   or ODE depending on the method used.
#' @param messages should status messages be printed? defaults to FALSE.
#'
#' @return list with posterior samples for the parameters and the latent
#'   process, along with MCMC diagnostics.
#' @export
fit_stem <-
        function(stem_object,
                 method,
                 mcmc_kern,
                 iterations,
                 initialization_attempts = 500,
                 thin_params = ceiling(iterations / 100),
                 thin_latent_proc = ceiling(iterations / 100),
                 return_adapt_rec = FALSE,
                 print_progress = 0,
                 status_filename = NULL,
                 messages = FALSE) {
            
        # check that the data, dynamics and measurement process are all supplied
        if(is.null(stem_object$measurement_process$data) ||
            is.null(stem_object$dynamics) ||
            is.null(stem_object$measurement_process)) {
                stop("The dataset, dynamics, and measurement process must all be specified.")
        }
        
        # check that the appropriate model object is compiled
        if(method == "lna") {
                if(is.null(stem_object$dynamics$lna_pointers)) {
                        stop("LNA is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "LNA"
                
        } else if(method == "ode") {
                if(is.null(stem_object$dynamics$ode_pointers)) {
                        stop("ODE is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "ODE"
        }
                
        # if the MCMC is being restarted, save the existing results
        mcmc_restart <- !is.null(stem_object$stem_settings$restart_objects)
        
        # grab parameter names
        parameters      <- stem_object$dynamics$parameters
        param_names_nat <- names(stem_object$dynamics$param_codes)
        param_names_est <- c(sapply(mcmc_kern$parameter_blocks, function(x) x$pars_est))
        n_model_params  <- length(param_names_est)
        
        # unpack mcmc kernel
        param_blocks         = mcmc_kern$parameter_blocks
        lna_ess_control      = mcmc_kern$lna_ess_control
        initdist_ess_control = mcmc_kern$initdist_ess_control
        tparam_ess_control   = mcmc_kern$tparam_ess_control
        
        # parameter codes
        if(method == "lna") {
                n_pars_tot  = length(stem_object$dynamics$lna_rates$lna_param_codes) 
                param_codes = stem_object$dynamics$lna_rates$lna_param_codes        
        } else {
                n_pars_tot  = length(stem_object$dynamics$ode_rates$ode_param_codes) 
                param_codes = stem_object$dynamics$lna_rates$ode_param_codes
        }
        
        # prepare param_blocks
        param_blocks <- 
                prepare_param_blocks(
                        param_blocks = param_blocks, 
                        parameters   = parameters,
                        param_codes  = param_codes,
                        iterations   = iterations)
        
        # progress printing interval
        if(print_progress != 0) {
                progress_interval <- print_progress
                print_progress <- TRUE
        } else {
                progress_interval <- NULL
                print_progress <- FALSE
        }
        
        ### Unpack stem_object-------------------------
        
        # dynamics that are not method specific
        censusmat           <- stem_object$measurement_process$censusmat
        constants           <- stem_object$dynamics$constants
        initializer         <- stem_object$dynamics$initializer
        fixed_inits         <- stem_object$dynamics$fixed_inits
        n_strata            <- stem_object$dynamics$n_strata
        t0                  <- stem_object$dynamics$t0
        step_size           <- stem_object$dynamics$dynamics_args$step_size
        
        # measurement process objects that are not method specific
        measproc_indmat <- stem_object$measurement_process$measproc_indmat
        dat             <- stem_object$measurement_process$obsmat
        obstimes        <- stem_object$measurement_process$obstimes
        
        # grab time-varying parameters
        if(mcmc_restart) {
                tparam <- stem_object$stem_settings$tparam_for_restart
        } else {
                tparam <- stem_object$dynamics$tparam
        }
        
        # dynamics and measurement process objects that are method specific
        if(method == "lna") {
                
                # extract objects from dynamics
                flow_matrix      <- stem_object$dynamics$flow_matrix_lna
                n_compartments   <- ncol(flow_matrix)
                n_rates          <- nrow(flow_matrix)
                stoich_matrix    <- stem_object$dynamics$stoich_matrix_lna
                proc_pointer     <- stem_object$dynamics$lna_pointers$lna_ptr
                set_pars_pointer <- stem_object$dynamics$lna_pointers$set_lna_params_ptr
                do_prevalence    <- stem_object$measurement_process$lna_prevalence
                event_inds       <- stem_object$measurement_process$incidence_codes_lna
                initdist_inds    <- stem_object$dynamics$lna_initdist_inds
                
                # measurement process
                d_meas_pointer   <- stem_object$measurement_process$meas_pointers_lna$d_measure_ptr
                
                # indices of parameters, constants, and time-varying covariates
                param_inds <- 
                        setdiff(stem_object$dynamics$lna_param_codes,
                                stem_object$dynamics$lna_initdist_inds)
                const_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        seq_along(stem_object$dynamics$const_codes) - 1
                tcovar_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        length(const_inds) + seq_along(stem_object$dynamics$tcovar_codes) - 1
                
                # should initial concentrations be updated jointly with the LNA path
                joint_initdist_update = !fixed_inits & lna_ess_control$joint_initdist_update
                
                # objects for computing the SVD of the LNA diffusion matrix
                svd_U    <- diag(0.0, n_rates)
                svd_V    <- diag(0.0, n_rates)
                svd_d    <- rep(0.0, n_rates)
                
                # grab the tparam indices and update scheme
                if(!is.null(tparam)) {
                        tparam_inds <-
                                stem_object$dynamics$lna_rates$lna_param_codes[
                                        sapply(tparam, function(x) x$tparam_name)]
                }
                
        } else if(method == "ode") {
                
                # extract objects from dynamics
                flow_matrix         <- stem_object$dynamics$flow_matrix_ode
                n_compartments      <- ncol(flow_matrix)
                n_rates             <- nrow(flow_matrix)
                stoich_matrix       <- stem_object$dynamics$stoich_matrix_ode
                proc_pointer        <- stem_object$dynamics$ode_pointers$ode_ptr
                set_pars_pointer    <- stem_object$dynamics$ode_pointers$set_ode_params_ptr
                do_prevalence       <- stem_object$measurement_process$ode_prevalence
                event_inds          <- stem_object$measurement_process$incidence_codes_ode
                initdist_inds       <- stem_object$dynamics$ode_initdist_inds
                
                # measurement process
                d_meas_pointer   <- stem_object$measurement_process$meas_pointers_ode$d_measure_ptr
                
                # indices of parameters, constants, and time-varying covariates
                param_inds <- 
                        setdiff(stem_object$dynamics$param_codes, 
                                stem_object$dynamics$ode_initdist_inds)
                const_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        seq_along(stem_object$dynamics$const_codes) - 1
                tcovar_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        length(const_inds) + seq_along(stem_object$dynamics$tcovar_codes) - 1
                
                # obviously, initial distribution is its own ESS update
                joint_initdist_update = FALSE
                
                # grab the tparam indices
                if(!is.na(tparam)) {
                        tparam_inds <-
                                stem_object$dynamics$ode_rates$ode_param_codes[
                                        sapply(tparam, function(x) x$tparam_name)]
                }
        }
        
        # LNA ESS schedule --------------------------------------------------------
        if(method == "lna") {
                
                # initialize list with ESS schedule
                joint_strata_update = lna_ess_control$joint_strata_update
                ess_schedule = vector(mode = "list")
                if(joint_strata_update | n_strata == 1) {
                        ess_schedule$ess_inds = seq_len(nrow(flow_matrix))
                        
                } else {
                        ess_schedule$ess_inds =
                                lapply(paste0("_", names(stem_object$dynamics$strata_codes)),
                                       function(x) grep(x, rownames(flow_matrix)))
                }
                
                # get the complement indices for the elliptical slice sampling schedule
                ess_schedule$complementary_inds <- 
                        lapply(ess_schedule$ess_inds, 
                               function(x) setdiff(seq_len(nrow(flow_matrix)), x))
                
                # whether all strata are updated jointly
                ess_schedule$joint_strata_update = joint_strata_update
                ess_schedule$strata_codes        = stem_object$dynamics$strata_codes + 1
                
                # get the corresponding initdist codes
                if(joint_strata_update | n_strata == 1) {
                        ess_schedule$initdist_codes = c("ALL" = 1)
                } else {
                        ess_schedule$initdist_codes = 
                                match(names(ess_schedule$strata_codes), sapply(initializer, function(x) x$strata))
                }
                
                # LNA bracket width
                if(n_strata > 1 & !joint_strata_update & length(lna_ess_control$bracket_width) == 1) {
                        lna_bracket_width <- rep(lna_ess_control$bracket_width, n_strata)
                        names(lna_bracket_width) <- names(stem_object$dynamics$strata_codes)
                        
                } else {
                        lna_bracket_width = lna_ess_control$bracket_width
                }
                
                # for updating the LNA bracket width if requested
                lna_bracket_update_iter = lna_ess_control$bracket_update_iter
                
                if(lna_bracket_update_iter != Inf) {
                        lna_angle_mean  <- rep(0, length(ess_schedule[[1]]))
                        lna_angle_var   <- rep(pi^2 / 3, length(ess_schedule[[1]]))
                        lna_angle_resid <- rep(0, length(ess_schedule[[1]]))
                }
        }
        
        ### Initial distribution objects --------------------------------------------
        if(n_strata == 1) {
                comp_size_vec <- constants["popsize"]
        } else {
                comp_size_vec <- constants[paste0("popsize_", sapply(initializer,"[[","strata"))]
        }
        
        # list for initial compartment volume objects
        initdist_objects <- 
                prepare_initdist_objects(initializer = initializer,
                                         param_codes = param_codes,
                                         comp_size_vec = comp_size_vec)
        
        # initialize initdist draws
        if(!fixed_inits) {
                
                # for recording the ess initdist updates
                if(!joint_initdist_update) {
                        initdist_steps        <- 1.0
                        initdist_angle        <- 0.0
                        initdist_step_record  <- rep(1, floor(iterations / thin_params))
                        initdist_angle_record <- rep(1, floor(iterations / thin_params))
                }
                
                bad_draws        <- rep(TRUE, length(initdist_objects))
                initdist_log_lik <- rep(0.0, floor(iterations / thin_params) + 1)
                
                # map draws to initial volumes
                while(any(bad_draws)) {
                        for(s in seq_along(initdist_objects)) {
                                
                                # map draws
                                copy_vec(dest = initdist_objects[[s]]$init_volumes,
                                         orig = c(initdist_objects[[s]]$comp_mean +
                                                          c(initdist_objects[[s]]$comp_sqrt_cov %*% 
                                                              initdist_objects[[s]]$draws_cur)))
                                
                                # check boundary conditions
                                bad_draws[s] <- 
                                        any(initdist_objects[[s]]$init_volumes < 0) | 
                                        any(initdist_objects[[s]]$init_volumes > 
                                                    initdist_objects[[s]]$comp_size)
                                
                                # if outside boundaries, resample
                                if(bad_draws[s]) {
                                        initdist_objects[[s]]$draws_cur <- 
                                                rnorm(initdist_objects[[s]]$draws_cur)        
                                } 
                        }      
                }
        }
        
        # full vector of times
        times <- sort(unique(c(obstimes,
                              stem_object$dynamics$tcovar[, 1],
                              seq(stem_object$dynamics$t0,
                                  stem_object$dynamics$tmax,
                                  by = stem_object$dynamics$timestep),
                              stem_object$dynamics$tmax)))
        n_times <- length(times)
        
        # make sure no times are less than t0
        if(any(obstimes < stem_object$dynamics$t0)) {
                stop("Cannot have observations before time t0.")
        }
        
        if(any(stem_object$dynamics$tcovar[,1] < stem_object$dynamics$t0)) {
                stop("Cannot have time-varying covariates specified before time t0.")
        }
        
        # vector of times, constrained between t0 and tmax
        census_times <- 
                times[times >= min(stem_object$dynamics$t0, min(obstimes)) &
                              times <= max(stem_object$dynamics$tmax, max(obstimes))]
        census_indices   <- unique(c(0, findInterval(obstimes, census_times) - 1))
        
        # warmup iterations
        initdist_ess_warmup = ifelse(fixed_inits, 0, initdist_ess_control$ess_warmup)
        lna_ess_warmup      = ifelse(method == "ode", 0, lna_ess_control$ess_warmup)
        tparam_ess_warmup   = ifelse(is.null(stem_object$dynamics$tparam), 0, tparam_ess_control$ess_warmup)
        warmup_iterations   = max(c(lna_ess_warmup, initdist_ess_warmup, tparam_ess_warmup))
        max_adaptation      = max(sapply(param_blocks, function(x) x$control$stop_adaptation))
        
        ### Set up parameter objects ---------------------------------
        params_cur <- 
                matrix(0.0,
                       nrow = n_times,
                       ncol = n_pars_tot,
                       dimnames = list(NULL, names(param_codes)))
        
        params_prop <- 
                matrix(0.0,
                       nrow = n_times,
                       ncol = n_pars_tot,
                       dimnames = list(NULL, names(param_codes)))
        
        # insert parameters into the parameter matrix
        insert_params(parmat = params_cur, param_blocks = param_blocks, prop = FALSE)
        insert_params(parmat = params_prop, param_blocks = param_blocks, prop = FALSE)
        
        # insert initial conditions
        insert_initdist(parmat = params_cur, initdist_objects = initdist_objects, prop = FALSE)
        insert_initdist(parmat = params_prop, initdist_objects = initdist_objects, prop = FALSE)
        
        # get column indices for constants and time-varying covariates
        const_inds  <- 
                seq_along(stem_object$dynamics$const_codes) + 
                length(stem_object$dynamics$param_codes)
        tcovar_inds <- (max(const_inds) + 1):ncol(lna_params_cur)
        
        # insert the constants
        params_cur[, const_inds]  <- 
                matrix(stem_object$dynamics$constants,
                       nrow = nrow(params_cur),
                       ncol = length(const_inds), byrow = T)
        
        params_prop[, const_inds] <- 
                matrix(stem_object$dynamics$constants,
                       nrow = nrow(params_cur),
                       ncol = length(const_inds), byrow = T)
        
        # generate forcing indices and other objects
        forcing_inds   <- rep(FALSE, length(lna_census_times))
        
        # insert time varying covariates
        if (!is.null(stem_object$dynamics$tcovar)) {
                
                tcovar_rowinds <- 
                        findInterval(times, stem_object$dynamics$tcovar[, 1], left.open = F)
                params_cur[tcovar_rowinds, tcovar_inds] <- 
                        stem_object$dynamics$tcovar[tcovar_rowinds, -1]
                params_prop[tcovar_rowinds, tcovar_inds] <- stem_object$dynamics$tcovar[tcovar_rowinds, -1]
                
                # zero out forcings if necessary
                if(!is.null(stem_object$dynamics$forcings)) {
                        
                        # get the forcing indices (supplied in the original tcovar matrix)
                        for(f in seq_along(stem_object$dynamics$forcings)) {
                                forcing_inds <- 
                                        forcing_inds | 
                                        stem_object$dynamics$tcovar[stem_object$dynamics$tcovar[,1] %in% census_times, 
                                                                    stem_object$dynamics$forcings[[f]]$tcovar_name] != 0
                        }
                        
                        zero_inds    <- !forcing_inds
                        
                        # zero out the tcovar elements corresponding to times with no forcings
                        for(l in seq_along(stem_object$dynamics$dynamics_args$forcings)) {
                                params_cur[zero_inds, stem_object$dynamics$dynamics_args$forcings[[l]]$tcovar_name]  = 0
                                params_prop[zero_inds, stem_object$dynamics$dynamics_args$forcings[[l]]$tcovar_name] = 0
                        }
                }
        }
        
        
        # get indices for time-varying parameters
        if (!is.null(tparam)) {
                
                if (!joint_tparam_update) {
                        tparam_ess  <- 1
                } else {
                        tparam_ess <- NULL
                }
                
                # verify whether the mcmc is being restarted
                if (!mcmc_restart) {
                        
                        # generate the indices for updating the time-varying parameter and initialize the values
                        for (s in seq_along(tparam)) {
                                
                                # can get rid of the values slot
                                tparam[[s]]$values <- NULL
                                
                                # indices
                                tparam[[s]]$col_ind   <- param_codes[tparam[[s]]$tparam_name]
                                tparam[[s]]$tpar_inds <- findInterval(times, tparam[[s]]$times, left.open = F) - 1
                                tparam[[s]]$tpar_inds[tparam[[s]]$tpar_inds == -1] <- 0
                                
                                # values
                                tparam[[s]]$draws_cur  <- rnorm(tparam[[s]]$n_draws)
                                tparam[[s]]$draws_prop <- rnorm(tparam[[s]]$n_draws)
                                tparam[[s]]$draws_ess  <- rnorm(tparam[[s]]$n_draws)
                                tparam[[s]]$log_lik    <- sum(dnorm(tparam[[s]]$draws_cur, log = TRUE))
                                
                                # get values
                                insert_tparam(tcovar = params_cur,
                                              values = tparam[[s]]$draws2par(
                                                      parameters = params_cur[1,],
                                                      draws = tparam[[s]]$draws_cur),
                                              col_ind   = tparam[[s]]$col_ind,
                                              tpar_inds = tparam[[s]]$tpar_inds)
                                
                                # copy into lna_params_prop
                                copy_col(
                                        dest = params_prop,
                                        orig = params_cur,
                                        ind  = tparam[[s]]$col_ind
                                )
                        }
                } else {
                        
                        # if restarting, just copy the values into the parameter matrices
                        for (s in seq_along(tparam)) {
                                
                                # get values
                                insert_tparam(tcovar = params_cur,
                                              values = tparam[[s]]$draws2par(
                                                        parameters = params_cur[1,],
                                                        draws = tparam[[s]]$draws_cur),
                                              col_ind   = tparam[[s]]$col_ind,
                                              tpar_inds = tparam[[s]]$tpar_inds)
                                
                                # copy into lna_params_prop
                                copy_col(dest = params_prop,
                                         orig = params_cur,
                                         ind  = tparam[[s]]$col_ind)
                        }
                }
                
                if(tparam_ess_control$joint_tparam_update | 
                   length(tparam) == 1) {
                        tparam_steps        <- 1.0
                        tparam_angle        <- 0.0
                        tparam_step_record  <- rep(1, floor(iterations / thin_params))
                        tparam_angle_record <- rep(1, floor(iterations / thin_params))
                } else {
                        tparam_steps        <- rep(1.0, length(tparam))
                        tparam_angle        <- rep(0.0, length(tparam))
                        tparam_step_record  <- matrix(1, nrow = length(tparam), 
                                                      ncol = floor(iterations / thin_params))
                }
                
                tparam_log_lik <-
                        matrix(0.0,
                               nrow = 1 + floor(iterations / thin_params),
                               ncol = length(tparam),
                               dimnames = list(NULL, paste0(sapply(tparam, function(x) x$tparam_name),"_loglik")))
                tparam_samples <-
                        array(0.0, 
                              dim = c(n_times, length(tparam), 1 + floor(iterations / thin_params)))
                        
        } else {
                tparam              <- NULL
                tparam_steps        <- NULL
                tparam_angle        <- NULL
                tparam_step_record  <- NULL
                tparam_angle_record <- NULL
                tparam_log_lik      <- NULL
                tparam_samples      <- NULL
                tparam_log_lik      <- NULL
        }
        
        # indices for when to update the parameters
        param_update_inds <- rep(FALSE, length(census_times))
        param_update_inds[1] <- TRUE
        
        if(!is.null(stem_object$dynamics$tcovar)) {
                param_update_inds[census_times %in% stem_object$dynamics$tcovar[,1]] <- TRUE
        }
        
        if(!is.null(tparam)) {
                for(s in seq_along(tparam)) {
                        param_update_inds[census_times %in% tparam[[s]]$times] <- TRUE
                }      
        }
        
        if(length(param_update_inds) == nrow(stem_object$dynamics$tcovar_changemat)) {
                param_update_inds <- 
                        param_update_inds | apply(stem_object$dynamics$tcovar_changemat, 1, any)
        }
        
        # generate forcing objects
        if(!is.null(stem_object$dynamics$forcings)) {
                
                # names and indices
                forcing_tcovars   <- sapply(forcings, function(x) x$tcovar_name)
                forcing_tcov_inds <- match(forcing_tcovars, colnames(params_cur)) - 1
                forcing_events    <- c(sapply(forcings, function(x) paste0(x$from, "2", x$to)))
                
                # matrix indicating which compartments are involved in which forcings in and out
                forcings_out <-
                        matrix(0.0, 
                               nrow = ncol(flow_matrix), 
                               ncol = length(forcings),
                               dimnames = list(colnames(flow_matrix), 
                                               forcing_tcovars))
                
                forcing_transfers <- 
                        array(0.0, 
                              dim = c(ncol(flow_matrix),
                                      ncol(flow_matrix),
                                      length(forcings)),
                              dimnames = list(colnames(flow_matrix),
                                              colnames(flow_matrix),
                                              forcing_tcovars))
                
                for(s in seq_along(forcings)) {
                        
                        forcings_out[forcings[[s]]$from, s] <- 1
                        
                        for(t in seq_along(forcings[[s]]$from)) {
                                forcing_transfers[forcings[[s]]$from[t], forcings[[s]]$from[t], s] <- -1
                                forcing_transfers[forcings[[s]]$to[t], forcings[[s]]$from[t], s]    <- 1
                        }
                }
                
        } else {
                forcing_tcovars   <- character(0L)
                forcing_tcov_inds <- integer(0L)
                forcing_events    <- character(0L)
                forcings_out      <- matrix(0.0, nrow = 0, ncol = 0)
                forcing_transfers <- array(0.0, dim = c(0,0,0))
        }
        
        # matrix in which to store the emission probabilities
        emitmat <- cbind(dat[, 1, drop = F],
                         matrix(0.0,
                                nrow = nrow(measproc_indmat),
                                ncol = ncol(measproc_indmat),
                                dimnames = list(NULL, colnames(measproc_indmat))))
        
        pathmat_prop <- cbind(census_times,
                              matrix(0.0,
                                     nrow = length(census_times),
                                     ncol = nrow(flow_matrix),
                                     dimnames = list(NULL, c(rownames(flow_matrix)))))
        
        # set up MCMC objects
        parameter_samples_nat <-
                matrix(0.0,
                       nrow = 1 + floor(iterations / thin_params),
                       ncol = n_model_params + n_compartments,
                       dimnames = 
                               list(NULL, 
                                    c(param_names_nat, 
                                      names(stem_object$dynamics$initdist_params)))
                )
        
        parameter_samples_est <-
                matrix(0.0,
                       nrow = 1 + floor(iterations / thin_params),
                       ncol = n_model_params,
                       dimnames = list(NULL, param_names_est))
        
        # initialize the lna_param_vec for the measurement process
        param_vec <- params_cur[1,]
        
        # initialize the latent path
        path <- NULL
        if (mcmc_restart) {
                
                # extract the path
                assign("path", stem_object$stem_settings$path_for_restart)
                data_log_lik_prop <- NULL
                
                # recompute the data log likelihood
                try({
                        census_lna(
                                path                = path$latent_path,
                                census_path         = censusmat,
                                census_inds         = census_indices,
                                lna_event_inds      = lna_event_inds,
                                flow_matrix_lna     = t(stoich_matrix),
                                do_prevalence       = do_prevalence,
                                init_state          = init_volumes_cur,
                                lna_pars            = lna_params_cur,
                                forcing_inds        = forcing_inds,
                                forcing_tcov_inds   = forcing_tcov_inds,
                                forcings_out        = forcings_out,
                                forcing_transfers   = forcing_transfers
                        )
                        
                        # evaluate the density of the incidence counts
                        evaluate_d_measure_LNA(
                                emitmat           = emitmat,
                                obsmat            = data,
                                censusmat         = censusmat,
                                measproc_indmat   = measproc_indmat,
                                lna_parameters    = lna_params_cur,
                                lna_param_inds    = lna_param_inds,
                                lna_const_inds    = lna_const_inds,
                                lna_tcovar_inds   = lna_tcovar_inds,
                                param_update_inds = param_update_inds,
                                census_indices    = census_indices,
                                lna_param_vec     = lna_param_vec,
                                d_meas_ptr        = d_meas_pointer
                        )
                        
                        # compute the data log likelihood
                        data_log_lik_prop <- sum(emitmat[, -1][measproc_indmat])
                        if (is.nan(data_log_lik_prop)) data_log_lik_prop <- -Inf
                }, silent = TRUE)
                
                if (is.null(data_log_lik_prop)) {
                        stop("Restart attempted with data log likelihood of negative infinity.")
                } else {
                        path$data_log_lik <- data_log_lik_prop
                }
                
        } else {
                
                path <- initialize_lna(
                        data                    = data,
                        lna_parameters          = lna_params_cur,
                        tparam                  = tparam,
                        censusmat               = censusmat,
                        emitmat                 = emitmat,
                        stoich_matrix           = stoich_matrix,
                        lna_pointer             = lna_pointer,
                        lna_set_pars_pointer    = lna_set_pars_pointer,
                        lna_times               = lna_census_times,
                        lna_param_vec           = lna_param_vec,
                        lna_param_inds          = lna_param_inds,
                        lna_const_inds          = lna_const_inds,
                        lna_tcovar_inds         = lna_tcovar_inds,
                        lna_initdist_inds       = lna_initdist_inds,
                        param_update_inds       = param_update_inds,
                        census_indices          = census_indices,
                        lna_event_inds          = lna_event_inds,
                        measproc_indmat         = measproc_indmat,
                        d_meas_pointer          = d_meas_pointer,
                        do_prevalence           = do_prevalence,
                        forcing_inds            = forcing_inds,
                        forcing_tcov_inds       = forcing_tcov_inds,
                        forcings_out            = forcings_out,
                        forcing_transfers       = forcing_transfers,
                        initialization_attempts = initialization_attempts,
                        step_size               = step_size,
                        par_init_fcn            = par_init_fcn,
                        fixed_inits             = fixed_inits,
                        initdist_objects        = initdist_objects,
                        init_volumes_cur        = init_volumes_cur,
                        ess_warmup              = 100
                )
                
                # make sure that the model parameters are updated if new ones were proposed
                if (!is.null(par_init_fcn)) {
                        model_params_est <- to_estimation_scale(lna_params_cur[1, lna_param_inds + 1])
                        model_params_nat <- from_estimation_scale(model_params_est)
                }
        }
        
        
        
        
        class(results) <- "stemr_inference_list"
        return(results)
}