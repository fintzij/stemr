#' Fit a stochastic epidemic model using the linear noise approximation or
#' ordinary differential equations to approximate the latent epidemic process.
#'
#' @param stem_object a stochastic epidemic model object containing the dataset,
#'   model dynamics, and measurement process.
#' @param method either "lna" or ode.
#' @param mcmc_kern MCMC transition kernel generated by a call to the
#'   \code{mcmc_kernel} function.
#' @param iterations number of iterations
#' @param initialization_attempts number of initialization attempts
#' @param thin_params thinning interval for posterior parameter samples,
#'   defaults to 1
#' @param thin_latent_proc thinning interval for latent paths, defaults to
#'   ceiling(iterations/100) so that every 100th path will be saved
#' @param return_adapt_rec should the MCMC adaptation record be returned?
#'   defaults to FALSE.
#' @param print_progress interval at which to print progress to a text file. If
#'   0 (default) progress is not printed.
#' @param status_filename string to pre-append to status files, defaults to LNA
#'   or ODE depending on the method used.
#' @param messages should status messages be printed? defaults to FALSE.
#'
#' @return list with posterior samples for the parameters and the latent
#'   process, along with MCMC diagnostics.
#' @export
fit_stem <-
        function(stem_object,
                 method,
                 mcmc_kern,
                 iterations,
                 initialization_attempts = 500,
                 thin_params = ceiling(iterations / 100),
                 thin_latent_proc = ceiling(iterations / 100),
                 return_adapt_rec = FALSE,
                 print_progress = 0,
                 status_filename = NULL,
                 messages = FALSE) {
            
        # check that the data, dynamics and measurement process are all supplied
        if(is.null(stem_object$measurement_process$data) ||
            is.null(stem_object$dynamics) ||
            is.null(stem_object$measurement_process)) {
                stop("The dataset, dynamics, and measurement process must all be specified.")
        }
        
        # check that the appropriate model object is compiled
        if(method == "lna") {
                if(is.null(stem_object$dynamics$lna_pointers)) {
                        stop("LNA is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "LNA"
                
        } else if(method == "ode") {
                if(is.null(stem_object$dynamics$ode_pointers)) {
                        stop("ODE is not compiled.")
                }
                
                if(is.null(status_filename)) status_filename <- "ODE"
        }
                
        # if the MCMC is being restarted, save the existing results
        mcmc_restart <- !is.null(stem_object$stem_settings$restart_objects)
        
        # grab parameter names
        parameters      <- stem_object$dynamics$parameters
        param_names_nat <- names(stem_object$dynamics$param_codes)
        param_names_est <- c(sapply(mcmc_kern$parameter_blocks, function(x) x$pars_est))
        n_model_params  <- length(param_names_est)
        
        # unpack mcmc kernel
        param_blocks         = mcmc_kern$parameter_blocks
        lna_ess_control      = mcmc_kern$lna_ess_control
        initdist_ess_control = mcmc_kern$initdist_ess_control
        tparam_ess_control   = mcmc_kern$tparam_ess_control
        
        # prepare param_blocks
        param_blocks <- 
                prep_param_blocks(param_blocks = param_blocks, 
                                  parameters = parameters,
                                  iterations = iterations)
        
        # progress printing interval
        if(print_progress != 0) {
                progress_interval <- print_progress
                print_progress <- TRUE
        } else {
                progress_interval <- NULL
                print_progress <- FALSE
        }
        
        ### Unpack stem_object-------------------------
        
        # dynamics that are not method specific
        censusmat           <- stem_object$measurement_process$censusmat
        constants           <- stem_object$dynamics$constants
        initializer         <- stem_object$dynamics$initializer
        fixed_inits         <- stem_object$dynamics$fixed_inits
        n_strata            <- stem_object$dynamics$n_strata
        initdist_params_cur <- as.numeric(stem_object$dynamics$initdist_params)
        t0                  <- stem_object$dynamics$t0
        step_size           <- stem_object$dynamics$dynamics_args$step_size
        
        # measurement process objects that are not method specific
        measproc_indmat <- stem_object$measurement_process$measproc_indmat
        dat             <- stem_object$measurement_process$obsmat
        obstimes        <- stem_object$measurement_process$obstimes
        
        # dynamics and measurement process objects that are method specific
        if(method == "lna") {
                
                # extract objects from dynamics
                flow_matrix      <- stem_object$dynamics$flow_matrix_lna
                n_compartments   <- ncol(flow_matrix)
                n_rates          <- nrow(flow_matrix)
                stoich_matrix    <- stem_object$dynamics$stoich_matrix_lna
                proc_pointer     <- stem_object$dynamics$lna_pointers$lna_ptr
                set_pars_pointer <- stem_object$dynamics$lna_pointers$set_lna_params_ptr
                do_prevalence    <- stem_object$measurement_process$lna_prevalence
                event_inds       <- stem_object$measurement_process$incidence_codes_lna
                initdist_inds    <- stem_object$dynamics$lna_initdist_inds
                
                # measurement process
                d_meas_pointer   <- stem_object$measurement_process$meas_pointers_lna$d_measure_ptr
                
                # indices of parameters, constants, and time-varying covariates
                param_inds <- 
                        setdiff(stem_object$dynamics$lna_param_codes,
                                stem_object$dynamics$lna_initdist_inds)
                const_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        seq_along(stem_object$dynamics$const_codes) - 1
                tcovar_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        length(const_inds) + seq_along(stem_object$dynamics$tcovar_codes) - 1
                
                # should initial concentrations be updated jointly with the LNA path
                joint_initdist_update = !fixed_inits & lna_ess_control$joint_initdist_update
                
                # objects for computing the SVD of the LNA diffusion matrix
                svd_U    <- diag(0.0, n_rates)
                svd_V    <- diag(0.0, n_rates)
                svd_d    <- rep(0.0, n_rates)
                
        } else if(method == "ode") {
                
                # extract objects from dynamics
                flow_matrix         <- stem_object$dynamics$flow_matrix_ode
                n_compartments      <- ncol(flow_matrix)
                n_rates             <- nrow(flow_matrix)
                stoich_matrix       <- stem_object$dynamics$stoich_matrix_ode
                proc_pointer        <- stem_object$dynamics$ode_pointers$ode_ptr
                set_pars_pointer    <- stem_object$dynamics$ode_pointers$set_ode_params_ptr
                do_prevalence       <- stem_object$measurement_process$ode_prevalence
                event_inds          <- stem_object$measurement_process$incidence_codes_ode
                initdist_inds       <- stem_object$dynamics$ode_initdist_inds
                
                # measurement process
                d_meas_pointer   <- stem_object$measurement_process$meas_pointers_ode$d_measure_ptr
                
                # indices of parameters, constants, and time-varying covariates
                param_inds <- 
                        setdiff(stem_object$dynamics$param_codes, 
                                stem_object$dynamics$ode_initdist_inds)
                const_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        seq_along(stem_object$dynamics$const_codes) - 1
                tcovar_inds <- 
                        length(stem_object$dynamics$param_codes) + 
                        length(const_inds) + seq_along(stem_object$dynamics$tcovar_codes) - 1
                
                # obviously, initial distribution is its own ESS update
                joint_initdist_update = FALSE
        }
        
        # LNA ESS schedule --------------------------------------------------------
        if(method == "lna") {
                
                # initialize list with ESS schedule
                joint_strata_update = lna_ess_control$joint_strata_update
                ess_schedule = vector(mode = "list")
                if(joint_strata_update | n_strata == 1) {
                        ess_schedule$ess_inds = seq_len(nrow(flow_matrix))
                        
                } else {
                        ess_schedule$ess_inds =
                                lapply(paste0("_", names(stem_object$dynamics$strata_codes)),
                                       function(x) grep(x, rownames(flow_matrix)))
                }
                
                # get the complement indices for the elliptical slice sampling schedule
                ess_schedule$complementary_inds <- 
                        lapply(ess_schedule$ess_inds, 
                               function(x) setdiff(seq_len(nrow(flow_matrix)), x))
                
                # whether all strata are updated jointly
                ess_schedule$joint_strata_update = joint_strata_update
                ess_schedule$strata_codes        = stem_object$dynamics$strata_codes + 1
                
                # get the corresponding initdist codes
                if(joint_strata_update | n_strata == 1) {
                        ess_schedule$initdist_codes = c("ALL" = 1)
                } else {
                        ess_schedule$initdist_codes = 
                                match(names(ess_schedule$strata_codes), sapply(initializer, function(x) x$strata))
                }
                
                # LNA bracket width
                if(n_strata > 1 & !joint_strata_update & length(lna_ess_control$bracket_width) == 1) {
                        lna_bracket_width <- rep(lna_ess_control$bracket_width, n_strata)
                        names(lna_bracket_width) <- names(stem_object$dynamics$strata_codes)
                        
                } else {
                        lna_bracket_width = lna_ess_control$bracket_width
                }
                
                # for updating the LNA bracket width if requested
                lna_bracket_update_iter = lna_ess_control$bracket_update_iter
                
                if(lna_bracket_update_iter != Inf) {
                        lna_angle_mean  <- rep(0, length(ess_schedule[[1]]))
                        lna_angle_var   <- rep(pi^2 / 3, length(ess_schedule[[1]]))
                        lna_angle_resid <- rep(0, length(ess_schedule[[1]]))
                }
        }
        
        ### Initial distribution objects --------------------------------------------
        if(n_strata == 1) {
                comp_size_vec <- constants["popsize"]
        } else {
                comp_size_vec <- constants[paste0("popsize_", sapply(initializer,"[[","strata"))]
        }
        
        # list for initial compartment volume objects
        initdist_objects <- vector("list", length = n_strata)
        for(t in seq_len(n_strata)) {
                
                # hyperparameters
                comp_prior <- 
                        if(!initializer[[t]]$fixed) {
                                if(!is.null(initializer[[t]]$prior)) {
                                        if(comp_size_vec[t] != 0) {
                                                initializer[[t]]$prior
                                        } else {
                                                rep(0.0, length(initializer[[t]]$init_states))
                                        }
                                } else {
                                        if(comp_size_vec[t] != 0) {
                                                initializer[[t]]$init_states
                                        } else {
                                                rep(0.0, length(initializer[[t]]$init_states))     
                                        }
                                }
                        } else {
                                if(comp_size_vec[t] != 0) {
                                        initializer[[t]]$init_states
                                } else {
                                        rep(0.0, length(initializer[[t]]$init_states))     
                                }
                        }
                
                # compartment probabilities
                comp_probs <- if(sum(comp_prior) != 0) {
                        comp_prior / sum(comp_prior)
                } else {
                        rep(0.0, length(comp_prior))
                }
                
                # unconstrained moments
                comp_mean  <- comp_size_vec[t] * comp_probs
                comp_cov   <- comp_size_vec[t] * (diag(comp_probs) - comp_probs %*% t(comp_probs)) 
                
                if(initializer[[t]]$dist == "dirmultinom") 
                        comp_cov <- comp_cov * ((comp_size_vec[t] + sum(comp_prior))/(1 + sum(comp_prior))) 
                
                comp_cov_svd <- svd(comp_cov)
                comp_cov_svd$d[length(comp_cov_svd$d)] <- 0
                comp_sqrt_cov <- comp_cov_svd$u %*% diag(sqrt(comp_cov_svd$d))
                
                initdist_objects[[t]] <- 
                        list(
                                stratum            = initializer[[t]]$strata,
                                fixed              = initializer[[t]]$fixed,
                                comp_size          = comp_size_vec[t],
                                comp_mean          = comp_mean,
                                comp_sqrt_cov      = comp_sqrt_cov[,-length(comp_mean)],
                                draws_cur          = rnorm(length(comp_mean)-1),
                                draws_prop         = rnorm(length(comp_mean)-1),
                                draws_ess          = rnorm(length(comp_mean)-1),
                                comp_inds_R        = initializer[[t]]$codes,
                                comp_inds_Cpp      = initializer[[t]]$codes - 1
                        )
        }
        
        # names of initial compartment volumes
        convrec_initvol_names <- names(stem_object$dynamics$initdist_params)
        
        # vector for the initial compartment volumes
        init_volumes_cur  <- rep(0.0, n_compartments); copy_vec(init_volumes_cur, initdist_params_cur)
        init_volumes_prop <- rep(0.0, n_compartments); copy_vec(init_volumes_prop, initdist_params_cur)
        names(init_volumes_prop) <- names(init_volumes_cur) <- names(initdist_params_cur)
        
        # initialize initdist draws
        if(!fixed_inits) {
                
                # for recording the ess initdist updates
                if(!joint_initdist_update) {
                        initdist_steps        <- 1.0
                        initdist_angle        <- 0.0
                        initdist_step_record  <- rep(1, floor(iterations / thin_params))
                        initdist_angle_record <- rep(1, floor(iterations / thin_params))
                }
                
                bad_draws             <- rep(TRUE, length(initdist_objects))
                initdist_log_lik <- rep(0.0, floor(iterations / thin_params) + 1)
                
                # map draws to initial volumes
                while(any(bad_draws)) {
                        for(s in seq_along(initdist_objects)) {
                                
                                # map draws
                                copy_vec2(dest = init_volumes_cur,
                                          orig = c(initdist_objects[[s]]$comp_mean + 
                                                           c(initdist_objects[[s]]$comp_sqrt_cov %*% initdist_objects[[s]]$draws_cur)),
                                          inds = initdist_objects[[s]]$comp_inds_Cpp)
                                
                                # check boundary conditions
                                bad_draws[s] <- 
                                        any(init_volumes_cur[initdist_objects[[s]]$comp_inds_R] < 0) | 
                                        any(init_volumes_cur[initdist_objects[[s]]$comp_inds_R] > initdist_objects[[s]]$comp_size)
                                
                                # if outside boundaries, resample
                                if(bad_draws[s]) initdist_objects[[s]]$draws_cur <- rnorm(initdist_objects[[s]]$draws_cur)
                        }      
                }
        }
        
        # vectors for storing the model parameters on their natural and estimation scales
        # model_params_nat -- model parameters on their natural scales
        # model_params_est -- model parameters on their estimation scales
        model_params_nat <- double(n_model_params) 
        copy_vec(model_params_nat, parameters[param_names_nat])
        
        model_params_est <- double(n_model_params)
        for(s in seq_along(to_est_scale)) {
                model_params_est[param_inds_est[[s]]] = 
                        to_est_scale[[s]](model_params_nat[param_inds_nat[[s]]])
        }
        
        # analogous vectors for parameter proposals
        params_prop_nat = double(n_model_params)
        params_prop_est = double(n_model_params)
        copy_vec(params_prop_nat, model_params_nat)
        copy_vec(params_prop_est, model_params_est)
        
        # name vectors
        names(model_params_nat) = param_names_nat
        names(params_prop_nat)  = param_names_nat
        names(model_params_est) = param_names_est
        names(params_prop_est)  = param_names_est
        
        # full vector of times
        times <- sort(unique(c(obstimes,
                              stem_object$dynamics$tcovar[, 1],
                              seq(stem_object$dynamics$t0,
                                  stem_object$dynamics$tmax,
                                  by = stem_object$dynamics$timestep),
                              stem_object$dynamics$tmax)))
        n_times <- length(times)
        
        # make sure no times are less than t0
        if(any(obstimes < stem_object$dynamics$t0)) {
                stop("Cannot have observations before time t0.")
        }
        
        if(any(stem_object$dynamics$tcovar[,1] < stem_object$dynamics$t0)) {
                stop("Cannot have time-varying covariates specified before time t0.")
        }
        
        # vector of times, constrained between t0 and tmax
        census_times <- 
                times[times >= min(stem_object$dynamics$t0, min(obstimes)) &
                              times <= max(stem_object$dynamics$tmax, max(obstimes))]
        census_indices   <- unique(c(0, findInterval(obstimes, census_times) - 1))
        
        # warmup iterations
        initdist_ess_warmup = ifelse(fixed_inits, 0, initdist_ess_control$ess_warmup)
        lna_ess_warmup      = ifelse(method == "ode", 0, lna_ess_control$ess_warmup)
        tparam_ess_warmup   = ifelse(is.null(stem_object$dynamics$tparam), 0, tparam_ess_control$ess_warmup)
        warmup_iterations   = max(c(lna_ess_warmup, initdist_ess_warmup, tparam_ess_warmup))
        
        ### Set up MCMC kernel ---------------------------------
        max_adaptation = max(sapply(param_blocks, function(x) x$control$stop_adaptation))
        
        for(s in seq_along(param_blocks)) {
                # generate sequence of gain factors
                param_blocks[[s]]$adaptations <- 
                        pmin(1, param_blocks[[s]]$control$scale_constant *
                                     (seq(0, iterations) * 
                                              param_blocks[[s]]$control$step_size + 
                                              param_blocks[[s]]$control$adaptation_offset + 1) ^ 
                                     -param_blocks[[s]]$control$scale_cooling)
                
                # set nugget step size if it wasn't specified
                if(is.null(param_blocks[[s]]$control$nugget_step_size)) {
                        param_blocks[[s]]$control$nugget_step_size = 
                                100 / iterations
                }
                
                # set the nugget sequence
                param_blocks[[s]]$nugget_sequence = 
                        param_blocks[[s]]$control$nugget * 
                        (seq(0, iterations) * 
                                 param_blocks[[s]]$control$nugget_step_size + 1) ^ 
                        -param_blocks[[s]]$control$nugget_cooling
                
                
        }
        
        # grab time-varying parameters
        if(mcmc_restart) {
                tparam <- stem_object$stem_settings$tparam_for_restart
        } else {
                tparam <- stem_object$dynamics$tparam
        }
        
        class(results) <- "stemr_inference_list"
        return(results)
}