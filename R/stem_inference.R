#' Perform inference for a stochastic epidemic model using either the linear
#' noise approximation or agent-based Bayesian data augmentation.
#'
#' @param stem_object a stochastic epidemic model object containing the dataset,
#'   model dynamics, and measurement process.
#' @param method either "lna" or "bda"
#' @param iterations number of iterations
#' @param priors list of priors for model parameters, each generated by a call
#'   to the \link{\code{prior}} function. Should not include priors for the
#'   initial compartment counts, which are specified in the
#'   \code{\link{stem_initializer}} function.
#' @param kernel MCMC transition kernel generated by a call to the
#'   \link{\code{kernel}} function. RWMH and adaptive RWMH are implemented for
#'   jointly updating the model parameters (not including the initial
#'   compartment counts which are handled separately).
#' @param t0_kernel output of \link{\code{t0_kernel}}, specifying the RWMH
#'   transition kernel for t0 and the truncated normal distribution prior.
#' @param thin_params thinning interval for posterior parameter samples,
#'   defaults to 1
#' @param thin_latent_proc thinning interval for latent paths, defaults to
#'   ceiling(iterations/100) so that every 100th path will be saved
#' @param messages should status messages be printed? defaults to TRUE.
#' @param monitor_MCMC should MCMC output be generated for the purposes of
#'   monitoring convergence (defaults to FALSE)? If so, the acceptance rate and
#'   the proposal covariance matrix (if adaptive RWMH is used) are printed
#'   whenever messages are printed.
#'
#' @return list with posterior samples for the parameters and the latent
#'   process, along with MCMC diagnostics.
#' @export
stem_inference <- function(stem_object, method, iterations, priors, kernel, t0_kernel = NULL, thin_params = 1, thin_latent_proc = ceiling(iterations/100), initialization_attempts = 500, messages = FALSE, monitor_MCMC = FALSE) {

        # check that the data, dynamics and measurement process are all supplied
        if (is.null(stem_object$measurement_process$data) ||
            is.null(stem_object$dynamics) ||
            is.null(stem_object$measurement_process)) {
                stop("The dataset, dynamics, and measurement process must all be specified.")
        }

        # check that the kernel for t0 was provided if t0 is not fixed
        if(!stem_object$dynamics$t0_fixed && is.null(t0_kernel)) {
                stop("An MCMC transition kernel must be provided for t0 if it is not fixed.")
        }

        # set the upper and lower bounds for t0_kernel if they are not supplied
        if(!is.null(t0_kernel)) {
                t0_kernel$upper <- min(t0_kernel$upper, min(stem_object$measurement_process$obstimes))
                t0_kernel$lower <- max(t0_kernel$lower, -Inf)
        }

        # construct prior density functions
        estimation_scales <- sapply(priors, "[[", "scale")
        prior_density     <- construct_priors(priors = priors, param_codes = stem_object$dynamics$param_codes)

        if(method == "lna") {

                # get the results
                results <- stem_inference_lna(stem_object             = stem_object,
                                              iterations              = iterations,
                                              prior_density           = prior_density,
                                              kernel                  = kernel,
                                              t0_kernel               = t0_kernel,
                                              estimation_scales       = estimation_scales,
                                              thin_params             = thin_params,
                                              thin_latent_proc        = thin_latent_proc,
                                              initialization_attempts = initialization_attempts,
                                              messages                = messages,
                                              monitor_MCMC            = monitor_MCMC)

        } else if (method == "bda") {
                print("bda not yet implemented")
                # # check that the required objects are present in the stem object
                # check_stem_object(stem_object, method = "bda")
#
#                 # get the results
#                 results <- stem_inference_lna(stem_object,
#                                               iterations,
#                                               prior_dists,
#                                               proposal_kernels,
#                                               thin_params,
#                                               thin_latent_proc,
#                                               messages)
        }

        return(results)
}