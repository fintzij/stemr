#' Approximate Bayesian inference for a stochastic epidemic model via the linear
#' noise approximation.
#'
#' @param stem_object stochastic epidemic model object with model dynamics, the
#'   measurement process, and a dataset.
#' @param iterations number of MCMC iterations
#' @param prior_density function to compute the prior density for the model
#'   parameters
#' @param kernels list of mcmc transition kernels for model parameters, each
#'   generated by a call to the \code{\link{kernel}} function
#' @param estimation_scales character vector of estimation scales, each the
#'   result of a
#' @param thin_params thinning interval for posterior parameter samples,
#'   defaults to 1
#' @param thin_latent_proc thinning interval for latent paths, defaults to
#'   ceiling(iterations/100)
#' @param initialization_attempts number of attempts to initialize the latent
#'   path before breaking.
#' @param messages should status messages be printed? defaults to TRUE.
#'
#' @return list with parameter posterior samples and MCMC diagnostics
#' @export
stem_inference_lna <- function(stem_object, iterations, prior_density, kernels, estimation_scales, thin_params, thin_latent_proc, initialization_attempts = 500, messages) {

        # extract the model objects from the stem_object
        flow_matrix            <- stem_object$dynamics$flow_matrix_lna
        lna_pointer            <- stem_object$dynamics$lna_pointers$lna_pointer
        lna_pointer_ess        <- stem_object$dynamics$lna_pointers$lna_pointer_ess
        lna_set_pars_pointer   <- stem_object$dynamics$lna_pointers$lna_set_pars_ptr
        parameters             <- stem_object$dynamics$parameters
        constants              <- stem_object$dynamics$constants
        initdist_parameters    <- stem_object$dynamics$initdist_params
        lna_initdist_inds      <- stem_object$dynamics$lna_initdist_inds
        n_compartments         <- ncol(flow_matrix)
        n_rates                <- nrow(flow_matrix)
        n_odes                 <- 2*n_rates + n_rates^2
        comp_codes             <- stem_object$dynamics$lna_comp_codes
        incidence_codes        <- stem_object$dynamics$incidence_codes_lna
        n_incidence            <- length(incidence_codes)
        fixed_inits            <- stem_object$dynamics$fixed_inits
        n_strata               <- stem_object$dynamics$n_strata

        # set up MCMC objects
        parameter_samples <- matrix(0.0, nrow = 1 + floor(iterations / thin_params),
                                    ncol = length(stem_object$dynamics$parameters))
        acceptances       <- matrix(0, nrow = iterations + 1, ncol = length(stem_object$dynamics$parameters))
        latent_paths      <- vector(mode = "list", length = 1 + floor(iterations / thin_latent_proc))
        lna_log_lik       <- double(1 + floor(iterations / thin_params))
        data_log_lik      <- double(1 + floor(iterations / thin_params))
        log_prior         <- double(1 + floor(iterations / thin_params))

        # depracated code for initialization function         # create the initialization function
        # if(fixed_inits) {
        #
        #         if(n_strata == 1) {
        #                 param_inds     <- stem_object$dynamics$state_initializer$param_inds # initial distribution parameter indices
        #                 initdist_codes <- stem_object$dynamics$state_initializer$codes # codes, by compartment then stratum
        #         } else {
        #                 param_inds     <- unlist(lapply(stem_object$dynamics$state_initializer, function(x) x$param_inds))
        #                 initdist_codes <- unlist(lapply(stem_object$dynamics$state_initializer, function(x) x$codes))
        #         }
        #
        #         # reorder the initial distribution parameters
        #         initdist_parameters <- as.numeric(initdist_parameters[order(initdist_codes)])
        #
        #         # there is no kernel for the initial state parameters
        #         initdist_kernel <- NULL
        #
        # } else {
        #         warning("The case for non-fixed initial distribution parameters is not yet implemented.")
        #         initdist_parameters <- NULL
        # }

        # compute the prior density of the parameters
        log_prior[1] <- prior_density(parameters)

        # measurement process objects
        data                    <- stem_object$measurement_process$data
        measproc_indmat         <- stem_object$measurement_process$measproc_indmat
        d_meas_pointer          <- stem_object$measurement_process$meas_pointers$d_measure_ptr
        obstimes                <- data[,1]
        obstime_inds            <- stem_object$measurement_process$obstime_inds
        tcovar_censmat          <- stem_object$measurement_process$tcovar_censmat
        emit_mat_cur            <- cbind(obstimes, matrix(0.0,
                                                           nrow = nrow(stem_object$measurement_process$measproc_indmat),
                                                           ncol = ncol(stem_object$measurement_process$measproc_indmat),
                                                           dimnames = list(NULL,
                                                                           colnames(stem_object$measurement_process$measproc_indmat))))
        emit_mat_new            <- cbind(obstimes, matrix(0.0,
                                                           nrow = nrow(stem_object$measurement_process$measproc_indmat),
                                                           ncol = ncol(stem_object$measurement_process$measproc_indmat),
                                                           dimnames = list(NULL,
                                                                           colnames(stem_object$measurement_process$measproc_indmat))))

        # generate other derived objects
        lna_times               <- sort(unique(c(obstimes,
                                               stem_object$dynamics$.dynamics_args$tcovar[,1],
                                               stem_object$dynamics$t0,
                                               stem_object$dynamics$tmax)))
        n_times                 <- length(lna_times)
        n_census_times          <- length(obstimes)
        param_update_inds       <- is.na(match(lna_times, obstimes))
        do_census               <- !identical(lna_times, data[,1])
        do_incidence            <- !is.null(incidence_codes)

        # matrix for storing the LNA parameters
        lna_parameters         <- matrix(0.0, nrow = length(lna_times), ncol = length(stem_object$dynamics$lna_param_codes),
                                          dimnames = list(NULL,names(stem_object$dynamics$lna_param_codes)))

        # insert the lna parameters
        pars2lnapars(lna_parameters, parameters)

        # get column indices for constants and time-varying covariates
        const_inds             <- seq_along(stem_object$dynamics$const_codes) + length(stem_object$dynamics$param_codes)
        tcovar_inds            <- (max(const_inds)+1):ncol(lna_parameters)

        # insert the constants
        lna_parameters[,const_inds] <- matrix(stem_object$dynamics$constants,
                                          nrow = nrow(lna_parameters),
                                          ncol = length(const_inds), byrow = T)

        # insert time varying covariates
        if(!is.null(stem_object$dynamics$dynamics_args$tcovar)) {
                tcovar_rowinds                 <- findInterval(lna_times, stem_object$dynamics$.dynamics_args$tcovar[,1])
                lna_parameters[, tcovar_inds]  <- stem_object$dynamics$.dynamics_args$tcovar[tcovar_rowinds,-1]
        }

        # initialize the latent path
        path <- initialize_lna(lna_parameters          = lna_parameters,
                               flow_matrix             = flow_matrix,
                               lna_pointer             = lna_pointer,
                               lna_set_pars_pointer    = lna_set_pars_pointer,
                               lna_times               = lna_times,
                               fixed_inits             = fixed_inits,
                               param_update_inds       = param_update_inds,
                               incidence_codes         = incidence_codes,
                               data                    = data,
                               measproc_indmat         = measproc_indmat,
                               obstime_inds            = obstime_inds,
                               d_meas_pointer          = d_meas_pointer,
                               parameters              = parameters,
                               constants               = constants,
                               tcovar_censmat          = tcovar_censmat,
                               initialization_attempts = initialization_attempts)

        # save the current observed data log-likelihood and compute the
        # likelihood of the latent LNA path
        path <- lna_density2(path              = path,
                             lna_times         = lna_times,
                             lna_pars          = lna_parameters,
                             param_update_inds = param_update_inds,
                             flow_matrix       = flow_matrix,
                             lna_pointer_ess   = lna_pointer_ess,
                             set_pars_pointer  = lna_set_pars_pointer)

        # save the data log-likelihood and the lna log-likelihood
        data_log_lik[1] <- path$data_log_lik
        lna_log_lik[1]  <- path$lna_log_lik

        # begin the MCMC
        start.time <- Sys.time()
        for(k in (seq_len(iterations) + 1)) {

                # print the status if messages are enabled
                if(messages && k%%thin_latent_proc == 0) {
                        print(k)
                }

                # update the path via elliptical slice sampling
                path <- update_lna_path(path_cur            = path,
                                        lna_parameters      = lna_parameters,
                                        stoich_matrix       = stoich_matrix,
                                        lna_ess_pointer     = lna_ess_pointer,
                                        lna_times           = lna_times,
                                        lna_initdist_inds   = lna_initdist_inds,
                                        fixed_inits         = fixed_inits,
                                        param_update_inds   = param_update_inds,
                                        drift_inds          = drift_inds,
                                        resid_inds          = resid_inds,
                                        incidence_codes     = incidence_codes,
                                        data                = data,
                                        measproc_indmat     = measproc_indmat,
                                        obstime_inds        = obstime_inds,
                                        d_meas_pointer      = d_meas_pointer,
                                        parameters          = parameters,
                                        constants           = constants,
                                        tcovar_censmat      = tcovar_censmat,
                                        do_census           = do_census,
                                        do_incidence        = do_incidence)

                compute_lna_density(path = path$path, fixed_inits = fixed_inits,
                                    log_scale = log_scale, incidence_codes = incidence_codes)

                compute_lna_density2(path              = path$path,
                                     parameters        = lna_parameters,
                                     stoich_matrix     = stoich_matrix,
                                     lna_pointer       = lna_pointer,
                                     times             = lna_times,
                                     param_update_inds = param_update_inds,
                                     drift_inds        = drift_inds,
                                     resid_inds        = resid_inds,
                                     diff_inds         = diff_inds,
                                     log_scale         = log_scale,
                                     incidence_codes   = incidence_codes,
                                     fixed_inits       = fixed_inits)
        }

}